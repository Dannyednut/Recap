{"file_contents":{"main.py":{"content":"import asyncio\nfrom dataclasses import asdict\nfrom quart import Quart, jsonify, request\nfrom datetime import datetime\n\n# Custom imports\nfrom cex.config import Config\nfrom cex.models import TradeResult\nfrom cex.arbitrage import ArbitrageApp, logger\n\n# DEX imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), 'dex'))\n\n# Import just the Ethereum service directly (avoiding complex orchestrator imports)\ntry:\n    from ethereum_service.service import EthereumArbitrageService\n    from ethereum_service.config import EthereumConfig\n    DEX_AVAILABLE = True\nexcept ImportError as e:\n    logger.warning(f\"DEX imports failed: {e}\")\n    DEX_AVAILABLE = False\n\n\n# --- Quart App and Global App Instance ---\napp = Quart(__name__)\narbitrage_app = ArbitrageApp(Config())\n\n# Global DEX service (Ethereum only for now)\nethereum_dex_service = None\n\n# Simple API key auth header name\nAPI_KEY_HEADER = \"X-API-KEY\"\n\n\n@app.route('/')\nasync def index():\n    return \"Hello there, I'm busy working\"\n\n\n@app.route('/balances', methods=['GET'])\nasync def get_balances():\n    cex_balances = arbitrage_app.engine.account_balances or {}\n    \n    # Get DEX balances if available\n    dex_balances = {}\n    if ethereum_dex_service:\n        try:\n            eth_status = await ethereum_dex_service.get_status()\n            dex_balances = {\"ethereum\": eth_status}\n        except Exception as e:\n            logger.warning(f\"Failed to get DEX balances: {e}\")\n    \n    return jsonify({\n        \"cex\": cex_balances,\n        \"dex\": dex_balances,\n        \"timestamp\": datetime.now().isoformat()\n    })\n\n\n@app.route('/execute', methods=['POST'])\nasync def execute_trade_endpoint():\n    # Require API key header for API-triggered execution\n    api_key = request.headers.get(API_KEY_HEADER) or request.args.get('api_key')\n    if not api_key:\n        return jsonify({\"status\": \"error\", \"message\": \"API key required\"}), 401\n    \n    data = await request.get_json()\n    if not data or not all(k in data for k in ['opportunity_id', 'type', 'strategy']):\n        return jsonify({\"status\": \"error\", \"message\": \"Missing required parameters\"}), 400\n\n    # Pass the auth key into execute_trade_logic which performs auth validation\n    try:\n        result = await arbitrage_app.execute_trade_logic(data, auth_key=api_key)\n        status_code = 200 if result.status == 'success' else 400\n\n        if 'chat_id' in data and arbitrage_app.notifier:\n            await arbitrage_app.notifier.send_trade_result(int(data['chat_id']), result)\n\n        return jsonify(asdict(result)), status_code\n\n    except asyncio.TimeoutError:\n        return jsonify({\"status\": \"error\", \"message\": \"Trade execution timed out.\"}), 504\n    except Exception as e:\n        logger.error(f\"API endpoint error: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": \"An internal server error occurred.\"}), 500\n\n\n# DISABLED: Insecure telegram webhook - requires signature verification\n# @app.route('/telegram-webhook', methods=['POST'])\nasync def _disabled_telegram_webhook():\n    data = await request.get_json()\n\n    if 'callback_query' in data:\n        callback = data['callback_query']\n        chat_id = callback['message']['chat']['id']\n        if str(chat_id) != str(Config.TELEGRAM_CHAT_ID):\n            return jsonify(ok=True)  # ignore non-whitelisted chats\n\n        data_str = callback['data']  # expecting format like \"exec|instant|opid\"\n        parts = data_str.split('|')\n        if len(parts) != 3:\n            return jsonify(ok=True)\n\n        action, subtype, opportunity_id = parts\n        if action == \"exec\":\n            exec_payload = {\n                \"type\": \"cross\" if subtype in (\"instant\", \"transfer\") else \"triangular\",\n                \"strategy\": subtype,\n                \"opportunity_id\": opportunity_id,\n                \"chat_id\": chat_id\n            }\n            try:\n                result = await arbitrage_app.execute_trade_logic(exec_payload, auth_key=Config.BASE44_APP_TOKEN)\n                if result.status != \"success\":\n                    logger.error(f\"Trade execution from Telegram button failed: {result.message}\")\n                    result = TradeResult(\"error\", f\"Trade execution failed: {result.message}\")\n            except Exception as e:\n                logger.error(f\"Error executing trade from Telegram button: {e}\")\n                result = TradeResult(\"error\", \"Failed to execute trade from Telegram button.\")\n\n            if arbitrage_app.notifier:\n                await arbitrage_app.notifier.send_trade_result(chat_id, result)\n\n    return jsonify(ok=True)\n\n\n@app.route('/dex/status', methods=['GET'])\nasync def get_dex_status():\n    \"\"\"Get DEX system status\"\"\"\n    if not ethereum_dex_service:\n        return jsonify({\"status\": \"not_initialized\", \"available\": DEX_AVAILABLE}), 503\n    \n    try:\n        status = await ethereum_dex_service.get_status()\n        return jsonify({\"ethereum\": status, \"status\": \"initialized\"})\n    except Exception as e:\n        logger.error(f\"Error getting DEX status: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n\n\n@app.route('/dex/opportunities', methods=['GET'])\nasync def get_dex_opportunities():\n    \"\"\"Get DEX arbitrage opportunities\"\"\"\n    if not ethereum_dex_service:\n        return jsonify({\"status\": \"error\", \"message\": \"DEX system not initialized\"}), 503\n    \n    try:\n        # For now, just return placeholder - the service needs proper opportunity scanning\n        opportunities = {\"ethereum\": \"scanning_not_implemented_yet\"}\n        return jsonify({\n            \"opportunities\": opportunities,\n            \"chains\": [\"ethereum\"],\n            \"timestamp\": datetime.now().isoformat()\n        })\n    except Exception as e:\n        logger.error(f\"Error scanning DEX opportunities: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n\n\n@app.route('/system/status', methods=['GET'])\nasync def get_system_status():\n    \"\"\"Get comprehensive system status\"\"\"\n    cex_status = {\n        \"running\": True,\n        \"exchanges\": len(arbitrage_app.engine.exchanges),\n        \"balances_loaded\": bool(arbitrage_app.engine.account_balances)\n    }\n    \n    dex_status = {\"initialized\": False, \"available\": DEX_AVAILABLE}\n    if ethereum_dex_service:\n        try:\n            eth_status = await ethereum_dex_service.get_status()\n            dex_status = {\"initialized\": True, \"ethereum\": eth_status}\n        except Exception as e:\n            dex_status = {\"error\": str(e)}\n    \n    return jsonify({\n        \"cex\": cex_status,\n        \"dex\": dex_status,\n        \"timestamp\": datetime.now().isoformat()\n    })\n\n\n# --- Main Entry Point ---\nif __name__ == \"__main__\":\n\n    async def main():\n        global ethereum_dex_service\n        try:\n            # Initialize DEX system (Ethereum only for now)\n            if DEX_AVAILABLE:\n                logger.info(\"Initializing Ethereum DEX service...\")\n                try:\n                    ethereum_config = EthereumConfig()\n                    ethereum_dex_service = EthereumArbitrageService()\n                    await ethereum_dex_service.initialize()\n                    logger.info(\"Ethereum DEX service initialized successfully\")\n                except Exception as e:\n                    logger.warning(f\"Ethereum DEX initialization failed (continuing with CEX only): {e}\")\n                    ethereum_dex_service = None\n            \n            # Start the CEX scanner tasks\n            scanner_task = asyncio.create_task(arbitrage_app.run_scanners())\n            \n            # Start DEX service if available\n            dex_task = None\n            if ethereum_dex_service:\n                dex_task = asyncio.create_task(ethereum_dex_service.start())\n                logger.info(\"Started Ethereum DEX service\")\n            \n            # Start Quart API server and wait for all services\n            if dex_task:\n                await asyncio.gather(\n                    app.run_task(host=Config.FLASK_HOST, port=Config.FLASK_PORT),\n                    scanner_task,\n                    dex_task\n                )\n            else:\n                await app.run_task(host=Config.FLASK_HOST, port=Config.FLASK_PORT)\n                await scanner_task\n        except KeyboardInterrupt:\n            logger.info(\"Shutdown signal received. Exiting.\")\n        finally:\n            # Shutdown both systems\n            await arbitrage_app.engine.stop()\n            if ethereum_dex_service:\n                try:\n                    await ethereum_dex_service.stop()\n                except Exception as e:\n                    logger.warning(f\"Error stopping Ethereum DEX service: {e}\")\n            logger.info(\"Application shut down gracefully.\")\n\n    asyncio.run(main())\n","size_bytes":8700},"telegram_alert.py":{"content":"import logging\nimport aiohttp\nfrom aiogram import Bot, Dispatcher, types\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery\nfrom cex.models import Opportunity, TradeResult\nfrom cex.config import Config\nfrom cex.engine import logger\n\n# Simple whitelist check\ndef is_whitelisted_chat(chat_id):\n    try:\n        allowed = int(Config.TELEGRAM_CHAT_ID)\n        return chat_id == allowed\n    except Exception:\n        return False\n\n\nclass TelegramNotifier:\n    def __init__(self, chat_id, execution_endpoint: str = None):\n        self.chat_id = int(chat_id) if chat_id else None\n        token = getattr(Config, \"TELEGRAM_BOT_TOKEN\", None)\n        if not token:\n            raise RuntimeError(\"Telegram bot token not configured.\")\n        self.bot = Bot(token=token)\n        self.dp = Dispatcher()\n        self.execution_endpoint = execution_endpoint or Config.EXECUTE_URL\n\n        # Register handlers\n        # Accept callback queries that begin with EXECUTE_\n        self.dp.callback_query.register(self.handle_execute_button, lambda c: str(c.data).startswith(\"EXECUTE_\"))\n\n    async def send_opportunity_alert(self, opportunity: Opportunity, Id: str = None):\n        \"\"\"\n        Send an opportunity alert message with inline buttons to execute trade.\n        \"\"\"\n        message_text = self._format_opportunity_message(opportunity)\n        keyboard = self._build_action_buttons(opportunity, Id)\n        try:\n            await self.bot.send_message(chat_id=self.chat_id, text=message_text, parse_mode=\"HTML\", reply_markup=keyboard)\n        except Exception as e:\n            logger.error(f\"Failed to send Telegram alert: {e}\")\n\n    def _format_opportunity_message(self, opp: Opportunity) -> str:\n        if getattr(opp, 'trading_pair', None):\n            text = (\n                f\"♻️ <b>New Cross-Exchange Opportunity Detected!</b>\\n\"\n                f\"Pair: {opp.trading_pair}\\n\"\n                f\"Buy on: {opp.buy_exchange} @ {opp.buy_price:.6f}\\n\"\n                f\"Sell on: {opp.sell_exchange} @ {opp.sell_price:.6f}\\n\"\n                f\"Profit: {opp.profit_percentage:.2f}% ({opp.profit_usd:.2f} USD)\\n\"\n                f\"Volume: {opp.volume}\\n\"\n                f\"Detected At: {opp.detected_at}\"\n            )\n        else:\n            path_str = \" -> \".join(opp.trading_path or [])\n            text = (\n                f\"🔺 <b>New Triangular Opportunity Detected!</b>\\n\"\n                f\"Exchange: {opp.exchange}\\n\"\n                f\"Path: {path_str}\\n\"\n                f\"Profit: {opp.profit_percentage:.2f}%\\n\"\n                f\"Initial Amount: {opp.initial_amount}\\n\"\n                f\"Final Amount: {opp.final_amount}\\n\"\n                f\"Detected At: {opp.detected_at}\"\n            )\n        return text\n\n    def _build_action_buttons(self, opp: Opportunity, Id: str = None) -> InlineKeyboardMarkup:\n        opp_type = \"cross\" if getattr(opp, 'trading_pair', None) else \"triangular\"\n        buttons = []\n        if opp_type == \"cross\":\n            buttons.append([\n                InlineKeyboardButton(text=\"Execute Instant\", callback_data=f\"EXECUTE_{opp_type}_{Id}_instant\"),\n                InlineKeyboardButton(text=\"Execute Transfer\", callback_data=f\"EXECUTE_{opp_type}_{Id}_transfer\")\n            ])\n        else:\n            buttons.append([InlineKeyboardButton(text=\"Execute\", callback_data=f\"EXECUTE_{opp_type}_{Id}_default\")])\n        return InlineKeyboardMarkup(inline_keyboard=buttons)\n\n    async def handle_execute_button(self, callback_query: CallbackQuery):\n        await callback_query.answer()\n        chat_id = callback_query.message.chat.id\n\n        # Whitelist chat_id\n        if not is_whitelisted_chat(chat_id):\n            await callback_query.message.edit_text(\"Unauthorized chat.\")\n            return\n\n        try:\n            _, opp_type, opportunity_id, strategy = callback_query.data.split(\"_\")\n            trade_type = \"triangular\" if opp_type == \"triangular\" else \"cross\"\n            payload = {\n                \"type\": trade_type,\n                \"strategy\": strategy,\n                \"opportunity_id\": opportunity_id,\n                \"chat_id\": chat_id\n            }\n            async with aiohttp.ClientSession() as session:\n                async with session.post(self.execution_endpoint, json=payload, timeout=10) as resp:\n                    try:\n                        data = await resp.json()\n                    except Exception:\n                        data = {\"status\": \"error\", \"message\": \"No json response\"}\n\n            if resp.status == 200:\n                text = \"✅ Trade request accepted, executing...\"\n            else:\n                text = f\"⚠️ Execution failed: {data.get('message', 'Unknown error')}\"\n\n        except Exception as e:\n            logger.error(f\"Error handling execute button: {e}\")\n            text = f\"❌ Error during execution: {str(e)}\"\n\n        await callback_query.message.edit_text(text, parse_mode=\"HTML\")\n\n    async def send_trade_result(self, chat_id: int, trade_result: TradeResult):\n        status = trade_result.status.capitalize()\n        profit = f\"${trade_result.profit_usd:.2f}\" if trade_result.profit_usd is not None else \"N/A\"\n        message = (\n            f\"📊 <b>Trade Result</b>\\n\"\n            f\"Status: {status}\\n\"\n            f\"Message: {trade_result.message}\\n\"\n            f\"Trade ID: {trade_result.trade_id or 'N/A'}\\n\"\n            f\"Profit: {profit}\"\n        )\n        target = chat_id or self.chat_id\n        try:\n            await self.bot.send_message(chat_id=target, text=message, parse_mode=\"HTML\")\n        except Exception as e:\n            logger.error(f\"Failed to send trade result to Telegram: {e}\")\n\n    async def start_polling(self):\n        await self.dp.start_polling(self.bot, skip_updates=True)\n","size_bytes":5763},"cex/__init__.py":{"content":"# CEX Arbitrage system ","size_bytes":23},"cex/arbitrage.py":{"content":"import aiohttp\nimport asyncio\nimport traceback\nfrom datetime import datetime\n\nfrom .config import Config\nfrom .cross import CrossExchange\nfrom .triangular import Triangular\nfrom .engine import logger, Engine\nfrom .models import TradeResult\nfrom telegram_alert import TelegramNotifier\n\n# --- Main Application Class ---\nclass ArbitrageApp:\n    def __init__(self, config: Config):\n        self.config = config\n        self.headers = {\n            'api_key': self.config.BASE44_APP_TOKEN,\n            'Content-Type': 'application/json'\n        }\n        self.notifier = None\n        if self.config.TELEGRAM_ALERTS_ENABLED and self.config.TELEGRAM_BOT_TOKEN and self.config.TELEGRAM_CHAT_ID:\n            try:\n                self.notifier = TelegramNotifier(self.config.TELEGRAM_CHAT_ID)\n            except Exception as e:\n                print(f\"[WARNING] Failed to initialize Telegram notifier: {e}\")\n                self.notifier = None\n        self.engine = Engine(config.BASE44_API_URL, config.BASE44_APP_TOKEN, self.notifier)\n        self.cross_engine = CrossExchange(self.engine, self.config)\n        self.triangular_engine = Triangular(self.engine)\n        self.trade_lock = asyncio.Lock()\n\n    async def run_scanners(self):\n        logger.info(\"Initializing exchanges...\")\n        await self.engine.initialize_exchanges()\n\n        logger.info(\"Starting all arbitrage scanners...\")\n        scanner_tasks = [\n            asyncio.create_task(self.cross_engine.start_price_streams()),\n            asyncio.create_task(self.triangular_engine.start()),\n            asyncio.create_task(self.engine.watch_base44_config()),\n            asyncio.create_task(self.engine.update_account_balances_periodically())\n        ]\n\n        if self.notifier:\n            scanner_tasks.append(asyncio.create_task(self.notifier.start_polling()))\n\n        await asyncio.gather(*scanner_tasks)\n\n    async def execute_trade_logic(self, trade_request: dict, auth_key: str = None) -> TradeResult:\n        \"\"\"\n        Central execution entrypoint. Caller should hold external authentication.\n        The orchestrator ensures single concurrent execution through a lock here.\n        \"\"\"\n        async with self.trade_lock:\n            # Required auth check (API key)\n            if not auth_key or auth_key != self.config.BASE44_APP_TOKEN:\n                return TradeResult(\"error\", \"Unauthorized request - valid API key required\")\n\n            op_type = trade_request.get('type')\n            entity_name = 'ArbitrageOpportunity' if op_type == 'cross' else 'TriangularOpportunity'\n\n            try:\n                # Fetch the latest opportunity record from Base44 (short timeout)\n                async with aiohttp.ClientSession() as session:\n                    url = f\"{self.config.BASE44_API_URL}/entities/{entity_name}/{trade_request.get('opportunity_id')}\"\n                    async with session.get(url, headers=self.headers, timeout=6) as resp:\n                        if resp.status != 200:\n                            return TradeResult(\"error\", f\"Opportunity not found or expired. Status: {resp.status}\")\n                        op = await resp.json()\n\n                # Basic staleness check\n                try:\n                    detected = op.get('detected_at')\n                    if detected:\n                        age = (datetime.utcnow() - datetime.fromisoformat(detected)).total_seconds()\n                        if age > 10:\n                            return TradeResult(\"error\", \"Opportunity is stale.\")\n                except Exception:\n                    pass\n\n                if op_type == 'cross':\n                    return await self.cross_engine._execute_cross_exchange_trade(op, trade_request)\n                elif op_type == 'triangular':\n                    return await self.triangular_engine._execute_triangular_trade(op, trade_request)\n\n                return TradeResult(\"error\", \"Invalid trade type\")\n            except Exception as e:\n                logger.error(f\"FATAL error during trade execution pipeline: {e}\")\n                logger.error(traceback.format_exc())\n                return TradeResult(\"error\", \"An unexpected server error occurred during execution.\")\n","size_bytes":4186},"cex/config.py":{"content":"import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass Config:\n    # Base44 Configuration\n    BASE44_API_URL = os.getenv(\"BASE44_API_URL\", \"\")\n    BASE44_APP_TOKEN = os.getenv(\"BASE44_APP_TOKEN\", \"\")\n\n    # Trading Configuration\n    SYMBOLS = os.getenv(\"SYMBOLS\", \"FIL/USDT,QTUM/USDT,DOT/USDT,XRP/USDT,ADA/USDT\").split(\",\")\n    MIN_PROFIT_THRESHOLD = float(os.getenv(\"MIN_PROFIT_THRESHOLD\", \"0.3\"))\n    MAX_TRADE_AMOUNT = float(os.getenv(\"MAX_TRADE_AMOUNT\", \"1000.0\"))\n\n    # Telegram Bot Configuration\n    TELEGRAM_BOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\", \"\")\n    TELEGRAM_CHAT_ID = os.getenv(\"TELEGRAM_CHAT_ID\", \"\")\n    TELEGRAM_API_URL = os.getenv(\"TELEGRAM_API_URL\", \"https://api.telegram.org/bot\") + TELEGRAM_BOT_TOKEN\n    TELEGRAM_ALERTS_ENABLED = os.getenv(\"TELEGRAM_ALERTS_ENABLED\", \"True\") == \"True\"\n    TELEGRAM_ALERT_THRESHOLD = float(os.getenv(\"TELEGRAM_ALERT_THRESHOLD\", \"0.5\"))\n    TELEGRAM_ALERT_COOLDOWN = int(\"300\")\n\n    # WebSocket Configuration\n    ORDERBOOK_LIMIT = int(os.getenv(\"ORDERBOOK_LIMIT\", \"1\"))\n    RECONNECT_DELAY = int(os.getenv(\"RECONNECT_DELAY\", \"30\"))\n\n    # Quart / Flask Configuration\n    FLASK_HOST = os.getenv(\"FLASK_HOST\", \"0.0.0.0\")\n    FLASK_PORT = int(os.getenv(\"FLASK_PORT\", \"5000\"))\n    EXECUTE_URL = os.getenv(\"EXECUTE_URL\", \"https://arbitragewise-production.up.railway.app/execute\")\n\n    # Logging Configuration\n    LOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\")\n\n    @classmethod\n    def validate(cls):\n        errors = []\n        if not cls.BASE44_API_URL:\n            errors.append(\"BASE44_API_URL not set\")\n        if not cls.BASE44_APP_TOKEN:\n            errors.append(\"BASE44_APP_TOKEN not set\")\n        if cls.TELEGRAM_ALERTS_ENABLED and (not cls.TELEGRAM_BOT_TOKEN or not cls.TELEGRAM_CHAT_ID):\n            errors.append(\"Telegram enabled but TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not set\")\n        if errors:\n            raise RuntimeError(\"Config validation errors: \" + \"; \".join(errors))\n\n# perform a runtime validation when module is imported\ntry:\n    Config.validate()\nexcept Exception as e:\n    # do NOT crash automatically in dev. Log error for operator to fix.\n    # In production you may want to raise to stop the app\n    print(f\"[CONFIG] Warning: {e}\")\n","size_bytes":2226},"cex/cross.py":{"content":"import asyncio\nimport traceback\nimport time\n\nfrom typing import List, Dict\nfrom decimal import Decimal, getcontext\nfrom datetime import datetime\n\nfrom .config import Config\nfrom .engine import Engine, logger\nfrom .models import TradeResult, Opportunity\n\ngetcontext().prec = 60\n\n\nclass CrossExchange(Engine):\n\n    def __init__(self, engine: Engine, config: Config):\n        # composition: we use engine instance passed in (don't re-initialize)\n        self.engine = engine\n        self.price_cache = {}\n        self.config = config\n        self.reconnect_delay = int(config.RECONNECT_DELAY)\n        # Use existing thresholds\n        self.min_profit_threshold = float(config.MIN_PROFIT_THRESHOLD)\n        # If desired, you can keep a local lock (but the orchestrator already locks execute)\n        self._execution_lock = asyncio.Lock()\n\n    # -----------------------------\n    # Price streams and detection\n    # -----------------------------\n    async def start_price_streams(self):\n        \"\"\"Initializes and manages all WebSocket price stream tasks.\"\"\"\n        logger.info(\"Starting cross-exchange price streams...\")\n        tasks = []\n\n        for exchange_name, exchange in self.engine.exchanges.items():\n            for symbol in self.config.SYMBOLS:\n                task = asyncio.create_task(self.stream_manager(exchange_name, exchange, symbol))\n                tasks.append(task)\n\n        # Start the separate task for continuously detecting opportunities\n        tasks.append(asyncio.create_task(self.continuous_opportunity_detection()))\n\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def stream_manager(self, exchange_name: str, exchange, symbol: str):\n        \"\"\"Manages the lifecycle of a single WebSocket stream with automatic reconnection.\"\"\"\n        while self.engine.running:\n            try:\n                logger.info(f\"[{exchange_name}] Subscribing to {symbol}...\")\n                await self.stream_orderbook(exchange_name, exchange, symbol)\n            except Exception as e:\n                logger.error(f\"[{exchange_name}] Unhandled exception in stream for {symbol}: {e}. Reconnecting in {self.reconnect_delay}s.\")\n                await asyncio.sleep(self.reconnect_delay)\n\n    async def stream_orderbook(self, exchange_name: str, exchange, symbol: str):\n        \"\"\"The core loop that watches for order book updates from a single stream.\"\"\"\n        reconnect_attempts = 0\n        max_reconnect_delay = 300\n\n        while self.engine.running:\n            try:\n                orderbook = await exchange.watch_order_book(symbol)\n                if exchange_name not in self.price_cache:\n                    self.price_cache[exchange_name] = {}\n\n                if orderbook and orderbook.get('bids') and orderbook.get('asks'):\n                    self.price_cache[exchange_name][symbol] = {\n                        'bid': orderbook['bids'][0][0],\n                        'ask': orderbook['asks'][0][0],\n                        'timestamp': orderbook.get('timestamp', int(time.time() * 1000))\n                    }\n                    logger.debug(f\"Price Update: {exchange_name} {symbol} | Bid: {self.price_cache[exchange_name][symbol]['bid']}, Ask: {self.price_cache[exchange_name][symbol]['ask']}\")\n                    reconnect_attempts = 0\n                else:\n                    logger.warning(f\"[{exchange_name}] Received invalid order book for {symbol}\")\n\n            except Exception as e:\n                logger.warning(f\"[{exchange_name}] Error in symbol watcher for {symbol}: {e}\")\n                # Ensure the connection is closed before a new attempt\n                try:\n                    if hasattr(exchange, 'close'):\n                        await exchange.close()\n                except Exception:\n                    pass\n\n                delay = min(self.reconnect_delay * (2 ** reconnect_attempts), max_reconnect_delay)\n                logger.info(f\"[{exchange_name}] Reconnecting in {delay} seconds...\")\n                await asyncio.sleep(delay)\n                reconnect_attempts += 1\n\n    async def continuous_opportunity_detection(self):\n        \"\"\"Continuously analyzes the in-memory price cache for arbitrage opportunities.\"\"\"\n        while self.engine.running:\n            try:\n                for symbol in self.config.SYMBOLS:\n                    opportunities = self.analyze_symbol_opportunities(symbol)\n                    for opp in opportunities:\n                        # Add expiry guard: skip stale opps older than X seconds\n                        now_ts = datetime.utcnow().timestamp()\n                        # opp.detected_at is ISO string - try convert\n                        try:\n                            opp_ts = datetime.fromisoformat(opp.detected_at).timestamp()\n                        except Exception:\n                            opp_ts = now_ts\n                        if now_ts - opp_ts > 10:  # 10 seconds max age\n                            logger.debug(\"Skipping stale opportunity\")\n                            continue\n\n                        # Profit check against engine threshold and configured minimum\n                        if opp.profit_percentage < max(self.engine.min_profit_threshold, self.min_profit_threshold):\n                            logger.debug(\"Skipping low-profit opportunity\")\n                            continue\n\n                        logger.info(f\"Cross-Exchange Opportunity: {opp.trading_pair} | Profit: {opp.profit_percentage:.3f}%\")\n                        await self.engine.save_opportunity(opp, 'ArbitrageOpportunity')\n\n                await asyncio.sleep(2)\n            except Exception as e:\n                logger.error(f\"Error in continuous opportunity detection loop: {e}\")\n                logger.error(traceback.format_exc())\n                await asyncio.sleep(10)\n\n    # -----------------------------\n    # Opportunity discovery\n    # -----------------------------\n    def analyze_symbol_opportunities(self, symbol: str) -> list:\n        prices = []\n        for exchange_name, exchange_data in self.price_cache.items():\n            if symbol in exchange_data and exchange_data[symbol].get('bid') and exchange_data[symbol].get('ask'):\n                prices.append({\n                    'exchange': exchange_name,\n                    'symbol': symbol,\n                    **exchange_data[symbol]\n                })\n\n        if len(prices) >= 2:\n            return self._find_arbitrage_opportunities(prices)\n        return []\n\n    def _find_arbitrage_opportunities(self, price_data: List[Dict]) -> List[Opportunity]:\n        \"\"\"Analyze price data to find arbitrage opportunities. Includes simple fee estimate.\"\"\"\n        opportunities: List[Opportunity] = []\n        if len(price_data) < 2:\n            return opportunities\n\n        valid_prices = [p for p in price_data if p and p.get('bid') and p.get('ask')]\n        if len(valid_prices) < 2:\n            return opportunities\n\n        sorted_by_ask = sorted(valid_prices, key=lambda x: x['ask'])\n        sorted_by_bid = sorted(valid_prices, key=lambda x: x['bid'], reverse=True)\n\n        best_buy = sorted_by_ask[0]\n        best_sell = sorted_by_bid[0]\n\n        if best_buy['exchange'] == best_sell['exchange']:\n            return opportunities\n\n        buy_price = Decimal(str(best_buy['ask']))\n        sell_price = Decimal(str(best_sell['bid']))\n\n        if sell_price <= buy_price:\n            return opportunities\n\n        # Basic fee estimate (taker fees) - can be replaced by real per-exchange fee lookup\n        estimated_fee_pct = Decimal('0.002')  # 0.2% per side default\n        trade_amount = Decimal(str(1000))  # simulate $1000 trade (configurable)\n        quantity = trade_amount / buy_price\n        gross_profit = quantity * (sell_price - buy_price)\n        fees = trade_amount * estimated_fee_pct * 2  # buy + sell\n        net_profit = gross_profit - fees\n\n        profit_percentage = (net_profit / trade_amount) * 100\n\n        if profit_percentage >= Decimal(str(self.engine.min_profit_threshold)):\n            opp = Opportunity(\n                trading_pair=best_buy['symbol'],\n                buy_exchange=best_buy['exchange'],\n                sell_exchange=best_sell['exchange'],\n                buy_price=float(buy_price),\n                sell_price=float(sell_price),\n                profit_percentage=float(profit_percentage),\n                profit_usd=float(net_profit),\n                volume=float(quantity),\n                detected_at=datetime.utcnow().isoformat()\n            )\n            opportunities.append(opp)\n        return opportunities\n\n    # -----------------------------\n    # Execution: instant vs transfer\n    # -----------------------------\n    async def _execute_cross_exchange_trade(self, op: dict, req: dict) -> TradeResult:\n        strategy = req.get('strategy')\n        amount = float(req.get('amount', self.config.MAX_TRADE_AMOUNT))\n\n        if strategy == 'instant':\n            return await self._execute_instant_arbitrage(op, amount)\n        elif strategy == 'transfer':\n            return await self._execute_transfer_arbitrage(op, amount)\n        return TradeResult(\"error\", \"Unknown cross-exchange strategy\")\n\n    async def _execute_instant_arbitrage(self, op: dict, amount_usd: float) -> TradeResult:\n        \"\"\"Attempt to buy on buy_exchange and sell on sell_exchange concurrently.\n        If one side fails after the other succeeded a simple hedge attempt is made to reduce exposure.\n        \"\"\"\n        buy_ex_name, sell_ex_name = op['buy_exchange'], op['sell_exchange']\n        buy_exchange = self.engine.exchanges.get(buy_ex_name)\n        sell_exchange = self.engine.exchanges.get(sell_ex_name)\n        pair = op['trading_pair']\n        base, quote = pair.split('/')\n\n        if not all([buy_exchange, sell_exchange]):\n            return TradeResult(\"error\", \"One of the exchanges is not initialized.\")\n\n        # Pre-check balances\n        buy_balance = self.engine.account_balances.get(buy_ex_name, {}).get(quote, 0)\n        sell_balance = self.engine.account_balances.get(sell_ex_name, {}).get(base, 0)\n\n        if buy_balance < amount_usd:\n            return TradeResult(\"error\", f\"Insufficient {quote} on {buy_ex_name}\")\n        amount_to_trade_base = amount_usd / op['buy_price']\n        if sell_balance < amount_to_trade_base:\n            logger.info(f\"Sell-exchange doesn't have base asset to cover immediate reverse. Proceeding with instant attempting buy+sell.\")\n            # not necessarily an error; we will attempt to buy then sell\n\n        # Execute both market orders concurrently via ccxt async interface\n        try:\n            logger.info(f\"⚡️ ATTEMPTING INSTANT ARBITRAGE: {pair} | {amount_usd:.2f} {quote}\")\n            buy_task = buy_exchange.create_market_buy_order(pair, amount_to_trade_base)\n            sell_task = sell_exchange.create_market_sell_order(pair, amount_to_trade_base)\n\n            results = await asyncio.gather(buy_task, sell_task, return_exceptions=True)\n            buy_order, sell_order = results\n\n            # If both succeeded\n            if not isinstance(buy_order, Exception) and not isinstance(sell_order, Exception):\n                # compute profit properly\n                buy_cost = Decimal(str(buy_order.get('cost', 0)))\n                sell_cost = Decimal(str(sell_order.get('cost', 0)))\n                buy_fee = Decimal(str((buy_order.get('fee') or {}).get('cost', 0)))\n                sell_fee = Decimal(str((sell_order.get('fee') or {}).get('cost', 0)))\n                profit = sell_cost - buy_cost - buy_fee - sell_fee\n                log = {\n                    \"opportunity_id\": op.get('id'),\n                    \"trading_pair\": pair,\n                    \"buy_exchange\": buy_ex_name,\n                    \"sell_exchange\": sell_ex_name,\n                    \"buy_price\": buy_order.get('average'),\n                    \"sell_price\": sell_order.get('average'),\n                    \"quantity\": buy_order.get('filled'),\n                    \"profit_usd\": float(profit),\n                    \"status\": \"completed\",\n                    \"strategy\": \"instant\"\n                }\n                trade_id = await self.engine._log_trade_to_base44(log)\n                return TradeResult(\"success\", \"Instant arbitrage executed successfully.\", trade_id, float(profit))\n\n            # Partial failure: one side succeeded, the other failed\n            logger.error(f\"PARTIAL FAILURE: Buy: {buy_order} | Sell: {sell_order}\")\n\n            # Basic hedge strategy:\n            # - If buy succeeded but sell failed: try to sell bought asset on buy_exchange immediately to reduce exposure.\n            # - If sell succeeded but buy failed: try to buy on sell_exchange (unlikely) or transfer logic to cover exposure.\n            # We will attempt best-effort hedge and return an error for manual review.\n\n            # Hedge if buy succeeded\n            if not isinstance(buy_order, Exception) and isinstance(sell_order, Exception):\n                try:\n                    bought_qty = Decimal(str(buy_order.get('filled', 0)))\n                    # attempt to sell back on buy_exchange (market sell)\n                    logger.info(\"Attempting hedge: selling bought asset back on buy exchange to reduce exposure.\")\n                    hedge_order = await buy_exchange.create_market_sell_order(pair, float(bought_qty))\n                    hedge_filled = Decimal(str(hedge_order.get('filled', 0)))\n                    hedge_sell_cost = Decimal(str(hedge_order.get('cost', 0)))\n                    buy_cost = Decimal(str(buy_order.get('cost', 0)))\n                    net = hedge_sell_cost - buy_cost\n                    logger.error(f\"Hedge result: sold {hedge_filled} back for net {net}\")\n                except Exception as hedge_err:\n                    logger.error(f\"Hedge attempt failed: {hedge_err}\")\n\n            # Hedge if sell succeeded but buy failed (very rare)\n            if isinstance(buy_order, Exception) and not isinstance(sell_order, Exception):\n                # attempt to buy back at market on sell_exchange\n                try:\n                    sold_qty = Decimal(str(sell_order.get('filled', 0)))\n                    logger.info(\"Attempting hedge: buying back asset on sell exchange to reduce exposure.\")\n                    hedge_order = await sell_exchange.create_market_buy_order(pair, float(sold_qty))\n                    logger.error(f\"Hedge buy result: {hedge_order}\")\n                except Exception as hedge_err:\n                    logger.error(f\"Hedge attempt failed: {hedge_err}\")\n\n            return TradeResult(\"error\", \"Partial execution occurred; manual review required.\")\n        except Exception as e:\n            logger.error(f\"Error during instant execution: {e}\\n{traceback.format_exc()}\")\n            return TradeResult(\"error\", str(e))\n\n    async def _execute_transfer_arbitrage(self, op: dict, amount_usd: float) -> TradeResult:\n        \"\"\"Transfer arbitrage: buy on exchange A, withdraw, wait deposit on exchange B, then sell.\"\"\"\n        try:\n            buy_ex_name, sell_ex_name = op['buy_exchange'], op['sell_exchange']\n            buy_exchange = self.engine.exchanges.get(buy_ex_name)\n            sell_exchange = self.engine.exchanges.get(sell_ex_name)\n            pair = op['trading_pair']\n            base, quote = pair.split('/')\n\n            if not all([buy_exchange, sell_exchange]):\n                return TradeResult(\"error\", \"One of the exchanges is not initialized.\")\n\n            quote_balance = self.engine.account_balances.get(buy_ex_name, {}).get(quote, 0)\n            if quote_balance < amount_usd:\n                return TradeResult(\"error\", f\"Insufficient {quote} on {buy_ex_name} (have: {quote_balance})\")\n\n            # 1a. Estimate slippage (BUY)\n            amount_base_est = Decimal(str(amount_usd)) / Decimal(str(op['buy_price']))\n            slip = await self.engine.calc_slippage(buy_exchange, pair, 'BUY', Decimal(str(amount_usd)))\n            if not self.engine._slippage_ok(slip):\n                return TradeResult(\"error\", f\"Buy slippage too high on {buy_ex_name}: {slip:.4%}\")\n\n            # 2. Place Market Buy Order (use with_cost variant if available)\n            logger.info(f\"[TRANSFER ARB] Buying ~{float(amount_base_est):.6f} {base} on {buy_ex_name}\")\n            buy_order = await buy_exchange.create_market_buy_order_with_cost(pair, float(amount_usd)) if hasattr(buy_exchange, 'create_market_buy_order_with_cost') else await buy_exchange.create_market_buy_order(pair, float(amount_base_est))\n            if not buy_order or buy_order.get('status') not in ('closed', 'filled'):\n                return TradeResult(\"error\", \"Buy order failed or not filled.\")\n\n            amount_base = Decimal(str(buy_order.get('filled', amount_base_est)))\n            # 3. Determine transfer network\n            common_chains = await self.get_common_transfer_chains(base, buy_exchange, sell_exchange)\n            if not common_chains:\n                return TradeResult(\"error\", f\"No common transfer chains for {base} between {buy_ex_name} and {sell_ex_name}\")\n\n            best_chain, fee = await self.select_best_transfer_chain(common_chains, buy_exchange, base)\n            if not best_chain:\n                return TradeResult(\"error\", f\"Could not determine best transfer chain for {base}\")\n\n            deposit_info = await sell_exchange.fetch_deposit_address(base, {'network': best_chain})\n            address = deposit_info.get('address')\n            tag_or_memo = deposit_info.get('tag', None)\n\n            # 4. Withdraw from buy exchange\n            withdrawal = await buy_exchange.withdraw(code=base, amount=float(amount_base), address=address, tag=tag_or_memo, params={'network': best_chain})\n            withdraw_fee = (withdrawal.get('fee') or {}).get('cost', fee)\n\n            # 5. Wait for deposit (poll balances)\n            logger.info(f\"[TRANSFER ARB] Waiting for deposit of {float(amount_base):.6f} {base} on {sell_ex_name}\")\n            max_wait = 600\n            interval = 10\n            waited = 0\n            amount_received = Decimal('0')\n            while waited < max_wait:\n                try:\n                    balance = await sell_exchange.fetch_balance()\n                    total_base = Decimal(str(balance.get('total', {}).get(base, 0)))\n                    if total_base >= (amount_base - Decimal(str(withdraw_fee))) * Decimal('0.98'):\n                        amount_received = total_base\n                        logger.info(f\"[TRANSFER ARB] Deposit received: {amount_received}\")\n                        break\n                except Exception:\n                    pass\n                await asyncio.sleep(interval)\n                waited += interval\n\n            if amount_received == 0:\n                return TradeResult(\"error\", \"Timeout waiting for deposit on sell exchange.\")\n\n            # 6a. Slippage check on sell\n            slip = await self.engine.calc_slippage(sell_exchange, pair, 'SELL', amount_received)\n            if not self.engine._slippage_ok(slip):\n                return TradeResult(\"error\", f\"Sell slippage too high on {sell_ex_name}: {slip:.4%}\")\n\n            # 6b. Sell\n            sell_order = await sell_exchange.create_market_sell_order(pair, float(amount_received))\n\n            # 7. Profit calc\n            buy_cost = Decimal(str(buy_order.get('cost', 0)))\n            sell_cost = Decimal(str(sell_order.get('cost', 0)))\n            buy_fee = Decimal(str((buy_order.get('fee') or {}).get('cost', 0)))\n            sell_fee = Decimal(str((sell_order.get('fee') or {}).get('cost', 0)))\n            withdraw_fee_dec = Decimal(str(withdraw_fee or 0))\n            profit = sell_cost - buy_cost - buy_fee - sell_fee - withdraw_fee_dec\n\n            trade_log = {\n                \"opportunity_id\": op.get('id'),\n                \"trading_pair\": pair,\n                \"buy_exchange\": buy_ex_name,\n                \"sell_exchange\": sell_ex_name,\n                \"buy_price\": buy_order.get('average'),\n                \"sell_price\": sell_order.get('average'),\n                \"quantity\": float(amount_base),\n                \"profit_usd\": float(profit),\n                \"status\": \"completed\",\n                \"strategy\": \"transfer\"\n            }\n            trade_id = await self.engine._log_trade_to_base44(trade_log)\n            logger.info(f\"[TRANSFER ARB] Transfer arbitrage successful. Profit: ${float(profit):.2f}\")\n            return TradeResult(\"success\", \"Transfer arbitrage executed successfully.\", trade_id, float(profit))\n\n        except Exception as e:\n            logger.error(f\"[TRANSFER ARB] Error: {e}\")\n            logger.error(traceback.format_exc())\n            return TradeResult(\"error\", f\"Exception occurred: {str(e)}\")\n\n    # -----------------------------\n    # Helper chain utilities\n    # -----------------------------\n    async def get_common_transfer_chains(self, asset: str, buy_exchange, sell_exchange) -> list:\n        \"\"\"Fetch common transfer chains (networks) for an asset between two exchanges.\"\"\"\n        try:\n            buy_currencies = await buy_exchange.fetch_currencies()\n            sell_currencies = await sell_exchange.fetch_currencies()\n\n            buy_chains = set()\n            sell_chains = set()\n\n            for key, info in buy_currencies.items():\n                if key.upper() == asset.upper() and isinstance(info, dict) and 'networks' in info:\n                    buy_chains.update(info['networks'].keys())\n\n            for key, info in sell_currencies.items():\n                if key.upper() == asset.upper() and isinstance(info, dict) and 'networks' in info:\n                    sell_chains.update(info['networks'].keys())\n\n            common = buy_chains & sell_chains\n            return list(common)\n        except Exception as e:\n            logger.error(f\"[CHAIN MATCHING] Error fetching common chains: {e}\")\n            return []\n\n    async def select_best_transfer_chain(self, common_chains: list, buy_exchange, asset: str):\n        \"\"\"\n        From a list of common chains, select the best one based on lowest withdrawal fee.\n        Returns (best_chain, estimated_fee)\n        \"\"\"\n        try:\n            buy_currencies = await buy_exchange.fetch_currencies()\n            best_chain = None\n            best_score = float('inf')\n            estimated_fee = 0\n\n            for chain in common_chains:\n                currency_info = buy_currencies.get(asset.upper())\n                network_info = currency_info.get('networks', {}).get(chain)\n                if not network_info:\n                    continue\n                fee = network_info.get('fee', 0)\n                # lower fee wins\n                if fee < best_score:\n                    best_score = fee\n                    estimated_fee = fee\n                    best_chain = chain\n\n            return best_chain, estimated_fee\n        except Exception as e:\n            logger.error(f\"[CHAIN SCORING] Error selecting best chain: {e}\")\n            return None, None\n\n    async def _log_pending_transfer(self, op: dict, amount_usd: float) -> TradeResult:\n        logger.info(f\"Logging 'Transfer & Trade' for opportunity {op.get('id')}\")\n        log = {\n            \"opportunity_id\": op.get('id'),\n            \"trading_pair\": op.get('trading_pair'),\n            \"buy_exchange\": op.get('buy_exchange'),\n            \"sell_exchange\": op.get('sell_exchange'),\n            \"buy_price\": op.get('buy_price'),\n            \"sell_price\": op.get('sell_price'),\n            \"quantity\": amount_usd / op.get('buy_price', 1),\n            \"profit_usd\": op.get('profit_usd'),\n            \"status\": \"pending\",\n            \"strategy\": \"transfer\"\n        }\n        trade_id = await self.engine._log_trade_to_base44(log)\n        if trade_id:\n            return TradeResult(\"success\", \"Trade logged as 'pending'. Manual transfer required.\", trade_id)\n        return TradeResult(\"error\", \"Failed to log the pending trade.\")\n","size_bytes":23878},"cex/engine.py":{"content":"import asyncio\nimport ccxt.pro as ccxt\nimport json\nimport os\nimport logging\nimport time\nfrom datetime import datetime\nfrom decimal import Decimal, getcontext\nfrom typing import Dict, List, Optional\nimport aiohttp\nfrom .models import Opportunity, asdict\n\n# Set Decimal precision high for financial math\ngetcontext().prec = 60\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('arbitrage.log'),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n# Small helper: aiohttp session factory with timeout and retry-like behavior\nasync def fetch_json_with_timeout(url: str, method: str = \"GET\", json_payload=None, headers=None, timeout=8):\n    try:\n        async with aiohttp.ClientSession() as session:\n            if method.upper() == \"GET\":\n                async with session.get(url, headers=headers, timeout=timeout) as resp:\n                    text = await resp.text()\n                    return resp.status, await resp.json()\n            elif method.upper() == \"POST\":\n                async with session.post(url, headers=headers, json=json_payload, timeout=timeout) as resp:\n                    text = await resp.text()\n                    try:\n                        return resp.status, await resp.json()\n                    except Exception:\n                        return resp.status, {\"raw\": text}\n    except asyncio.TimeoutError:\n        logger.error(f\"[HTTP] Timeout when calling {url}\")\n        return None, None\n    except Exception as e:\n        logger.error(f\"[HTTP] Error when calling {url}: {e}\")\n        return None, None\n\n\nclass Engine:\n    \"\"\"Core Arbitrage Engine handling exchange initialization, balance updates, and opportunity logging.\"\"\"\n    account_balances: Dict[str, Dict[str, float]] = {}  # {exchange: {asset: balance}}\n    slippage_tolerance = Decimal('0.005')  # 0.5% default tolerance\n\n    def __init__(self, base44_api_url: str, app_token: str, notifier=None):\n        self.base44_api_url = base44_api_url\n        self.app_token = app_token\n        self.notifier = notifier\n\n        self.headers = {\n            'api_key': self.app_token,\n            'Content-Type': 'application/json'\n        }\n\n        self.exchanges: Dict[str, ccxt.Exchange] = {}\n        # Minimum profit threshold (%) to consider an opportunity valid (double-checked with config)\n        self.min_profit_threshold = float(os.getenv('MIN_PROFIT_THRESHOLD', '0.3'))\n        self.reconnect_delay = int(os.getenv('RECONNECT_DELAY', '30'))\n        self.seen_opportunities = set()  # Cache of signatures\n        self.cache_ttl = 60  # seconds\n        self.loaded_config = None\n        self.seen_timestamps = {}\n        self.running = False\n\n        # lock for critical execution sections (optional usage)\n        self._internal_lock = asyncio.Lock()\n\n    # -----------------------------\n    # Base44 / config helpers\n    # -----------------------------\n    async def fetch_exchanges(self):\n        \"\"\"Load exchange configurations from base44 database\"\"\"\n        if not self.base44_api_url:\n            logger.warning(\"No BASE44_API_URL configured.\")\n            return None\n\n        url = f\"{self.base44_api_url}/entities/Exchange\"\n        status, payload = await fetch_json_with_timeout(url, method=\"GET\", headers=self.headers, timeout=8)\n        if status in (200, 201) and payload:\n            return payload\n        logger.error(f\"Failed to fetch exchanges from Base44 (status={status})\")\n        return None\n\n    async def watch_base44_config(self):\n        while True:\n            try:\n                if not self.loaded_config:\n                    self.loaded_config = await self.fetch_exchanges()\n\n                load_config = await self.fetch_exchanges()\n                if not load_config:\n                    await asyncio.sleep(self.reconnect_delay)\n                    continue\n\n                if load_config != self.loaded_config:\n                    logger.info(\"Detect configuration update. Re-initializing exchanges...\")\n                    await self.stop()\n                    await asyncio.sleep(2)\n                    await self.initialize_exchanges(load_config)\n                await asyncio.sleep(1800)\n            except Exception as e:\n                logger.error(f\"Error in watch_base44_config: {e}\")\n                await asyncio.sleep(self.reconnect_delay)\n\n    # -----------------------------\n    # Exchange initialization\n    # -----------------------------\n    async def initialize_exchanges(self, config=None):\n        \"\"\"Initialize exchanges with retry-per-exchange and safe close on failure.\"\"\"\n        try:\n            exchange_configs = await self.fetch_exchanges() if not config else config\n            if not exchange_configs:\n                logger.warning(\"No exchange configurations available to initialize.\")\n                return\n\n            for cfg in exchange_configs:\n                try:\n                    if not cfg.get('is_active', False):\n                        continue\n\n                    exchange_name = cfg.get('name', '').lower()\n                    ccxt_name = self._get_ccxt_name(exchange_name)\n\n                    if not hasattr(ccxt, ccxt_name):\n                        logger.warning(f\"CCXT does not support {ccxt_name}\")\n                        continue\n\n                    exchange_class = getattr(ccxt, ccxt_name)\n                    exchange = exchange_class({\n                        'apiKey': cfg.get('api_key', ''),\n                        'secret': cfg.get('api_secret', ''),\n                        'options': {'defaultType': 'spot'},\n                        'enableRateLimit': True,\n                        'timeout': 30000,\n                        'adjustForTimeDifference': True\n                    })\n\n                    # Attempt to load markets with per-exchange try/catch\n                    try:\n                        await asyncio.wait_for(exchange.load_markets(), timeout=30.0)\n                        self.exchanges[exchange_name] = exchange\n                        logger.info(f\"Successfully initialized {exchange_name}\")\n                    except asyncio.TimeoutError:\n                        logger.error(f\"Timeout initializing {exchange_name}\")\n                        try:\n                            await exchange.close()\n                        except Exception:\n                            pass\n                    except Exception as e:\n                        logger.error(f\"Failed to initialize {exchange_name}: {e}\")\n                        try:\n                            await exchange.close()\n                        except Exception:\n                            pass\n\n                except Exception as e:\n                    logger.error(f\"Unhandled error while initializing exchange config: {e}\")\n\n            self.loaded_config = exchange_configs\n        except Exception as e:\n            logger.error(f\"Failed to load exchange configurations: {e}\")\n\n    def _get_ccxt_name(self, exchange_name: str) -> str:\n        \"\"\"Map exchange names to ccxt identifiers\"\"\"\n        mapping = {\n            'binance': 'binance',\n            'coinbase': 'coinbasepro',\n            'coinbase pro': 'coinbase',\n            'kraken': 'kraken',\n            'kucoin': 'kucoin',\n            'bybit': 'bybit',\n            'mexc': 'mexc',\n            'huobi': 'huobi',\n            'okx': 'okx',\n            'gate.io': 'gate'\n        }\n        return mapping.get(exchange_name.lower(), exchange_name.lower())\n\n    # -----------------------------\n    # Slippage estimation\n    # -----------------------------\n    async def calc_slippage(self, exchange, symbol: str, side: str, qty: Decimal) -> Optional[Decimal]:\n        \"\"\"\n        Estimates slippage for a market order on the given exchange and symbol.\n        qty: for BUY -> quote amount (e.g., USD); for SELL -> base amount\n        Returns slippage fraction (Decimal) or None if insufficient liquidity\n        \"\"\"\n        try:\n            orderbook = await exchange.fetch_order_book(symbol)\n            if not orderbook or not orderbook.get('bids') or not orderbook.get('asks'):\n                return None\n\n            side = side.upper()\n            levels = orderbook['asks'] if side == 'BUY' else orderbook['bids']\n            filled_base = Decimal('0')\n            spent_quote = Decimal('0')\n\n            if side == 'BUY':\n                remaining_quote = qty\n                for price, amount in levels:\n                    price_d = Decimal(str(price))\n                    amount_d = Decimal(str(amount))\n                    level_quote = price_d * amount_d\n                    if remaining_quote <= level_quote:\n                        take_quote = remaining_quote\n                        take_base = take_quote / price_d\n                    else:\n                        take_quote = level_quote\n                        take_base = amount_d\n\n                    filled_base += take_base\n                    spent_quote += take_quote\n                    remaining_quote -= take_quote\n\n                    if remaining_quote <= 0:\n                        break\n\n                if remaining_quote > 0:\n                    return None\n\n                vwap = spent_quote / filled_base\n                best_price = Decimal(str(orderbook['asks'][0][0]))\n                if best_price == 0:\n                    return None\n                slippage = (vwap - best_price) / best_price\n\n            else:  # SELL\n                remaining_base = qty\n                for price, amount in levels:\n                    price_d = Decimal(str(price))\n                    amount_d = Decimal(str(amount))\n                    take_base = min(amount_d, remaining_base)\n                    filled_base += take_base\n                    spent_quote += take_base * price_d\n                    remaining_base -= take_base\n                    if remaining_base <= 0:\n                        break\n\n                if remaining_base > 0:\n                    return None\n\n                vwap = spent_quote / filled_base\n                best_price = Decimal(str(orderbook['bids'][0][0]))\n                if best_price == 0:\n                    return None\n                slippage = (best_price - vwap) / best_price\n\n            return max(slippage, Decimal('0'))\n        except Exception as e:\n            logger.error(f\"[SLIPPAGE] Error estimating slippage for {symbol} on {getattr(exchange,'id',str(exchange))}: {e}\")\n            return None\n\n    def _slippage_ok(self, slip: Optional[Decimal]) -> bool:\n        if slip is None:\n            return False\n        try:\n            return slip <= self.slippage_tolerance\n        except Exception:\n            return False\n\n    # -----------------------------\n    # Persistence / logging\n    # -----------------------------\n    async def _log_trade_to_base44(self, entity_data: dict) -> Optional[str]:\n        \"\"\"Logs a completed or pending trade to the 'Trade' entity.\"\"\"\n        try:\n            url = f\"{self.base44_api_url}/entities/Trade\"\n            status, payload = await fetch_json_with_timeout(url, method=\"POST\", json_payload=entity_data, headers=self.headers, timeout=8)\n            if status in (200, 201) and payload:\n                logger.info(f\"Successfully logged trade to base44. ID: {payload.get('id')}\")\n                return payload.get('id')\n            else:\n                logger.error(f\"Failed to log trade. Status: {status}, payload: {payload}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Exception while logging trade: {e}\")\n            return None\n\n    async def save_opportunity(self, op: Opportunity, entity_name: str):\n        \"\"\"Saves an opportunity to the base44 database with duplicate debounce and TTL.\"\"\"\n        try:\n            # Build unique signature (include timestamp bucket to reduce collisions)\n            now = time.time()\n            if entity_name == 'ArbitrageOpportunity':\n                signature = f\"{op.trading_pair}-{op.buy_exchange}-{op.sell_exchange}-{round(op.profit_percentage, 2)}\"\n            elif entity_name == 'TriangularOpportunity':\n                signature = f\"{op.exchange}-{'->'.join(op.trading_path or [])}-{round(op.profit_percentage, 2)}\"\n            else:\n                signature = f\"{op.detected_at}\"\n\n            if signature in self.seen_opportunities:\n                return\n\n            self.seen_opportunities.add(signature)\n            self.seen_timestamps[signature] = now\n            self._cleanup_seen_cache(now)\n\n            url = f\"{self.base44_api_url}/entities/{entity_name}\"\n            status, payload = await fetch_json_with_timeout(url, method=\"POST\", json_payload=asdict(op), headers=self.headers, timeout=8)\n            if status in (200, 201):\n                logger.info(f\"Saved {entity_name} opportunity: {payload.get('id')}\")\n                if self.notifier:\n                    # best-effort notify (do not block)\n                    try:\n                        await self.notifier.send_opportunity_alert(op, payload.get('id'))\n                    except Exception as e:\n                        logger.error(f\"Notifier send failed: {e}\")\n            else:\n                logger.error(f\"Failed to save {entity_name}: status={status}, payload={payload}\")\n        except Exception as e:\n            logger.error(f\"Exception saving {entity_name}: {e}\")\n\n    # -----------------------------\n    # Balance updater\n    # -----------------------------\n    async def update_account_balances_periodically(self):\n        \"\"\"Periodically fetches and updates balances for all exchanges with retries.\"\"\"\n        # wait a bit before first fetch\n        await asyncio.sleep(5)\n\n        while self.running:\n            logger.info(\"Updating account balances...\")\n            all_balances = {}\n            for name, exchange in list(self.exchanges.items()):\n                tries = 0\n                balance = {}\n                while tries < 3:\n                    try:\n                        resp = await exchange.fetch_balance()\n                        # Filter total balances\n                        balance = {\n                            asset: data for asset, data in resp.get('total', {}).items() if data and data > 0\n                        }\n                        break\n                    except Exception as e:\n                        tries += 1\n                        logger.warning(f\"Failed to fetch balance for {name} (attempt {tries}): {e}\")\n                        await asyncio.sleep(1 + tries * 2)\n                if balance:\n                    all_balances[name] = balance\n                else:\n                    logger.error(f\"Unable to fetch balances for {name} after retries.\")\n            # atomic replace\n            self.account_balances.clear()\n            self.account_balances.update(all_balances)\n            logger.info(\"Account balances updated successfully.\")\n            await asyncio.sleep(300)  # update every 5 minutes\n\n    # -----------------------------\n    # Helpers\n    # -----------------------------\n    def _cleanup_seen_cache(self, now):\n        expired = [sig for sig, ts in self.seen_timestamps.items() if now - ts > self.cache_ttl]\n        for sig in expired:\n            self.seen_opportunities.discard(sig)\n            self.seen_timestamps.pop(sig, None)\n\n    async def reconnect(self, exchange, sleep=None):\n        await asyncio.sleep(sleep or self.reconnect_delay)\n        try:\n            await exchange.close()\n        except Exception:\n            pass\n\n    async def stop(self):\n        \"\"\"Stop the arbitrage engine and cleanup connections\"\"\"\n        logger.info(\"Stopping Arbitrage Engine...\")\n        self.running = False\n        for name, exchange in list(self.exchanges.items()):\n            try:\n                if hasattr(exchange, 'close'):\n                    await exchange.close()\n                logger.info(f\"Closed {name} connection\")\n            except Exception as e:\n                logger.error(f\"Error closing {name}: {e}\")\n\n\n# instantiate engine with env vars (safe: no secrets printed)\nengine = Engine(base44_api_url=os.getenv('BASE44_API_URL'), app_token=os.getenv('BASE44_APP_TOKEN'))\n","size_bytes":16222},"cex/models.py":{"content":"from dataclasses import dataclass, asdict\nfrom typing import Optional, List\n\n@dataclass\nclass TradeResult:\n    status: str\n    message: str\n    trade_id: Optional[str] = None\n    profit_usd: Optional[float] = None\n\n@dataclass\nclass Opportunity:\n    # Common fields\n    profit_percentage: float = 0.0\n    detected_at: str = \"\"\n    status: str = \"active\"\n    # Cross-Exchange specific\n    trading_pair: Optional[str] = None\n    buy_exchange: Optional[str] = None\n    sell_exchange: Optional[str] = None\n    buy_price: Optional[float] = None\n    sell_price: Optional[float] = None\n    profit_usd: Optional[float] = None\n    volume: Optional[float] = None\n    # Triangular specific\n    exchange: Optional[str] = None\n    trading_path: Optional[List[str]] = None\n    assets: Optional[List[str]] = None \n    initial_amount: Optional[float] = None\n    final_amount: Optional[float] = None\n","size_bytes":882},"cex/triangular.py":{"content":"import asyncio\nimport ccxt.pro as ccxt\nfrom datetime import datetime\n\nfrom .engine import Engine, logger\nfrom .models import TradeResult, Opportunity\n\nfrom typing import Dict, List, Optional\nfrom decimal import Decimal, getcontext\nimport traceback\nimport math\n\ngetcontext().prec = 60\n\n\nclass Triangular:\n\n    def __init__(self, engine: Engine):\n        self.engine = engine\n        self.paths_by_pair = {}\n        self.order_book_cache = {}\n        self.reconnect_delay = int(self.engine.reconnect_delay or 30)\n\n    async def start_ops(self):\n        \"\"\"Orchestrates the setup and launch of perpetual scanner tasks for each exchange.\"\"\"\n        logger.info(\"Starting triangular opportunity scanning...\")\n        tasks = []\n\n        for exchange_name, exchange in self.engine.exchanges.items():\n            task = asyncio.create_task(self.exchange_scanner_loop(exchange_name, exchange))\n            tasks.append(task)\n\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n        else:\n            logger.warning(\"No exchanges available for triangular scanning\")\n\n    async def exchange_scanner_loop(self, exchange_name: str, exchange: ccxt.Exchange):\n        \"\"\"The main perpetual loop for a single exchange with improved error handling.\"\"\"\n        logger.info(f\"[{exchange_name}] Initializing triangular scanner...\")\n\n        all_paths = await self._generate_triangular_paths(exchange)\n        if not all_paths:\n            logger.warning(f\"[{exchange_name}] No triangular paths found. Stopping scanner.\")\n            return\n\n        unique_symbols = self._build_path_lookup_map(exchange_name, all_paths)\n        logger.info(f\"[{exchange_name}] Generated {len(all_paths)} paths across {len(unique_symbols)} symbols.\")\n\n        symbols_to_watch = unique_symbols[:20]  # watch top 20\n\n        tasks = []\n        try:\n            for symbol in symbols_to_watch:\n                task = asyncio.create_task(self._watch_symbol(exchange_name, exchange, symbol))\n                tasks.append(task)\n\n            if tasks:\n                await asyncio.gather(*tasks, return_exceptions=True)\n            else:\n                logger.warning(\"No symbol available to watch for triangular scanning\")\n\n        except Exception as e:\n            logger.error(f\"[{exchange_name}] Major error in scanner: {e}\")\n            logger.error(traceback.format_exc())\n            await asyncio.sleep(self.reconnect_delay)\n\n    async def _watch_symbol(self, exchange_name, exchange, symbol):\n        reconnect_attempts = 0\n        max_reconnect_delay = 300\n\n        while self.engine.running:\n            try:\n                ob = await asyncio.wait_for(exchange.watch_order_book(symbol), timeout=None)\n                if exchange_name not in self.order_book_cache:\n                    self.order_book_cache[exchange_name] = {}\n                self.order_book_cache[exchange_name][symbol] = ob\n                reconnect_attempts = 0\n\n                affected_paths = self.paths_by_pair[exchange_name].get(symbol, [])\n                for path in affected_paths:\n                    # calculate asynchronously but do not flood the event loop\n                    asyncio.create_task(self._calculate_path_profit(exchange_name, exchange, path))\n\n            except asyncio.TimeoutError:\n                logger.warning(f\"[{exchange_name}] Timeout for {symbol}\")\n            except Exception as e:\n                logger.warning(f\"[{exchange_name}] Error in symbol watcher for {symbol}: {e}\")\n                try:\n                    if hasattr(exchange, 'close'):\n                        await exchange.close()\n                except Exception:\n                    pass\n                delay = min(self.reconnect_delay * (2 ** reconnect_attempts), max_reconnect_delay)\n                logger.info(f\"[{exchange_name}] Reconnecting in {delay} seconds...\")\n                await asyncio.sleep(delay)\n                reconnect_attempts += 1\n\n    async def _calculate_path_profit(self, exchange_name: str, exchange, path: tuple):\n        \"\"\"Calculates the profit for a single triangular path with improved validation and decimal maths.\"\"\"\n        asset1, asset2, asset3, pair1, pair2, pair3 = path\n\n        try:\n            cache = self.order_book_cache.get(exchange_name, {})\n            ob1, ob2, ob3 = cache.get(pair1), cache.get(pair2), cache.get(pair3)\n            if not all([ob1, ob2, ob3]):\n                return\n\n            # ensure depth\n            if not (ob1.get('asks') and ob2.get('asks') and ob3.get('bids')):\n                return\n\n            initial_usdt = Decimal('1000')\n            fee_multiplier_per_trade = Decimal('0.999')  # 0.1% fee\n\n            # Rate detection using limits (top of book approach)\n            rate1 = self._get_conversion_rate(pair1, asset2, asset1, ob1, is_buy=True)\n            if not rate1:\n                return\n            amount_asset2 = (initial_usdt * fee_multiplier_per_trade) / Decimal(str(rate1))\n\n            rate2 = self._get_conversion_rate(pair2, asset3, asset2, ob2, is_buy=True)\n            if not rate2:\n                return\n            amount_asset3 = (Decimal(str(amount_asset2)) * fee_multiplier_per_trade) / Decimal(str(rate2))\n\n            rate3 = self._get_conversion_rate(pair3, asset3, asset1, ob3, is_buy=False)\n            if not rate3:\n                return\n            final_amount = Decimal(str(amount_asset3)) * Decimal(str(rate3))\n            final_amount_after_fees = final_amount * fee_multiplier_per_trade\n\n            profit_percentage = ((final_amount_after_fees - initial_usdt) / initial_usdt) * 100\n\n            if profit_percentage > Decimal(str(self.engine.min_profit_threshold)):\n                opp = Opportunity(\n                    exchange=exchange_name,\n                    trading_path=[pair1, pair2, pair3],\n                    assets=[asset1, asset2, asset3],\n                    profit_percentage=float(profit_percentage),\n                    initial_amount=float(initial_usdt),\n                    final_amount=float(final_amount_after_fees),\n                    detected_at=datetime.utcnow().isoformat()\n                )\n                logger.info(f\"Triangular Opportunity: {exchange_name} | {asset1}=>{asset2}=>{asset3} | {profit_percentage:.3f}%\")\n                await self.engine.save_opportunity(opp, 'TriangularOpportunity')\n\n        except (KeyError, IndexError, ZeroDivisionError, TypeError) as e:\n            logger.debug(f\"Data error for path {path}: {e}\")\n        except Exception as e:\n            logger.warning(f\"Calculation error for path {path}: {e}\")\n\n    def _build_path_lookup_map(self, exchange_name: str, all_paths: list) -> list:\n        self.paths_by_pair.setdefault(exchange_name, {})\n        self.order_book_cache.setdefault(exchange_name, {})\n        unique_symbols = set()\n\n        for path in all_paths:\n            asset1, _, _, pair1, pair2, pair3 = path\n            for pair in (pair1, pair2, pair3):\n                self.paths_by_pair[exchange_name].setdefault(pair, []).append(path)\n                unique_symbols.add(pair)\n\n        return list(unique_symbols)\n\n    async def _generate_triangular_paths(self, exchange) -> list:\n        try:\n            markets = await exchange.load_markets()\n            spot_markets = {symbol: m for symbol, m in markets.items() if m.get('spot') and m.get('active') and '/' in symbol}\n            logger.info(f\"[{exchange.id}] Found {len(spot_markets)} active spot markets.\")\n\n            asset_pairs = {}\n            for symbol in spot_markets:\n                base, quote = symbol.split('/')\n                for asset in (base, quote):\n                    asset_pairs.setdefault(asset, []).append(symbol)\n\n            valid_paths = set()\n            for pair1 in spot_markets:\n                asset1, asset2 = pair1.split('/')\n                for pair2 in asset_pairs.get(asset2, []):\n                    if pair2 == pair1:\n                        continue\n                    base2, quote2 = pair2.split('/')\n                    asset3 = base2 if base2 != asset2 else quote2\n                    for pair3 in (f\"{asset3}/{asset1}\", f\"{asset1}/{asset3}\"):\n                        if pair3 in spot_markets:\n                            valid_paths.add((asset1, asset2, asset3, pair1, pair2, pair3))\n                            break\n\n            logger.info(f\"[{exchange.id}] Generated {len(valid_paths)} total triangular paths.\")\n            # Keep priority assets only\n            priority_assets = {'USDT', 'BTC', 'ETH', 'BNB', 'USDC'}\n            filtered_paths = [p for p in valid_paths if any(a in priority_assets for a in p[:3])]\n            logger.info(f\"[{exchange.id}] Filtered to {len(filtered_paths)} priority paths.\")\n            return list(filtered_paths)\n        except Exception as e:\n            logger.info(f\"[{exchange.id}] Failed to generate triangular paths: {e}\")\n            return []\n\n    def _get_conversion_rate(self, pair, base, quote, ob, is_buy):\n        \"\"\"Returns the correct rate based on trade direction; uses top-of-book price.\"\"\"\n        try:\n            if not ob or not ob.get('asks') or not ob.get('bids'):\n                return None\n            if pair == f\"{base}/{quote}\":\n                return ob['asks'][0][0] if is_buy else ob['bids'][0][0]\n            elif pair == f\"{quote}/{base}\":\n                price = ob['bids'][0][0] if is_buy else ob['asks'][0][0]\n                return (1 / price) if price != 0 else None\n            return None\n        except Exception:\n            return None\n\n    async def _execute_triangular_trade(self, op: dict, req: dict) -> TradeResult:\n        exchange_name = op.get('exchange')\n        exchange: Optional[ccxt.Exchange] = self.engine.exchanges.get(exchange_name)\n        asset1, asset2, asset3 = op.get('assets', [])\n        pair1, pair2, pair3 = op.get('trading_path', [])\n        amount1 = float(req.get('amount', op.get('initial_amount', 1000)))\n\n        if not exchange:\n            return TradeResult(\"error\", f\"Exchange '{exchange_name}' not initialized.\")\n\n        if self.engine.account_balances.get(exchange_name, {}).get(asset1, 0) < amount1:\n            return TradeResult(\"error\", f\"Insufficient {asset1} on {exchange_name}\")\n\n        try:\n            logger.info(f\"LEG 1: Buying {pair1} with {amount1} {asset1}\")\n            amount2 = await self.try_trade_leg(exchange, pair1, asset1, amount1)\n            if isinstance(amount2, TradeResult) and amount2.status == \"error\":\n                return amount2\n\n            logger.info(f\"LEG 2: Trading {amount2} {asset2} via {pair2}\")\n            amount3 = await self.try_trade_leg(exchange, pair2, asset2, amount2)\n            if isinstance(amount3, TradeResult) and amount3.status == \"error\":\n                return amount3\n\n            logger.info(f\"LEG 3: Trading {amount3} {asset3} via {pair3}\")\n            final_amount = await self.try_trade_leg(exchange, pair3, asset3, amount3)\n            if isinstance(final_amount, TradeResult) and final_amount.status == \"error\":\n                return final_amount\n\n            profit = final_amount - amount1\n            log = {\n                \"opportunity_id\": op.get('id'),\n                \"trading_pair\": ' -> '.join(op.get('assets', [])),\n                \"buy_exchange\": exchange_name,\n                \"sell_exchange\": exchange_name,\n                \"quantity\": amount1,\n                \"profit_usd\": profit,\n                \"status\": \"completed\",\n                \"strategy\": \"triangular\"\n            }\n            trade_id = await self.engine._log_trade_to_base44(log)\n            return TradeResult(\"success\", \"Triangular trade executed successfully.\", trade_id, profit)\n\n        except Exception as e:\n            logger.error(f\"Error during triangular execution: {e}\\n{traceback.format_exc()}\")\n            return TradeResult(\"error\", f\"Failed on one of the legs: {e}. Manual intervention required.\")\n\n    async def try_trade_leg(self, exchange, pair, asset, amount):\n        pair_base, pair_quote = pair.split('/')\n        # Determine side: if asset is quote in the pair, we are BUYing pair_base using asset (quote)\n        # If asset equals pair_base, we are SELLing pair_base to receive quote.\n        side = \"BUY\" if asset == pair_quote else \"SELL\"\n        asset2 = pair_base if side == \"BUY\" else pair_quote\n\n        # estimate slippage using Decimal amounts (BUY expects quote amount for our calc; SELL expects base)\n        slip = await self.engine.calc_slippage(exchange, pair, side, Decimal(str(amount)))\n        if not self.engine._slippage_ok(slip):\n            return TradeResult(\"error\", f\"High slippage on {pair} {side}: {slip}\")\n\n        try:\n            if side == \"BUY\":\n                order = await exchange.create_market_buy_order_with_cost(pair, float(amount)) if hasattr(exchange, 'create_market_buy_order_with_cost') else await exchange.create_market_buy_order(pair, float(Decimal(str(amount)) / Decimal('1')))\n            else:\n                order = await exchange.create_market_sell_order(pair, float(amount))\n\n            return self.net_amount_received(order, asset2)\n        except Exception as e:\n            logger.error(f\"[TRADE LEG] Failed: {pair}, {side}, {amount}: {e}\")\n            return TradeResult(\"error\", f\"Trade leg failed: {e}\")\n\n    def net_amount_received(self, order: dict, received_asset: str) -> float:\n        fee = order.get(\"fee\", {}) or {}\n        fee_cost = Decimal(str(fee.get(\"cost\", 0))) if fee else Decimal('0')\n        fee_currency = fee.get(\"currency\")\n        symbol = order.get(\"symbol\", \"\")\n        base_asset = symbol.split(\"/\")[0] if symbol else None\n\n        if received_asset == base_asset:\n            gross_received = Decimal(str(order.get(\"filled\", 0)))\n        else:\n            gross_received = Decimal(str(order.get(\"cost\", 0)))\n\n        if fee_currency == received_asset:\n            return float(gross_received - fee_cost)\n        else:\n            return float(gross_received)\n\n    async def start(self):\n        logger.info(\"Starting Triangular Arbitrage Engine...\")\n        self.engine.running = True\n        if not self.engine.exchanges:\n            logger.error(\"No exchanges configured for triangular arbitrage\")\n            return\n        logger.info(f\"Initialized {len(self.engine.exchanges)} exchanges: {list(self.engine.exchanges.keys())}\")\n        await self.start_ops()\n","size_bytes":14327},"dex/__init__.py":{"content":"# DEX arbitrage system","size_bytes":22},"dex/bsc_service/__init__.py":{"content":"# BSC (Binance Smart Chain) Arbitrage Service","size_bytes":45},"dex/bsc_service/arbitrage.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom datetime import datetime\n\nfrom .engine import BSCEngine\nfrom .config import BSCConfig\nfrom .cross_arbitrage import BSCCrossArbitrageEngine\nfrom .triangular_arbitrage import BSCTriangularArbitrageEngine\nfrom .flashloan_engine import BSCFlashLoanEngine\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nlogger = logging.getLogger(__name__)\n\nclass BSCArbitrageService:\n    \"\"\"Main BSC arbitrage service coordinating all arbitrage engines\"\"\"\n    \n    def __init__(self, config: BSCConfig = None):\n        self.config = config or BSCConfig()\n        self.chain = \"bsc\"\n        self.chain_id = self.config.CHAIN_ID\n        \n        # Core engine\n        self.engine = BSCEngine(self.config)\n        \n        # Arbitrage engines\n        self.cross_arbitrage = BSCCrossArbitrageEngine(self.engine, self.config)\n        self.triangular_arbitrage = BSCTriangularArbitrageEngine(self.engine, self.config)\n        self.flash_loan = BSCFlashLoanEngine(self.engine, self.config)\n        \n        self.is_initialized = False\n        self.last_health_check = datetime.now()\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize all components\"\"\"\n        try:\n            logger.info(\"Initializing BSC Arbitrage Service...\")\n            \n            # Initialize core engine\n            await self.engine.initialize()\n            \n            # Initialize arbitrage engines\n            await self.cross_arbitrage.initialize()\n            await self.triangular_arbitrage.initialize()\n            await self.flash_loan.initialize()\n            \n            self.is_initialized = True\n            logger.info(\"BSC Arbitrage Service initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize BSC Arbitrage Service: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for all types of arbitrage opportunities\"\"\"\n        if not self.is_initialized:\n            logger.warning(\"BSC Service not initialized\")\n            return []\n        \n        try:\n            all_opportunities = []\n            \n            # Get cross-exchange opportunities\n            cross_ops = await self.cross_arbitrage.scan_opportunities()\n            all_opportunities.extend(cross_ops)\n            \n            # Get triangular arbitrage opportunities\n            triangular_ops = await self.triangular_arbitrage.scan_opportunities()\n            all_opportunities.extend(triangular_ops)\n            \n            # Get flash loan opportunities\n            flash_ops = await self.flash_loan.scan_opportunities()\n            all_opportunities.extend(flash_ops)\n            \n            logger.info(f\"Found {len(all_opportunities)} opportunities on BSC\")\n            return all_opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning BSC opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute a specific arbitrage opportunity\"\"\"\n        if not self.is_initialized:\n            raise RuntimeError(\"BSC Service not initialized\")\n        \n        try:\n            logger.info(f\"Executing BSC opportunity {opportunity.id} of type {opportunity.type}\")\n            \n            if opportunity.type == \"cross_exchange\":\n                return await self.cross_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"triangular\":\n                return await self.triangular_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"flash_loan\":\n                return await self.flash_loan.execute_opportunity(opportunity)\n            else:\n                raise ValueError(f\"Unknown opportunity type: {opportunity.type}\")\n                \n        except Exception as e:\n            logger.error(f\"Error executing BSC opportunity {opportunity.id}: {e}\")\n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get service health status\"\"\"\n        try:\n            self.last_health_check = datetime.now()\n            \n            # Check engine health\n            engine_health = await self._check_engine_health()\n            \n            # Check component health\n            components_health = await self._check_components_health()\n            \n            overall_healthy = (\n                engine_health[\"status\"] == \"healthy\" and\n                all(comp[\"status\"] == \"healthy\" for comp in components_health.values())\n            )\n            \n            return {\n                \"status\": \"healthy\" if overall_healthy else \"degraded\",\n                \"timestamp\": self.last_health_check.isoformat(),\n                \"chain\": self.chain,\n                \"chain_id\": self.chain_id,\n                \"engine\": engine_health,\n                \"components\": components_health,\n                \"initialized\": self.is_initialized\n            }\n            \n        except Exception as e:\n            logger.error(f\"BSC Health check failed: {e}\")\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": str(e),\n                \"timestamp\": datetime.now().isoformat()\n            }\n    \n    async def _check_engine_health(self) -> Dict[str, Any]:\n        \"\"\"Check core engine health\"\"\"\n        try:\n            if not self.engine or not self.engine.w3:\n                return {\"status\": \"unhealthy\", \"error\": \"Engine not initialized\"}\n            \n            # Test connection\n            is_connected = await self.engine.w3.is_connected()\n            if not is_connected:\n                return {\"status\": \"unhealthy\", \"error\": \"Web3 connection failed\"}\n            \n            # Test wallet\n            if self.engine.wallet_address:\n                balance = await self.engine.get_balance(\"0x0\")  # BNB balance\n                return {\n                    \"status\": \"healthy\",\n                    \"wallet_address\": self.engine.wallet_address,\n                    \"bnb_balance\": str(balance)\n                }\n            else:\n                return {\"status\": \"degraded\", \"warning\": \"No wallet configured\"}\n                \n        except Exception as e:\n            return {\"status\": \"unhealthy\", \"error\": str(e)}\n    \n    async def _check_components_health(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Check arbitrage components health\"\"\"\n        components = {\n            \"cross_arbitrage\": self.cross_arbitrage,\n            \"triangular_arbitrage\": self.triangular_arbitrage,\n            \"flash_loan\": self.flash_loan\n        }\n        \n        health_status = {}\n        \n        for name, component in components.items():\n            try:\n                if hasattr(component, 'get_health_status'):\n                    health_status[name] = await component.get_health_status()\n                else:\n                    # Basic health check\n                    health_status[name] = {\n                        \"status\": \"healthy\" if hasattr(component, 'initialized') else \"unknown\",\n                        \"initialized\": getattr(component, 'initialized', False)\n                    }\n            except Exception as e:\n                health_status[name] = {\n                    \"status\": \"unhealthy\",\n                    \"error\": str(e)\n                }\n        \n        return health_status\n    \n    async def ping(self) -> bool:\n        \"\"\"Simple ping for heartbeat monitoring\"\"\"\n        try:\n            if not self.is_initialized:\n                return False\n            \n            # Quick Web3 connection test\n            if self.engine and self.engine.w3:\n                return await self.engine.w3.is_connected()\n            \n            return False\n            \n        except Exception:\n            return False\n    \n    async def shutdown(self) -> None:\n        \"\"\"Graceful shutdown\"\"\"\n        try:\n            logger.info(\"Shutting down BSC Arbitrage Service...\")\n            \n            # Close engine connections\n            if self.engine:\n                await self.engine.shutdown()\n            \n            self.is_initialized = False\n            logger.info(\"BSC Arbitrage Service shutdown complete\")\n            \n        except Exception as e:\n            logger.error(f\"Error during BSC shutdown: {e}\")\n    \n    async def restart(self) -> None:\n        \"\"\"Restart the service\"\"\"\n        await self.shutdown()\n        await self.initialize()\n        logger.info(\"BSC Arbitrage Service restarted\")","size_bytes":8986},"dex/bsc_service/config.py":{"content":"import os\nfrom typing import List, Dict\n\nclass BSCConfig:\n    # Network Configuration\n    CHAIN_ID = int(os.getenv(\"BSC_CHAIN_ID\", \"56\"))  # 56=mainnet, 97=testnet\n    RPC_URL = os.getenv(\"BSC_RPC_URL\", \"https://bsc-dataseed1.binance.org/\")\n    WSS_URL = os.getenv(\"BSC_WSS_URL\", \"wss://bsc-ws-node.nariox.org:443\")\n    \n    # Wallet Configuration\n    PRIVATE_KEY = os.getenv(\"BSC_PRIVATE_KEY\", \"\")\n    WALLET_ADDRESS = os.getenv(\"BSC_WALLET_ADDRESS\", \"\")\n    \n    # Gas Configuration\n    MAX_GAS_PRICE_GWEI = int(os.getenv(\"BSC_MAX_GAS_PRICE_GWEI\", \"20\"))\n    GAS_PRICE_MULTIPLIER = float(os.getenv(\"BSC_GAS_PRICE_MULTIPLIER\", \"1.1\"))\n    \n    # Trading Configuration\n    MIN_PROFIT_THRESHOLD = float(os.getenv(\"BSC_MIN_PROFIT_THRESHOLD\", \"0.3\"))  # %\n    MAX_SLIPPAGE = float(os.getenv(\"BSC_MAX_SLIPPAGE\", \"0.5\"))  # %\n    MAX_TRADE_SIZE_BNB = float(os.getenv(\"BSC_MAX_TRADE_SIZE\", \"5.0\"))\n    \n    # DEX Addresses (BSC)\n    PANCAKESWAP_V2_ROUTER = \"0x10ED43C718714eb63d5aA57B78B54704E256024E\"\n    PANCAKESWAP_V2_FACTORY = \"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\"\n    PANCAKESWAP_V3_ROUTER = \"0x13f4EA83D0bd40E75C8222255bc855a974568Dd4\"\n    PANCAKESWAP_V3_FACTORY = \"0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865\"\n    PANCAKESWAP_V3_QUOTER_V2 = \"0xB048Bbc1Ee6b733FFfCFb9e9CeF7375518e25997\"\n    \n    BISWAP_ROUTER = \"0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8\"\n    BISWAP_FACTORY = \"0x858E3312ed3A876947EA49d572A7C42DE08af7EE\"\n    \n    APESWAP_ROUTER = \"0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7\"\n    APESWAP_FACTORY = \"0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6\"\n    \n    # Flash Loan Providers (BSC)\n    VENUS_COMPTROLLER = \"0xfD36E2c2a6789Db23113685031d7F16329158384\"\n    ALPACA_LENDING_POOL = \"0x0895196562C7868C5Be92459FaE7f877ED450452\"\n    \n    # Common Tokens (BSC addresses)\n    TOKENS = {\n        \"WBNB\": \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n        \"BUSD\": \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n        \"USDT\": \"0x55d398326f99059fF775485246999027B3197955\",\n        \"USDC\": \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\",\n        \"ETH\": \"0x2170Ed0880ac9A755fd29B2688956BD959F933F8\",\n        \"BTCB\": \"0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c\",\n        \"CAKE\": \"0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82\"\n    }\n    \n    # Mempool Configuration\n    MEMPOOL_MONITOR_ENABLED = os.getenv(\"BSC_MEMPOOL_MONITOR\", \"False\") == \"True\"\n    MIN_MEV_OPPORTUNITY_USD = float(os.getenv(\"BSC_MIN_MEV_OPPORTUNITY\", \"50.0\"))\n    \n    @classmethod\n    def validate(cls):\n        errors = []\n        if not cls.RPC_URL:\n            errors.append(\"BSC_RPC_URL not properly configured\")\n        if not cls.PRIVATE_KEY:\n            errors.append(\"BSC_PRIVATE_KEY not set\")\n        if errors:\n            raise RuntimeError(f\"BSC config validation errors: {'; '.join(errors)}\")","size_bytes":2782},"dex/bsc_service/cross_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import BSCEngine\nfrom .config import BSCConfig\n\nlogger = logging.getLogger(__name__)\n\nclass BSCCrossArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"BSC Cross-exchange arbitrage engine\"\"\"\n    \n    def __init__(self, engine: BSCEngine, config: BSCConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # BSC DEX configurations\n        self.dexes = {\n            \"pancakeswap_v2\": {\n                \"router\": config.PANCAKESWAP_V2_ROUTER,\n                \"factory\": config.PANCAKESWAP_V2_FACTORY,\n                \"fee\": 0.0025,  # 0.25%\n                \"type\": \"v2\"\n            },\n            \"pancakeswap_v3\": {\n                \"router\": config.PANCAKESWAP_V3_ROUTER,\n                \"factory\": config.PANCAKESWAP_V3_FACTORY,\n                \"quoter\": config.PANCAKESWAP_V3_QUOTER_V2,\n                \"fee_tiers\": [100, 500, 2500, 10000],  # 0.01%, 0.05%, 0.25%, 1%\n                \"type\": \"v3\"\n            },\n            \"biswap\": {\n                \"router\": config.BISWAP_ROUTER,\n                \"factory\": config.BISWAP_FACTORY,\n                \"fee\": 0.001,  # 0.1%\n                \"type\": \"v2\"\n            },\n            \"apeswap\": {\n                \"router\": config.APESWAP_ROUTER,\n                \"factory\": config.APESWAP_FACTORY,\n                \"fee\": 0.002,  # 0.2%\n                \"type\": \"v2\"\n            }\n        }\n        \n        # Common trading pairs on BSC\n        self.trading_pairs = [\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"BUSD\"]),\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"USDC\"]),\n            (config.TOKENS[\"BUSD\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"BUSD\"], config.TOKENS[\"USDC\"]),\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"ETH\"]),\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"BTCB\"]),\n            (config.TOKENS[\"WBNB\"], config.TOKENS[\"CAKE\"])\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize cross arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing BSC Cross Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"BSC Cross Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize BSC cross arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for cross-exchange arbitrage opportunities on BSC\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for token_a, token_b in self.trading_pairs:\n                # Check prices across different DEXes\n                prices = await self._get_prices_across_dexes(token_a, token_b)\n                \n                if len(prices) >= 2:\n                    # Find best buy and sell prices\n                    best_buy = min(prices, key=lambda x: x[\"price\"])\n                    best_sell = max(prices, key=lambda x: x[\"price\"])\n                    \n                    if best_buy[\"dex\"] != best_sell[\"dex\"]:\n                        price_diff = best_sell[\"price\"] - best_buy[\"price\"]\n                        profit_percentage = (price_diff / best_buy[\"price\"]) * 100\n                        \n                        if profit_percentage > self.config.MIN_PROFIT_THRESHOLD:\n                            # Calculate potential profit\n                            trade_amount = Decimal(\"1.0\")  # 1 unit of token_a\n                            \n                            profit_usd = await self._calculate_profit(\n                                token_a, token_b, trade_amount,\n                                best_buy, best_sell\n                            )\n                            \n                            if profit_usd > Decimal(\"10\"):  # Minimum $10 profit\n                                opportunity = ArbitrageOpportunity(\n                                    id=f\"bsc_cross_{best_buy['dex']}_{best_sell['dex']}_{datetime.now().timestamp()}\",\n                                    type=\"cross_exchange\",\n                                    chain=\"bsc\",\n                                    token_a=token_a,\n                                    token_b=token_b,\n                                    exchange_a=best_buy[\"dex\"],\n                                    exchange_b=best_sell[\"dex\"],\n                                    price_a=best_buy[\"price\"],\n                                    price_b=best_sell[\"price\"],\n                                    price_difference=price_diff,\n                                    profit_usd=profit_usd,\n                                    gas_cost_usd=await self._estimate_gas_cost(),\n                                    amount_in=trade_amount,\n                                    amount_out=trade_amount * best_sell[\"price\"],\n                                    total_liquidity_usd=await self._estimate_liquidity(token_a, token_b),\n                                    price_impact=await self._estimate_price_impact(trade_amount, best_buy, best_sell),\n                                    timestamp=datetime.now()\n                                )\n                                \n                                opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} BSC cross-arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning BSC cross arbitrage opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute cross-exchange arbitrage on BSC\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing BSC cross arbitrage: {opportunity.id}\")\n            \n            # Step 1: Buy on exchange A\n            buy_result = await self._execute_buy(\n                opportunity.exchange_a,\n                opportunity.token_a,\n                opportunity.token_b,\n                opportunity.amount_in\n            )\n            \n            if not buy_result[\"success\"]:\n                raise Exception(f\"Buy failed: {buy_result['error']}\")\n            \n            # Step 2: Sell on exchange B\n            sell_result = await self._execute_sell(\n                opportunity.exchange_b,\n                opportunity.token_b,\n                opportunity.token_a,\n                buy_result[\"amount_out\"]\n            )\n            \n            if not sell_result[\"success\"]:\n                raise Exception(f\"Sell failed: {sell_result['error']}\")\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            # Calculate actual profit\n            actual_profit = sell_result[\"amount_out\"] - opportunity.amount_in\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=True,\n                profit_usd=actual_profit * opportunity.price_a,  # Convert to USD\n                gas_cost_usd=buy_result[\"gas_cost\"] + sell_result[\"gas_cost\"],\n                execution_time=execution_time,\n                transaction_hashes=[buy_result[\"tx_hash\"], sell_result[\"tx_hash\"]]\n            )\n            \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"BSC cross arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _get_prices_across_dexes(self, token_a: str, token_b: str) -> List[Dict[str, Any]]:\n        \"\"\"Get prices for token pair across all DEXes\"\"\"\n        prices = []\n        \n        for dex_name, dex_config in self.dexes.items():\n            try:\n                if dex_config[\"type\"] == \"v2\":\n                    price = await self._get_v2_price(token_a, token_b, dex_config)\n                else:  # v3\n                    price = await self._get_v3_price(token_a, token_b, dex_config)\n                \n                if price and price > 0:\n                    prices.append({\n                        \"dex\": dex_name,\n                        \"price\": price,\n                        \"config\": dex_config\n                    })\n                    \n            except Exception as e:\n                logger.debug(f\"Error getting price from {dex_name}: {e}\")\n                continue\n        \n        return prices\n    \n    async def _get_v2_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from V2 DEX (simplified)\"\"\"\n        try:\n            # This would call the pair contract to get reserves\n            # For now, return a mock price with some variation\n            base_price = Decimal(\"400.50\")  # Mock WBNB/BUSD price\n            variation = Decimal(\"0.01\") * (hash(dex_config[\"router\"]) % 100)\n            return base_price + variation\n            \n        except Exception as e:\n            logger.debug(f\"Error getting V2 price: {e}\")\n            return None\n    \n    async def _get_v3_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from V3 DEX using quoter\"\"\"\n        try:\n            # This would call the quoter contract\n            # For now, return a mock price with different variation\n            base_price = Decimal(\"400.75\")  # Mock WBNB/BUSD price\n            variation = Decimal(\"0.02\") * (hash(dex_config[\"quoter\"]) % 50)\n            return base_price + variation\n            \n        except Exception as e:\n            logger.debug(f\"Error getting V3 price: {e}\")\n            return None\n    \n    async def _calculate_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        amount: Decimal,\n        buy_data: Dict,\n        sell_data: Dict\n    ) -> Decimal:\n        \"\"\"Calculate expected profit in USD\"\"\"\n        try:\n            buy_cost = amount * buy_data[\"price\"]\n            sell_revenue = amount * sell_data[\"price\"]\n            \n            # Subtract fees\n            buy_fee = buy_cost * Decimal(str(buy_data[\"config\"][\"fee\"]))\n            sell_fee = sell_revenue * Decimal(str(sell_data[\"config\"][\"fee\"]))\n            \n            gross_profit = sell_revenue - buy_cost\n            net_profit = gross_profit - buy_fee - sell_fee\n            \n            return net_profit\n            \n        except Exception as e:\n            logger.error(f\"Error calculating BSC profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _estimate_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for cross arbitrage in USD\"\"\"\n        try:\n            # BSC gas is typically very low\n            gas_price_gwei = 5  # 5 Gwei typical\n            gas_used = 200000  # Two swaps\n            \n            # BNB price (mock)\n            bnb_price_usd = Decimal(\"600\")\n            \n            gas_cost_bnb = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_bnb * bnb_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"2.0\")  # Fallback\n    \n    async def _estimate_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate available liquidity\"\"\"\n        # Mock liquidity estimation\n        return Decimal(\"100000\")  # $100K\n    \n    async def _estimate_price_impact(\n        self, \n        amount: Decimal, \n        buy_data: Dict, \n        sell_data: Dict\n    ) -> float:\n        \"\"\"Estimate price impact\"\"\"\n        # Simple price impact estimation\n        return 0.1  # 0.1%\n    \n    async def _execute_buy(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute buy order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing buy on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution for now\n            # This would build and execute actual swap transaction\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"0.998\"),  # After fees\n                \"tx_hash\": f\"0x{'abc123' * 10}\",\n                \"gas_cost\": Decimal(\"1.0\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost\": Decimal(\"0\")\n            }\n    \n    async def _execute_sell(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute sell order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing sell on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution for now\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"1.002\"),  # Favorable rate\n                \"tx_hash\": f\"0x{'def456' * 10}\",\n                \"gas_cost\": Decimal(\"1.0\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"supported_dexes\": list(self.dexes.keys()),\n            \"trading_pairs\": len(self.trading_pairs)\n        }","size_bytes":14348},"dex/bsc_service/engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional, Union\nfrom web3 import Web3, AsyncWeb3\nfrom web3.exceptions import Web3Exception\nfrom eth_account import Account\nfrom eth_utils import to_wei, from_wei\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseEngine\nfrom models.arbitrage_models import ExecutionResult\n\nfrom .config import BSCConfig\n\nlogger = logging.getLogger(__name__)\n\nclass BSCEngine(BaseEngine):\n    \"\"\"BSC (Binance Smart Chain) blockchain engine for Web3 operations\"\"\"\n    \n    def __init__(self, config: BSCConfig):\n        self.config = config\n        self.w3: Optional[AsyncWeb3] = None\n        self.account: Optional[Account] = None\n        self.wallet_address: Optional[str] = None\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize Web3 connection and wallet\"\"\"\n        try:\n            # Initialize Web3 connection\n            self.w3 = AsyncWeb3(AsyncWeb3.AsyncHTTPProvider(self.config.RPC_URL))\n            \n            # Check connection\n            if not await self.w3.is_connected():\n                raise ConnectionError(\"Failed to connect to BSC RPC\")\n            \n            # Initialize wallet\n            if self.config.PRIVATE_KEY:\n                self.account = Account.from_key(self.config.PRIVATE_KEY)\n                self.wallet_address = self.account.address\n                logger.info(f\"BSC Wallet initialized: {self.wallet_address}\")\n            \n            # Verify network\n            chain_id = await self.w3.eth.chain_id\n            if chain_id != self.config.CHAIN_ID:\n                logger.warning(f\"BSC Chain ID mismatch: expected {self.config.CHAIN_ID}, got {chain_id}\")\n            \n            logger.info(f\"BSC engine initialized on chain {chain_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize BSC engine: {e}\")\n            raise\n    \n    async def get_balance(self, token_address: str, wallet_address: str = None) -> Decimal:\n        \"\"\"Get token balance for wallet\"\"\"\n        try:\n            target_wallet = wallet_address or self.wallet_address\n            if not target_wallet:\n                raise ValueError(\"No wallet address provided\")\n            \n            # BNB balance\n            if token_address.lower() == \"0x0\" or token_address.upper() == \"BNB\":\n                balance_wei = await self.w3.eth.get_balance(target_wallet)\n                return Decimal(from_wei(balance_wei, 'ether'))\n            else:\n                # ERC20 token balance (using standard ERC20 ABI)\n                erc20_abi = [\n                    {\n                        \"constant\": True,\n                        \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n                        \"name\": \"balanceOf\",\n                        \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n                        \"type\": \"function\"\n                    },\n                    {\n                        \"constant\": True,\n                        \"inputs\": [],\n                        \"name\": \"decimals\",\n                        \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n                        \"type\": \"function\"\n                    }\n                ]\n                \n                contract = self.w3.eth.contract(address=Web3.to_checksum_address(token_address), abi=erc20_abi)\n                balance_wei = await contract.functions.balanceOf(target_wallet).call()\n                decimals = await contract.functions.decimals().call()\n                \n                return Decimal(balance_wei) / Decimal(10 ** decimals)\n                \n        except Exception as e:\n            logger.error(f\"Error getting BSC balance for {token_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_gas_price(self) -> Dict[str, int]:\n        \"\"\"Get current gas price (BSC uses legacy gas pricing)\"\"\"\n        try:\n            # BSC primarily uses legacy gas pricing\n            gas_price = await self.w3.eth.gas_price\n            \n            # Apply multiplier and cap\n            adjusted_gas_price = int(gas_price * self.config.GAS_PRICE_MULTIPLIER)\n            max_gas_price = to_wei(self.config.MAX_GAS_PRICE_GWEI, 'gwei')\n            \n            final_gas_price = min(adjusted_gas_price, max_gas_price)\n            \n            return {\n                \"gasPrice\": final_gas_price,\n                \"type\": \"legacy\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting BSC gas price: {e}\")\n            # Fallback to 5 gwei\n            return {\n                \"gasPrice\": to_wei(5, 'gwei'),\n                \"type\": \"legacy\"\n            }\n    \n    async def estimate_gas(self, transaction: Dict[str, Any]) -> int:\n        \"\"\"Estimate gas for transaction\"\"\"\n        try:\n            gas_estimate = await self.w3.eth.estimate_gas(transaction)\n            # Add 20% buffer for BSC\n            return int(gas_estimate * 1.2)\n            \n        except Exception as e:\n            logger.error(f\"Error estimating BSC gas: {e}\")\n            return 100000  # Default fallback\n    \n    async def execute_transaction(self, transaction_data: Dict[str, Any]) -> str:\n        \"\"\"Execute transaction on BSC\"\"\"\n        try:\n            if not self.account or not self.wallet_address:\n                raise ValueError(\"Wallet not initialized\")\n            \n            # Get current nonce\n            nonce = await self.w3.eth.get_transaction_count(self.wallet_address)\n            \n            # Get gas price\n            gas_info = await self.get_gas_price()\n            \n            # Build transaction\n            transaction = {\n                \"to\": transaction_data.get(\"to\"),\n                \"value\": transaction_data.get(\"value\", 0),\n                \"data\": transaction_data.get(\"data\", \"0x\"),\n                \"gas\": transaction_data.get(\"gas\") or await self.estimate_gas(transaction_data),\n                \"gasPrice\": gas_info[\"gasPrice\"],\n                \"nonce\": nonce,\n                \"chainId\": self.config.CHAIN_ID\n            }\n            \n            # Sign transaction\n            signed_txn = self.account.sign_transaction(transaction)\n            \n            # Send transaction\n            tx_hash = await self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)\n            \n            logger.info(f\"BSC Transaction sent: {tx_hash.hex()}\")\n            return tx_hash.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error executing BSC transaction: {e}\")\n            raise\n    \n    async def wait_for_transaction_receipt(self, tx_hash: str, timeout: int = 60) -> Dict[str, Any]:\n        \"\"\"Wait for transaction confirmation\"\"\"\n        try:\n            receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=timeout)\n            return {\n                \"success\": receipt.status == 1,\n                \"blockNumber\": receipt.blockNumber,\n                \"gasUsed\": receipt.gasUsed,\n                \"receipt\": receipt\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error waiting for BSC transaction receipt: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def get_current_block(self) -> int:\n        \"\"\"Get current block number\"\"\"\n        try:\n            return await self.w3.eth.block_number\n        except Exception as e:\n            logger.error(f\"Error getting BSC block number: {e}\")\n            return 0\n    \n    async def shutdown(self) -> None:\n        \"\"\"Shutdown engine\"\"\"\n        try:\n            if self.w3:\n                # Close any open connections\n                pass\n            logger.info(\"BSC engine shutdown complete\")\n        except Exception as e:\n            logger.error(f\"Error shutting down BSC engine: {e}\")","size_bytes":7897},"dex/bsc_service/flashloan_engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import BSCEngine\nfrom .config import BSCConfig\n\nlogger = logging.getLogger(__name__)\n\nclass BSCFlashLoanEngine(BaseArbitrageEngine):\n    \"\"\"BSC Flash loan arbitrage engine\"\"\"\n    \n    def __init__(self, engine: BSCEngine, config: BSCConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Flash loan providers on BSC\n        self.flash_loan_providers = {\n            \"venus\": {\n                \"address\": config.VENUS_COMPTROLLER,\n                \"fee\": 0.0009,  # 0.09%\n                \"max_amount\": {\n                    config.TOKENS[\"WBNB\"]: Decimal(\"10000\"),\n                    config.TOKENS[\"BUSD\"]: Decimal(\"5000000\"),\n                    config.TOKENS[\"USDT\"]: Decimal(\"5000000\"),\n                    config.TOKENS[\"USDC\"]: Decimal(\"5000000\"),\n                    config.TOKENS[\"ETH\"]: Decimal(\"1000\"),\n                    config.TOKENS[\"BTCB\"]: Decimal(\"100\")\n                }\n            },\n            \"alpaca\": {\n                \"address\": config.ALPACA_LENDING_POOL,\n                \"fee\": 0.0005,  # 0.05%\n                \"max_amount\": {\n                    config.TOKENS[\"WBNB\"]: Decimal(\"5000\"),\n                    config.TOKENS[\"BUSD\"]: Decimal(\"2000000\"),\n                    config.TOKENS[\"USDT\"]: Decimal(\"2000000\")\n                }\n            }\n        }\n        \n        # DEX combinations for flash loan arbitrage\n        self.dex_combinations = [\n            (\"pancakeswap_v2\", \"biswap\"),\n            (\"pancakeswap_v2\", \"apeswap\"),\n            (\"biswap\", \"apeswap\"),\n            (\"pancakeswap_v3\", \"pancakeswap_v2\")\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize flash loan engine\"\"\"\n        try:\n            logger.info(\"Initializing BSC Flash Loan Engine...\")\n            self.initialized = True\n            logger.info(\"BSC Flash Loan Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize BSC flash loan engine: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for flash loan arbitrage opportunities on BSC\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            # Check major token pairs for flash loan opportunities\n            major_tokens = [\n                self.config.TOKENS[\"WBNB\"],\n                self.config.TOKENS[\"BUSD\"],\n                self.config.TOKENS[\"USDT\"],\n                self.config.TOKENS[\"USDC\"],\n                self.config.TOKENS[\"ETH\"]\n            ]\n            \n            for i, token_a in enumerate(major_tokens):\n                for token_b in major_tokens[i+1:]:\n                    for dex_a, dex_b in self.dex_combinations:\n                        opportunity = await self._check_flash_loan_opportunity(\n                            token_a, token_b, dex_a, dex_b\n                        )\n                        if opportunity:\n                            opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} BSC flash loan opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning BSC flash loan opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute flash loan arbitrage on BSC\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing BSC flash loan arbitrage: {opportunity.id}\")\n            \n            # Select best flash loan provider\n            provider = await self._select_best_provider(\n                opportunity.token_a, \n                opportunity.loan_amount\n            )\n            \n            if not provider:\n                raise Exception(\"No suitable flash loan provider found\")\n            \n            # Execute flash loan arbitrage\n            result = await self._execute_flash_loan_arbitrage(\n                provider,\n                opportunity\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=result[\"profit_usd\"],\n                    gas_cost_usd=result[\"gas_cost_usd\"],\n                    execution_time=execution_time,\n                    transaction_hashes=[result[\"tx_hash\"]]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"gas_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"BSC flash loan execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_flash_loan_opportunity(\n        self, \n        token_a: str, \n        token_b: str, \n        dex_a: str, \n        dex_b: str\n    ) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check for flash loan arbitrage opportunity between two DEXes\"\"\"\n        try:\n            # Get prices on both DEXes\n            price_dex_a = await self._get_dex_price(token_a, token_b, dex_a)\n            price_dex_b = await self._get_dex_price(token_a, token_b, dex_b)\n            \n            if not price_dex_a or not price_dex_b:\n                return None\n            \n            # Determine which direction is profitable\n            if price_dex_b > price_dex_a:\n                buy_dex, sell_dex = dex_a, dex_b\n                buy_price, sell_price = price_dex_a, price_dex_b\n            else:\n                buy_dex, sell_dex = dex_b, dex_a\n                buy_price, sell_price = price_dex_b, price_dex_a\n            \n            price_diff = sell_price - buy_price\n            profit_percentage = (price_diff / buy_price) * 100\n            \n            if profit_percentage > Decimal(\"0.5\"):  # Minimum 0.5% price difference\n                # Calculate optimal loan amount\n                loan_amount = await self._calculate_optimal_loan_amount(\n                    token_a, buy_price, sell_price\n                )\n                \n                if loan_amount > Decimal(\"100\"):  # Minimum loan amount\n                    # Calculate expected profit\n                    profit_usd = await self._calculate_flash_loan_profit(\n                        token_a, token_b, loan_amount, buy_price, sell_price\n                    )\n                    \n                    if profit_usd > Decimal(\"20\"):  # Minimum $20 profit\n                        return ArbitrageOpportunity(\n                            id=f\"bsc_flash_{buy_dex}_{sell_dex}_{datetime.now().timestamp()}\",\n                            type=\"flash_loan\",\n                            chain=\"bsc\",\n                            token_a=token_a,\n                            token_b=token_b,\n                            exchange_a=buy_dex,\n                            exchange_b=sell_dex,\n                            price_a=buy_price,\n                            price_b=sell_price,\n                            price_difference=price_diff,\n                            profit_usd=profit_usd,\n                            gas_cost_usd=await self._estimate_flash_loan_gas_cost(),\n                            loan_amount=loan_amount,\n                            amount_in=loan_amount,\n                            amount_out=loan_amount * (sell_price / buy_price),\n                            total_liquidity_usd=await self._estimate_dex_liquidity(token_a, token_b),\n                            price_impact=await self._estimate_flash_loan_price_impact(loan_amount),\n                            timestamp=datetime.now()\n                        )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking flash loan opportunity: {e}\")\n            return None\n    \n    async def _get_dex_price(self, token_a: str, token_b: str, dex: str) -> Optional[Decimal]:\n        \"\"\"Get price from specific DEX\"\"\"\n        try:\n            # Mock price fetching with DEX-specific variations\n            base_price = Decimal(\"600.0\")  # Mock base price\n            \n            dex_variations = {\n                \"pancakeswap_v2\": Decimal(\"0.0\"),\n                \"pancakeswap_v3\": Decimal(\"0.5\"),\n                \"biswap\": Decimal(\"-1.0\"),\n                \"apeswap\": Decimal(\"1.5\")\n            }\n            \n            variation = dex_variations.get(dex, Decimal(\"0\"))\n            return base_price + variation\n            \n        except Exception as e:\n            logger.debug(f\"Error getting {dex} price: {e}\")\n            return None\n    \n    async def _calculate_optimal_loan_amount(\n        self, \n        token: str, \n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate optimal flash loan amount\"\"\"\n        try:\n            # Get available liquidity from providers\n            max_available = Decimal(\"0\")\n            \n            for provider_data in self.flash_loan_providers.values():\n                provider_max = provider_data[\"max_amount\"].get(token, Decimal(\"0\"))\n                max_available = max(max_available, provider_max)\n            \n            # Calculate amount that maximizes profit considering slippage\n            price_diff = sell_price - buy_price\n            profit_percentage = price_diff / buy_price\n            \n            # Conservative amount to minimize slippage\n            optimal_amount = min(\n                max_available * Decimal(\"0.1\"),  # 10% of max available\n                Decimal(\"1000\")  # Cap at reasonable amount\n            )\n            \n            return optimal_amount\n            \n        except Exception as e:\n            logger.error(f\"Error calculating optimal loan amount: {e}\")\n            return Decimal(\"100\")  # Fallback\n    \n    async def _calculate_flash_loan_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        loan_amount: Decimal,\n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate expected profit from flash loan arbitrage\"\"\"\n        try:\n            # Calculate revenue from arbitrage\n            bought_amount = loan_amount / buy_price\n            sold_amount = bought_amount * sell_price\n            gross_profit = sold_amount - loan_amount\n            \n            # Subtract flash loan fee (using Venus as example)\n            flash_loan_fee = loan_amount * Decimal(\"0.0009\")\n            \n            # Subtract DEX fees (0.25% each)\n            buy_fee = loan_amount * Decimal(\"0.0025\")\n            sell_fee = sold_amount * Decimal(\"0.0025\")\n            \n            net_profit = gross_profit - flash_loan_fee - buy_fee - sell_fee\n            \n            # Convert to USD\n            token_price_usd = await self._get_token_price_usd(token_a)\n            profit_usd = net_profit * token_price_usd\n            \n            return profit_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating flash loan profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        # Mock USD prices\n        prices = {\n            self.config.TOKENS[\"WBNB\"]: Decimal(\"600.00\"),\n            self.config.TOKENS[\"BUSD\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDT\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDC\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"ETH\"]: Decimal(\"3200.00\"),\n            self.config.TOKENS[\"BTCB\"]: Decimal(\"65000.00\")\n        }\n        return prices.get(token, Decimal(\"1.00\"))\n    \n    async def _estimate_flash_loan_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for flash loan arbitrage\"\"\"\n        try:\n            # BSC gas cost for flash loan + 2 swaps\n            gas_price_gwei = 5\n            gas_used = 400000  # Flash loan with swaps\n            \n            bnb_price_usd = Decimal(\"600\")\n            \n            gas_cost_bnb = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_bnb * bnb_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"4.0\")  # Fallback\n    \n    async def _estimate_dex_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate DEX liquidity\"\"\"\n        return Decimal(\"200000\")  # $200K mock liquidity\n    \n    async def _estimate_flash_loan_price_impact(self, loan_amount: Decimal) -> float:\n        \"\"\"Estimate price impact from flash loan arbitrage\"\"\"\n        # Higher amounts have higher impact\n        impact_factor = float(loan_amount) / 10000  # Base factor\n        return min(2.0, 0.1 + impact_factor * 0.001)  # Cap at 2%\n    \n    async def _select_best_provider(self, token: str, amount: Decimal) -> Optional[Dict]:\n        \"\"\"Select best flash loan provider\"\"\"\n        try:\n            best_provider = None\n            lowest_fee = Decimal(\"999\")\n            \n            for provider_name, provider_data in self.flash_loan_providers.items():\n                max_amount = provider_data[\"max_amount\"].get(token, Decimal(\"0\"))\n                fee = Decimal(str(provider_data[\"fee\"]))\n                \n                if max_amount >= amount and fee < lowest_fee:\n                    lowest_fee = fee\n                    best_provider = {\n                        \"name\": provider_name,\n                        \"data\": provider_data\n                    }\n            \n            return best_provider\n            \n        except Exception as e:\n            logger.error(f\"Error selecting flash loan provider: {e}\")\n            return None\n    \n    async def _execute_flash_loan_arbitrage(\n        self, \n        provider: Dict, \n        opportunity: ArbitrageOpportunity\n    ) -> Dict[str, Any]:\n        \"\"\"Execute flash loan arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing flash loan arbitrage via {provider['name']}\")\n            \n            # Mock execution for now\n            # This would deploy and call flash loan contract\n            \n            # Simulate successful execution\n            profit_usd = opportunity.profit_usd * Decimal(\"0.9\")  # 90% of expected\n            \n            return {\n                \"success\": True,\n                \"profit_usd\": profit_usd,\n                \"gas_cost_usd\": Decimal(\"4.0\"),\n                \"tx_hash\": f\"0x{'flashloan' * 8}\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost_usd\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"flash_loan_providers\": list(self.flash_loan_providers.keys()),\n            \"dex_combinations\": len(self.dex_combinations)\n        }","size_bytes":16147},"dex/bsc_service/triangular_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import BSCEngine\nfrom .config import BSCConfig\n\nlogger = logging.getLogger(__name__)\n\nclass BSCTriangularArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"BSC Triangular arbitrage engine\"\"\"\n    \n    def __init__(self, engine: BSCEngine, config: BSCConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Triangular arbitrage paths on BSC\n        self.triangular_paths = [\n            # WBNB -> BUSD -> USDT -> WBNB\n            [config.TOKENS[\"WBNB\"], config.TOKENS[\"BUSD\"], config.TOKENS[\"USDT\"]],\n            # WBNB -> BUSD -> USDC -> WBNB\n            [config.TOKENS[\"WBNB\"], config.TOKENS[\"BUSD\"], config.TOKENS[\"USDC\"]],\n            # WBNB -> ETH -> BUSD -> WBNB\n            [config.TOKENS[\"WBNB\"], config.TOKENS[\"ETH\"], config.TOKENS[\"BUSD\"]],\n            # WBNB -> BTCB -> BUSD -> WBNB\n            [config.TOKENS[\"WBNB\"], config.TOKENS[\"BTCB\"], config.TOKENS[\"BUSD\"]],\n            # WBNB -> CAKE -> BUSD -> WBNB\n            [config.TOKENS[\"WBNB\"], config.TOKENS[\"CAKE\"], config.TOKENS[\"BUSD\"]],\n        ]\n        \n        # Primary DEX for triangular arbitrage (PancakeSwap V2)\n        self.primary_dex = {\n            \"router\": config.PANCAKESWAP_V2_ROUTER,\n            \"factory\": config.PANCAKESWAP_V2_FACTORY,\n            \"fee\": 0.0025  # 0.25%\n        }\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize triangular arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing BSC Triangular Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"BSC Triangular Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize BSC triangular arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for triangular arbitrage opportunities on BSC\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for path in self.triangular_paths:\n                opportunity = await self._check_triangular_path(path)\n                if opportunity:\n                    opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} BSC triangular arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning BSC triangular arbitrage: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute triangular arbitrage on BSC\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing BSC triangular arbitrage: {opportunity.id}\")\n            \n            # Execute the three swaps in sequence\n            result = await self._execute_triangular_swaps(\n                opportunity.token_a,\n                opportunity.token_b, \n                opportunity.token_c,\n                opportunity.amount_in\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                actual_profit = result[\"final_amount\"] - opportunity.amount_in\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=actual_profit * result[\"token_price\"],  # Convert to USD\n                    gas_cost_usd=result[\"total_gas_cost\"],\n                    execution_time=execution_time,\n                    transaction_hashes=result[\"tx_hashes\"]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"total_gas_cost\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"BSC triangular arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_triangular_path(self, path: List[str]) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check if a triangular path is profitable\"\"\"\n        try:\n            token_a, token_b, token_c = path\n            start_amount = Decimal(\"1.0\")  # 1 unit of token_a\n            \n            # Get exchange rates for each step\n            rate_ab = await self._get_exchange_rate(token_a, token_b)\n            rate_bc = await self._get_exchange_rate(token_b, token_c)\n            rate_ca = await self._get_exchange_rate(token_c, token_a)\n            \n            if not all([rate_ab, rate_bc, rate_ca]):\n                return None\n            \n            # Calculate final amount after complete cycle\n            amount_b = start_amount * rate_ab * (1 - Decimal(\"0.0025\"))  # Subtract fee\n            amount_c = amount_b * rate_bc * (1 - Decimal(\"0.0025\"))     # Subtract fee\n            final_amount = amount_c * rate_ca * (1 - Decimal(\"0.0025\")) # Subtract fee\n            \n            profit = final_amount - start_amount\n            profit_percentage = (profit / start_amount) * 100\n            \n            if profit_percentage > Decimal(str(self.config.MIN_PROFIT_THRESHOLD)):\n                # Calculate profit in USD\n                token_a_price_usd = await self._get_token_price_usd(token_a)\n                profit_usd = profit * token_a_price_usd\n                \n                # Check if profit exceeds gas costs\n                gas_cost_usd = await self._estimate_triangular_gas_cost()\n                \n                if profit_usd > gas_cost_usd + Decimal(\"5\"):  # Minimum $5 net profit\n                    return ArbitrageOpportunity(\n                        id=f\"bsc_triangular_{token_a[:8]}_{datetime.now().timestamp()}\",\n                        type=\"triangular\",\n                        chain=\"bsc\",\n                        token_a=token_a,\n                        token_b=token_b,\n                        token_c=token_c,\n                        exchange_a=\"pancakeswap_v2\",\n                        price_a=rate_ab,\n                        price_b=rate_bc,\n                        price_c=rate_ca,\n                        price_difference=profit_percentage,\n                        profit_usd=profit_usd,\n                        gas_cost_usd=gas_cost_usd,\n                        amount_in=start_amount,\n                        amount_out=final_amount,\n                        amount_ab=amount_b,\n                        amount_bc=amount_c,\n                        total_liquidity_usd=await self._estimate_path_liquidity(path),\n                        price_impact=await self._estimate_triangular_price_impact(start_amount, path),\n                        timestamp=datetime.now()\n                    )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking triangular path: {e}\")\n            return None\n    \n    async def _get_exchange_rate(self, token_in: str, token_out: str) -> Optional[Decimal]:\n        \"\"\"Get exchange rate between two tokens\"\"\"\n        try:\n            # This would call the pair contract or quoter\n            # For now, return mock rates based on token types\n            if self._is_stablecoin(token_in) and self._is_stablecoin(token_out):\n                return Decimal(\"1.001\")  # Slight premium for stablecoin swaps\n            elif token_in == self.config.TOKENS[\"WBNB\"]:\n                if token_out == self.config.TOKENS[\"BUSD\"]:\n                    return Decimal(\"600.50\")  # Mock WBNB/BUSD rate\n                elif token_out == self.config.TOKENS[\"ETH\"]:\n                    return Decimal(\"0.18\")    # Mock WBNB/ETH rate\n                elif token_out == self.config.TOKENS[\"BTCB\"]:\n                    return Decimal(\"0.009\")   # Mock WBNB/BTCB rate\n                elif token_out == self.config.TOKENS[\"CAKE\"]:\n                    return Decimal(\"150.0\")   # Mock WBNB/CAKE rate\n            elif token_out == self.config.TOKENS[\"WBNB\"]:\n                # Inverse rates\n                rate = await self._get_exchange_rate(token_out, token_in)\n                return Decimal(\"1\") / rate if rate else None\n            \n            # Default fallback rate\n            return Decimal(\"1.0\")\n            \n        except Exception as e:\n            logger.debug(f\"Error getting exchange rate {token_in}/{token_out}: {e}\")\n            return None\n    \n    def _is_stablecoin(self, token: str) -> bool:\n        \"\"\"Check if token is a stablecoin\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"BUSD\"],\n            self.config.TOKENS[\"USDT\"],\n            self.config.TOKENS[\"USDC\"]\n        ]\n        return token in stablecoins\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        try:\n            # Mock USD prices\n            if token == self.config.TOKENS[\"WBNB\"]:\n                return Decimal(\"600.00\")\n            elif self._is_stablecoin(token):\n                return Decimal(\"1.00\")\n            elif token == self.config.TOKENS[\"ETH\"]:\n                return Decimal(\"3200.00\")\n            elif token == self.config.TOKENS[\"BTCB\"]:\n                return Decimal(\"65000.00\")\n            elif token == self.config.TOKENS[\"CAKE\"]:\n                return Decimal(\"4.50\")\n            else:\n                return Decimal(\"1.00\")  # Fallback\n                \n        except Exception:\n            return Decimal(\"1.00\")\n    \n    async def _estimate_triangular_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for triangular arbitrage\"\"\"\n        try:\n            # BSC gas cost for 3 swaps\n            gas_price_gwei = 5\n            gas_used = 300000  # Three swaps\n            \n            bnb_price_usd = Decimal(\"600\")\n            \n            gas_cost_bnb = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_bnb * bnb_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"3.0\")  # Fallback\n    \n    async def _estimate_path_liquidity(self, path: List[str]) -> Decimal:\n        \"\"\"Estimate liquidity for triangular path\"\"\"\n        # Mock liquidity estimation\n        return Decimal(\"50000\")  # $50K\n    \n    async def _estimate_triangular_price_impact(self, amount: Decimal, path: List[str]) -> float:\n        \"\"\"Estimate price impact for triangular arbitrage\"\"\"\n        # Simple price impact estimation\n        return 0.15  # 0.15%\n    \n    async def _execute_triangular_swaps(\n        self, \n        token_a: str, \n        token_b: str, \n        token_c: str, \n        start_amount: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute the three swaps for triangular arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing triangular swaps: {token_a} -> {token_b} -> {token_c} -> {token_a}\")\n            \n            # Mock execution for now\n            # This would build and execute actual multicall transaction\n            \n            # Simulate the three swaps\n            amount_after_first = start_amount * Decimal(\"0.997\")   # After fees\n            amount_after_second = amount_after_first * Decimal(\"0.997\")\n            final_amount = amount_after_second * Decimal(\"1.003\")  # Profitable final swap\n            \n            return {\n                \"success\": True,\n                \"final_amount\": final_amount,\n                \"token_price\": await self._get_token_price_usd(token_a),\n                \"total_gas_cost\": Decimal(\"3.0\"),\n                \"tx_hashes\": [\n                    f\"0x{'swap1' * 12}\",\n                    f\"0x{'swap2' * 12}\",\n                    f\"0x{'swap3' * 12}\"\n                ]\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"total_gas_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"triangular_paths\": len(self.triangular_paths),\n            \"primary_dex\": \"pancakeswap_v2\"\n        }","size_bytes":13210},"dex/ethereum_service/__init__.py":{"content":"# Ethereum microservice for DEX arbitrage","size_bytes":41},"dex/ethereum_service/abi_encoder.py":{"content":"import logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom web3 import Web3\nfrom eth_abi import encode\n\nlogger = logging.getLogger(__name__)\n\nclass SwapCallDataEncoder:\n    \"\"\"Encode real swap function calls for Uniswap V2/V3\"\"\"\n    \n    # Uniswap V2 Router function selectors\n    SWAP_EXACT_TOKENS_FOR_TOKENS = \"0x38ed1739\"  # swapExactTokensForTokens\n    SWAP_TOKENS_FOR_EXACT_TOKENS = \"0x8803dbee\"  # swapTokensForExactTokens\n    \n    # Uniswap V3 Router function selectors (corrected)\n    EXACT_INPUT_SINGLE = \"0x04e45aaf\"  # exactInputSingle - SwapRouter\n    EXACT_OUTPUT_SINGLE = \"0xf28c0498\"  # exactOutputSingle - SwapRouter\n    MULTICALL = \"0xac9650d8\"  # multicall(bytes[]) - SwapRouter02\n    \n    @staticmethod\n    def encode_v2_swap_exact_tokens_for_tokens(\n        amount_in: int,\n        amount_out_min: int, \n        path: List[str],\n        to: str,\n        deadline: int\n    ) -> str:\n        \"\"\"Encode Uniswap V2 swapExactTokensForTokens call\"\"\"\n        try:\n            # Function signature: swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\n            encoded_params = encode(\n                ['uint256', 'uint256', 'address[]', 'address', 'uint256'],\n                [amount_in, amount_out_min, path, to, deadline]\n            )\n            \n            return SwapCallDataEncoder.SWAP_EXACT_TOKENS_FOR_TOKENS + encoded_params.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error encoding V2 swap: {e}\")\n            return \"\"\n    \n    @staticmethod\n    def encode_v3_exact_input_single(\n        token_in: str,\n        token_out: str,\n        fee: int,\n        recipient: str,\n        deadline: int,\n        amount_in: int,\n        amount_out_minimum: int,\n        sqrt_price_limit_x96: int = 0\n    ) -> str:\n        \"\"\"Encode Uniswap V3 exactInputSingle call\"\"\"\n        try:\n            # ExactInputSingleParams struct encoding\n            params_tuple = (\n                token_in,\n                token_out, \n                fee,\n                recipient,\n                deadline,\n                amount_in,\n                amount_out_minimum,\n                sqrt_price_limit_x96\n            )\n            \n            encoded_params = encode(\n                ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],\n                [params_tuple]\n            )\n            \n            return SwapCallDataEncoder.EXACT_INPUT_SINGLE + encoded_params.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error encoding V3 swap: {e}\")\n            return \"\"\n    \n    @staticmethod\n    def encode_erc20_approve(spender: str, amount: int) -> str:\n        \"\"\"Encode ERC20 approve call\"\"\"\n        try:\n            # Function signature: approve(address,uint256)\n            function_selector = \"0x095ea7b3\"\n            encoded_params = encode(['address', 'uint256'], [spender, amount])\n            \n            return function_selector + encoded_params.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error encoding approve: {e}\")\n            return \"\"\n    \n    @staticmethod\n    def encode_multicall(calls: List[str]) -> str:\n        \"\"\"Encode multiple calls into a single multicall transaction (SwapRouter)\"\"\"\n        try:\n            # SwapRouter02 multicall function signature: multicall(bytes[])\n            function_selector = \"0xac9650d8\"\n            \n            # Convert hex strings to bytes\n            call_bytes = [bytes.fromhex(call[2:]) if call.startswith('0x') else bytes.fromhex(call) for call in calls]\n            \n            encoded_params = encode(['bytes[]'], [call_bytes])\n            \n            return function_selector + encoded_params.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error encoding multicall: {e}\")\n            return \"\"\n    \n    @staticmethod\n    def build_v2_swap_transaction(\n        router_address: str,\n        token_in: str,\n        token_out: str,\n        amount_in: Decimal,\n        amount_out_min: Decimal,\n        wallet_address: str,\n        token_in_decimals: int = 18,\n        token_out_decimals: int = 18,\n        deadline_offset: int = 1200\n    ) -> Dict[str, Any]:\n        \"\"\"Build complete V2 swap transaction with proper decimal handling\"\"\"\n        try:\n            import time\n            \n            # Convert to wei amounts with correct decimals\n            amount_in_wei = int(amount_in * Decimal(f\"1e{token_in_decimals}\"))\n            amount_out_min_wei = int(amount_out_min * Decimal(f\"1e{token_out_decimals}\"))\n            deadline = int(time.time()) + deadline_offset\n            \n            # Build path\n            path = [Web3.to_checksum_address(token_in), Web3.to_checksum_address(token_out)]\n            \n            # Encode call data\n            call_data = SwapCallDataEncoder.encode_v2_swap_exact_tokens_for_tokens(\n                amount_in_wei,\n                amount_out_min_wei,\n                path,\n                Web3.to_checksum_address(wallet_address),\n                deadline\n            )\n            \n            return {\n                \"to\": Web3.to_checksum_address(router_address),\n                \"value\": 0,\n                \"data\": call_data,\n                \"gas\": 150000  # Estimated gas\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error building V2 swap transaction: {e}\")\n            return {}\n    \n    @staticmethod\n    def build_v3_swap_transaction(\n        router_address: str,\n        token_in: str,\n        token_out: str,\n        fee_tier: int,\n        amount_in: Decimal,\n        amount_out_min: Decimal,\n        wallet_address: str,\n        token_in_decimals: int = 18,\n        token_out_decimals: int = 18,\n        deadline_offset: int = 1200\n    ) -> Dict[str, Any]:\n        \"\"\"Build complete V3 swap transaction with proper decimal handling\"\"\"\n        try:\n            import time\n            \n            # Convert to wei amounts with correct decimals\n            amount_in_wei = int(amount_in * Decimal(f\"1e{token_in_decimals}\"))\n            amount_out_min_wei = int(amount_out_min * Decimal(f\"1e{token_out_decimals}\"))\n            deadline = int(time.time()) + deadline_offset\n            \n            # Encode call data\n            call_data = SwapCallDataEncoder.encode_v3_exact_input_single(\n                Web3.to_checksum_address(token_in),\n                Web3.to_checksum_address(token_out),\n                fee_tier,\n                Web3.to_checksum_address(wallet_address),\n                deadline,\n                amount_in_wei,\n                amount_out_min_wei,\n                0  # No price limit\n            )\n            \n            return {\n                \"to\": Web3.to_checksum_address(router_address),\n                \"value\": 0,\n                \"data\": call_data,\n                \"gas\": 180000  # Estimated gas\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error building V3 swap transaction: {e}\")\n            return {}","size_bytes":7041},"dex/ethereum_service/arbitrage.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom datetime import datetime\n\nfrom .engine import EthereumEngine\nfrom .config import EthereumConfig\nfrom .cross_arbitrage import CrossArbitrageEngine\nfrom .triangular_arbitrage import TriangularArbitrageEngine\nfrom .flashloan_engine import FlashLoanEngine\nfrom .mempool_monitor import MempoolMonitor\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumArbitrageService:\n    \"\"\"Main Ethereum arbitrage service coordinating all arbitrage engines\"\"\"\n    \n    def __init__(self, config: EthereumConfig = None):\n        self.config = config or EthereumConfig()\n        self.chain = \"ethereum\"\n        self.chain_id = self.config.CHAIN_ID\n        \n        # Core engine\n        self.engine = EthereumEngine(self.config)\n        \n        # Arbitrage engines\n        self.cross_arbitrage = CrossArbitrageEngine(self.engine, self.config)\n        self.triangular_arbitrage = TriangularArbitrageEngine(self.engine, self.config)\n        self.flash_loan = FlashLoanEngine(self.engine, self.config)\n        self.mempool_monitor = MempoolMonitor(self.engine, self.config)\n        \n        self.is_initialized = False\n        self.last_health_check = datetime.now()\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize all components\"\"\"\n        try:\n            logger.info(\"Initializing Ethereum Arbitrage Service...\")\n            \n            # Initialize core engine\n            await self.engine.initialize()\n            \n            # Initialize arbitrage engines\n            await self.cross_arbitrage.initialize()\n            await self.triangular_arbitrage.initialize()\n            await self.flash_loan.initialize()\n            \n            # Initialize mempool monitor (if enabled)\n            if self.config.MEMPOOL_MONITOR_ENABLED:\n                await self.mempool_monitor.initialize()\n            \n            self.is_initialized = True\n            logger.info(\"Ethereum Arbitrage Service initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Ethereum Arbitrage Service: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for all types of arbitrage opportunities\"\"\"\n        if not self.is_initialized:\n            logger.warning(\"Service not initialized\")\n            return []\n        \n        try:\n            all_opportunities = []\n            \n            # Get cross-exchange opportunities\n            cross_ops = await self.cross_arbitrage.scan_opportunities()\n            all_opportunities.extend(cross_ops)\n            \n            # Get triangular arbitrage opportunities\n            triangular_ops = await self.triangular_arbitrage.scan_opportunities()\n            all_opportunities.extend(triangular_ops)\n            \n            # Get flash loan opportunities\n            flash_ops = await self.flash_loan.scan_opportunities()\n            all_opportunities.extend(flash_ops)\n            \n            logger.info(f\"Found {len(all_opportunities)} opportunities on Ethereum\")\n            return all_opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute a specific arbitrage opportunity\"\"\"\n        if not self.is_initialized:\n            raise RuntimeError(\"Service not initialized\")\n        \n        try:\n            logger.info(f\"Executing opportunity {opportunity.id} of type {opportunity.type}\")\n            \n            if opportunity.type == \"cross_exchange\":\n                return await self.cross_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"triangular\":\n                return await self.triangular_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"flash_loan\":\n                return await self.flash_loan.execute_opportunity(opportunity)\n            else:\n                raise ValueError(f\"Unknown opportunity type: {opportunity.type}\")\n                \n        except Exception as e:\n            logger.error(f\"Error executing opportunity {opportunity.id}: {e}\")\n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get service health status\"\"\"\n        try:\n            self.last_health_check = datetime.now()\n            \n            # Check engine health\n            engine_health = await self._check_engine_health()\n            \n            # Check component health\n            components_health = await self._check_components_health()\n            \n            overall_healthy = (\n                engine_health[\"status\"] == \"healthy\" and\n                all(comp[\"status\"] == \"healthy\" for comp in components_health.values())\n            )\n            \n            return {\n                \"status\": \"healthy\" if overall_healthy else \"degraded\",\n                \"timestamp\": self.last_health_check.isoformat(),\n                \"chain\": self.chain,\n                \"chain_id\": self.chain_id,\n                \"engine\": engine_health,\n                \"components\": components_health,\n                \"initialized\": self.is_initialized\n            }\n            \n        except Exception as e:\n            logger.error(f\"Health check failed: {e}\")\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": str(e),\n                \"timestamp\": datetime.now().isoformat()\n            }\n    \n    async def _check_engine_health(self) -> Dict[str, Any]:\n        \"\"\"Check core engine health\"\"\"\n        try:\n            if not self.engine or not self.engine.w3:\n                return {\"status\": \"unhealthy\", \"error\": \"Engine not initialized\"}\n            \n            # Test connection\n            is_connected = await self.engine.w3.is_connected()\n            if not is_connected:\n                return {\"status\": \"unhealthy\", \"error\": \"Web3 connection failed\"}\n            \n            # Test wallet\n            if self.engine.wallet_address:\n                balance = await self.engine.get_balance(\"0x0\")  # ETH balance\n                return {\n                    \"status\": \"healthy\",\n                    \"wallet_address\": self.engine.wallet_address,\n                    \"eth_balance\": str(balance)\n                }\n            else:\n                return {\"status\": \"degraded\", \"warning\": \"No wallet configured\"}\n                \n        except Exception as e:\n            return {\"status\": \"unhealthy\", \"error\": str(e)}\n    \n    async def _check_components_health(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Check arbitrage components health\"\"\"\n        components = {\n            \"cross_arbitrage\": self.cross_arbitrage,\n            \"triangular_arbitrage\": self.triangular_arbitrage,\n            \"flash_loan\": self.flash_loan,\n            \"mempool_monitor\": self.mempool_monitor\n        }\n        \n        health_status = {}\n        \n        for name, component in components.items():\n            try:\n                if hasattr(component, 'get_health_status'):\n                    health_status[name] = await component.get_health_status()\n                else:\n                    # Basic health check\n                    health_status[name] = {\n                        \"status\": \"healthy\" if hasattr(component, 'initialized') else \"unknown\",\n                        \"initialized\": getattr(component, 'initialized', False)\n                    }\n            except Exception as e:\n                health_status[name] = {\n                    \"status\": \"unhealthy\",\n                    \"error\": str(e)\n                }\n        \n        return health_status\n    \n    async def ping(self) -> bool:\n        \"\"\"Simple ping for heartbeat monitoring\"\"\"\n        try:\n            if not self.is_initialized:\n                return False\n            \n            # Quick Web3 connection test\n            if self.engine and self.engine.w3:\n                return await self.engine.w3.is_connected()\n            \n            return False\n            \n        except Exception:\n            return False\n    \n    async def shutdown(self) -> None:\n        \"\"\"Graceful shutdown\"\"\"\n        try:\n            logger.info(\"Shutting down Ethereum Arbitrage Service...\")\n            \n            # Shutdown components\n            if hasattr(self.mempool_monitor, 'shutdown'):\n                await self.mempool_monitor.shutdown()\n            \n            # Close engine connections\n            if self.engine:\n                if hasattr(self.engine, 'shutdown'):\n                    await self.engine.shutdown()\n            \n            self.is_initialized = False\n            logger.info(\"Ethereum Arbitrage Service shutdown complete\")\n            \n        except Exception as e:\n            logger.error(f\"Error during shutdown: {e}\")\n    \n    async def restart(self) -> None:\n        \"\"\"Restart the service\"\"\"\n        await self.shutdown()\n        await self.initialize()\n        logger.info(\"Ethereum Arbitrage Service restarted\")","size_bytes":9575},"dex/ethereum_service/config.py":{"content":"import os\nfrom typing import List, Dict\n\nclass EthereumConfig:\n    # Network Configuration\n    CHAIN_ID = int(os.getenv(\"ETH_CHAIN_ID\", \"11155111\"))  # 1=mainnet, 11155111=sepolia\n    RPC_URL = os.getenv(\"ETH_RPC_URL\", \"https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY\")\n    WSS_URL = os.getenv(\"ETH_WSS_URL\", \"wss://eth-mainnet.g.alchemy.com/v2/YOUR_KEY\")\n    \n    # Wallet Configuration\n    PRIVATE_KEY = os.getenv(\"ETH_PRIVATE_KEY\", \"\")\n    WALLET_ADDRESS = os.getenv(\"ETH_WALLET_ADDRESS\", \"\")\n    \n    # Gas Configuration\n    MAX_GAS_PRICE_GWEI = int(os.getenv(\"ETH_MAX_GAS_PRICE_GWEI\", \"50\"))\n    GAS_PRICE_MULTIPLIER = float(os.getenv(\"ETH_GAS_PRICE_MULTIPLIER\", \"1.1\"))\n    \n    # Trading Configuration\n    MIN_PROFIT_THRESHOLD = float(os.getenv(\"ETH_MIN_PROFIT_THRESHOLD\", \"0.5\"))  # %\n    MAX_SLIPPAGE = float(os.getenv(\"ETH_MAX_SLIPPAGE\", \"0.5\"))  # %\n    MAX_TRADE_SIZE_ETH = float(os.getenv(\"ETH_MAX_TRADE_SIZE\", \"10.0\"))\n    \n    # DEX Addresses\n    UNISWAP_V2_ROUTER = \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\"\n    UNISWAP_V2_FACTORY = \"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\"\n    UNISWAP_V3_ROUTER = \"0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45\"  # SwapRouter02 with multicall\n    UNISWAP_V3_FACTORY = \"0x1F98431c8aD98523631AE4a59f267346ea31F984\"\n    UNISWAP_V3_QUOTER_V2 = \"0x61fFE014bA17989E743c5F6cB21bF9697530B21e\"\n    \n    SUSHISWAP_ROUTER = \"0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\"\n    SUSHISWAP_FACTORY = \"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\"\n    \n    # Flash Loan Providers\n    AAVE_LENDING_POOL = \"0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9\"\n    DYDX_SOLO_MARGIN = \"0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e\"\n    \n    # Common Tokens (Mainnet addresses)\n    TOKENS = {\n        \"WETH\": \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n        \"USDC\": \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eb48\",  # Correct USDC mainnet address\n        \"USDT\": \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n        \"DAI\": \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n        \"WBTC\": \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\"\n    }\n    \n    # Mempool Configuration\n    MEMPOOL_MONITOR_ENABLED = os.getenv(\"ETH_MEMPOOL_MONITOR\", \"False\") == \"True\"\n    MIN_MEV_OPPORTUNITY_USD = float(os.getenv(\"ETH_MIN_MEV_OPPORTUNITY\", \"100.0\"))\n    \n    @classmethod\n    def validate(cls):\n        errors = []\n        if not cls.RPC_URL or \"YOUR_KEY\" in cls.RPC_URL:\n            errors.append(\"ETH_RPC_URL not properly configured\")\n        if not cls.PRIVATE_KEY:\n            errors.append(\"ETH_PRIVATE_KEY not set\")\n        if errors:\n            raise RuntimeError(f\"Ethereum config validation errors: {'; '.join(errors)}\")","size_bytes":2632},"dex/ethereum_service/cross_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageStrategy\nfrom models.arbitrage_models import ArbitrageOpportunity, DexPair, Token\n\nfrom .engine import EthereumEngine\nfrom .config import EthereumConfig\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumCrossArbitrage(BaseArbitrageStrategy):\n    \"\"\"Cross-DEX arbitrage between Uniswap, Sushiswap, 1inch, etc. on Ethereum\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.dex_adapters = {}  # Will be populated with V2/V3 adapters\n        self.price_cache = {}\n        self.last_update = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize DEX adapters and price feeds\"\"\"\n        logger.info(\"Initializing Ethereum cross-arbitrage engine...\")\n        # This would initialize V2/V3 protocol adapters\n        # For now, placeholder implementation\n        pass\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for cross-DEX arbitrage opportunities\"\"\"\n        opportunities = []\n        \n        try:\n            # Get token pairs to monitor\n            token_pairs = self._get_monitoring_pairs()\n            \n            for pair in token_pairs:\n                # Get prices from different DEXs\n                prices = await self._get_cross_dex_prices(pair)\n                \n                if len(prices) < 2:\n                    continue\n                \n                # Find arbitrage opportunities\n                opportunity = await self._analyze_price_differences(pair, prices)\n                if opportunity:\n                    opportunities.append(opportunity)\n                    \n        except Exception as e:\n            logger.error(f\"Error scanning cross-arbitrage opportunities: {e}\")\n        \n        return opportunities\n    \n    async def calculate_profit(self, opportunity: ArbitrageOpportunity) -> Decimal:\n        \"\"\"Calculate potential profit including gas costs\"\"\"\n        try:\n            if not opportunity.buy_price or not opportunity.sell_price:\n                return Decimal(\"0\")\n            \n            # Calculate gross profit\n            price_diff = opportunity.sell_price - opportunity.buy_price\n            gross_profit_pct = (price_diff / opportunity.buy_price) * 100\n            \n            # Estimate gas costs\n            gas_cost = await self._estimate_arbitrage_gas_cost()\n            \n            # Calculate net profit\n            trade_size_usd = Decimal(str(self.config.MAX_TRADE_SIZE_ETH)) * opportunity.buy_price\n            gross_profit_usd = trade_size_usd * (gross_profit_pct / 100)\n            net_profit_usd = gross_profit_usd - gas_cost\n            \n            return net_profit_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def execute_arbitrage(self, opportunity: ArbitrageOpportunity) -> Dict[str, Any]:\n        \"\"\"Execute cross-DEX arbitrage with flash loan\"\"\"\n        try:\n            logger.info(f\"Executing cross-arbitrage: {opportunity.opportunity_id}\")\n            \n            # This would:\n            # 1. Request flash loan\n            # 2. Buy on cheaper DEX\n            # 3. Sell on more expensive DEX \n            # 4. Repay flash loan\n            # 5. Keep profit\n            \n            # Placeholder implementation\n            return {\n                \"status\": \"success\",\n                \"tx_hash\": \"0x123...\",\n                \"profit_realized\": \"0.5\",\n                \"gas_used\": 300000\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing arbitrage: {e}\")\n            return {\n                \"status\": \"failed\",\n                \"error\": str(e)\n            }\n    \n    def _get_monitoring_pairs(self) -> List[tuple]:\n        \"\"\"Get token pairs to monitor for arbitrage\"\"\"\n        # Common trading pairs\n        return [\n            (\"WETH\", \"USDC\"),\n            (\"WETH\", \"USDT\"), \n            (\"WETH\", \"DAI\"),\n            (\"WBTC\", \"WETH\"),\n            (\"USDC\", \"USDT\")\n        ]\n    \n    async def _get_cross_dex_prices(self, pair: tuple) -> Dict[str, Decimal]:\n        \"\"\"Get prices from different DEXs for the same pair\"\"\"\n        prices = {}\n        \n        try:\n            # Placeholder - would call actual DEX adapters\n            # For now, return mock prices with small differences\n            base_price = Decimal(\"1800.0\")  # Mock ETH price\n            \n            prices[\"uniswap_v2\"] = base_price * Decimal(\"1.002\")  # 0.2% higher\n            prices[\"sushiswap\"] = base_price * Decimal(\"0.998\")   # 0.2% lower\n            prices[\"uniswap_v3\"] = base_price * Decimal(\"1.001\")  # 0.1% higher\n            \n        except Exception as e:\n            logger.error(f\"Error getting cross-DEX prices for {pair}: {e}\")\n        \n        return prices\n    \n    async def _analyze_price_differences(self, pair: tuple, prices: Dict[str, Decimal]) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Analyze price differences and create opportunity if profitable\"\"\"\n        try:\n            # Find min and max prices\n            dex_prices = list(prices.items())\n            dex_prices.sort(key=lambda x: x[1])  # Sort by price\n            \n            buy_dex, buy_price = dex_prices[0]   # Cheapest\n            sell_dex, sell_price = dex_prices[-1]  # Most expensive\n            \n            # Calculate profit percentage\n            profit_pct = ((sell_price - buy_price) / buy_price) * 100\n            \n            # Check if profitable after costs\n            if profit_pct < self.config.MIN_PROFIT_THRESHOLD:\n                return None\n            \n            # Create opportunity\n            return ArbitrageOpportunity(\n                opportunity_id=f\"cross_{pair[0]}_{pair[1]}_{int(datetime.now().timestamp())}\",\n                strategy_type=\"cross\",\n                chain=\"ethereum\",\n                profit_percentage=profit_pct,\n                profit_amount_usd=Decimal(\"0\"),  # Will be calculated later\n                gas_cost_usd=Decimal(\"0\"),      # Will be calculated later\n                net_profit_usd=Decimal(\"0\"),    # Will be calculated later\n                detected_at=datetime.now(),\n                buy_price=buy_price,\n                sell_price=sell_price\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing price differences: {e}\")\n            return None\n    \n    async def _estimate_arbitrage_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for arbitrage transaction\"\"\"\n        try:\n            # Rough estimate for flash loan + 2 swaps\n            estimated_gas = 400000\n            gas_price = await self.engine.get_gas_price()\n            \n            # Convert to USD (simplified - would need ETH price feed)\n            eth_price_usd = Decimal(\"1800\")  # Mock ETH price\n            gas_cost_eth = Decimal(str(estimated_gas * gas_price)) / Decimal(\"1e18\")\n            gas_cost_usd = gas_cost_eth * eth_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception as e:\n            logger.error(f\"Error estimating gas cost: {e}\")\n            return Decimal(\"50\")  # Default $50 estimate","size_bytes":7507},"dex/ethereum_service/engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional, Union\nfrom web3 import Web3, AsyncWeb3\nfrom web3.exceptions import Web3Exception\nfrom eth_account import Account\nfrom eth_utils import to_wei, from_wei\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseEngine\nfrom models.arbitrage_models import ExecutionResult\n\nfrom .config import EthereumConfig\nfrom .erc20_helper import ERC20Helper\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumEngine(BaseEngine):\n    \"\"\"Ethereum blockchain engine for Web3 operations\"\"\"\n    \n    def __init__(self, config: EthereumConfig):\n        self.config = config\n        self.w3: Optional[AsyncWeb3] = None\n        self.account: Optional[Account] = None\n        self.wallet_address: Optional[str] = None\n        self.erc20_helper: Optional[ERC20Helper] = None\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize Web3 connection and wallet\"\"\"\n        try:\n            # Initialize Web3 connection\n            self.w3 = AsyncWeb3(AsyncWeb3.AsyncHTTPProvider(self.config.RPC_URL))\n            \n            # Check connection\n            if not await self.w3.is_connected():\n                raise ConnectionError(\"Failed to connect to Ethereum RPC\")\n            \n            # Initialize wallet\n            if self.config.PRIVATE_KEY:\n                self.account = Account.from_key(self.config.PRIVATE_KEY)\n                self.wallet_address = self.account.address\n                self.erc20_helper = ERC20Helper(self.w3, self.wallet_address)\n                logger.info(f\"Wallet initialized: {self.wallet_address}\")\n            \n            # Verify network\n            chain_id = await self.w3.eth.chain_id\n            if chain_id != self.config.CHAIN_ID:\n                logger.warning(f\"Chain ID mismatch: expected {self.config.CHAIN_ID}, got {chain_id}\")\n            \n            logger.info(f\"Ethereum engine initialized on chain {chain_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Ethereum engine: {e}\")\n            raise\n    \n    async def get_balance(self, token_address: str, wallet_address: str = None) -> Decimal:\n        \"\"\"Get token balance for wallet\"\"\"\n        try:\n            target_wallet = wallet_address or self.wallet_address\n            if not target_wallet:\n                raise ValueError(\"No wallet address provided\")\n            \n            if self.erc20_helper:\n                return await self.erc20_helper.get_balance(token_address)\n            else:\n                # Fallback for ETH only\n                if token_address.lower() == \"0x0\" or token_address.upper() == \"ETH\":\n                    balance_wei = await self.w3.eth.get_balance(target_wallet)\n                    return Decimal(from_wei(balance_wei, 'ether'))\n                else:\n                    logger.warning(\"ERC20Helper not initialized, cannot get token balance\")\n                    return Decimal(\"0\")\n        except Exception as e:\n            logger.error(f\"Error getting balance for {token_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_gas_price(self) -> Dict[str, int]:\n        \"\"\"Get current gas price using EIP-1559 or legacy\"\"\"\n        try:\n            # Try to get EIP-1559 gas price\n            try:\n                latest_block = await self.w3.eth.get_block('latest')\n                if hasattr(latest_block, 'baseFeePerGas') and latest_block.baseFeePerGas:\n                    # EIP-1559 transaction\n                    base_fee = latest_block.baseFeePerGas\n                    max_priority_fee = to_wei(2, 'gwei')  # 2 gwei tip\n                    max_fee = int(base_fee * 2 + max_priority_fee)  # 2x base fee + tip\n                    \n                    # Cap at max gas price\n                    max_cap = to_wei(self.config.MAX_GAS_PRICE_GWEI, 'gwei')\n                    max_fee = min(max_fee, max_cap)\n                    \n                    return {\n                        \"maxFeePerGas\": max_fee,\n                        \"maxPriorityFeePerGas\": max_priority_fee,\n                        \"type\": \"eip1559\"\n                    }\n            except Exception as eip_error:\n                logger.debug(f\"EIP-1559 not available: {eip_error}\")\n            \n            # Fallback to legacy gas price\n            gas_price = await self.w3.eth.gas_price\n            adjusted_price = int(gas_price * self.config.GAS_PRICE_MULTIPLIER)\n            \n            # Cap at max gas price\n            max_price = to_wei(self.config.MAX_GAS_PRICE_GWEI, 'gwei')\n            return {\n                \"gasPrice\": min(adjusted_price, max_price),\n                \"type\": \"legacy\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting gas price: {e}\")\n            return {\n                \"gasPrice\": to_wei(20, 'gwei'),\n                \"type\": \"legacy\"\n            }\n    \n    async def execute_transaction(self, tx_data: Dict[str, Any]) -> str:\n        \"\"\"Execute transaction and return tx hash\"\"\"\n        try:\n            if not self.account:\n                raise ValueError(\"Wallet not initialized\")\n            \n            # Get gas pricing\n            gas_config = await self.get_gas_price()\n            \n            # Build transaction\n            transaction = {\n                'from': self.wallet_address,\n                'gas': tx_data.get('gas', 200000),\n                'nonce': await self.w3.eth.get_transaction_count(self.wallet_address),\n                **tx_data\n            }\n            \n            # Add gas pricing based on type\n            if gas_config[\"type\"] == \"eip1559\":\n                transaction.update({\n                    'maxFeePerGas': gas_config[\"maxFeePerGas\"],\n                    'maxPriorityFeePerGas': gas_config[\"maxPriorityFeePerGas\"],\n                    'type': 2  # EIP-1559 transaction type\n                })\n            else:\n                transaction['gasPrice'] = gas_config[\"gasPrice\"]\n            \n            # Estimate gas if not provided\n            if 'gas' not in tx_data:\n                try:\n                    estimated_gas = await self.w3.eth.estimate_gas(transaction)\n                    transaction['gas'] = int(estimated_gas * 1.2)  # Add 20% buffer\n                except Exception as gas_error:\n                    logger.warning(f\"Gas estimation failed: {gas_error}\")\n                    transaction['gas'] = 200000  # Fallback\n            \n            # Sign transaction\n            signed_txn = self.account.sign_transaction(transaction)\n            \n            # Send transaction\n            tx_hash = await self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)\n            \n            logger.info(f\"Transaction sent: {tx_hash.hex()}\")\n            return tx_hash.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error executing transaction: {e}\")\n            raise\n    \n    async def get_block_number(self) -> int:\n        \"\"\"Get latest block number\"\"\"\n        return await self.w3.eth.block_number\n    \n    async def estimate_gas(self, tx_data: Dict[str, Any]) -> int:\n        \"\"\"Estimate gas for transaction\"\"\"\n        try:\n            return await self.w3.eth.estimate_gas(tx_data)\n        except Exception as e:\n            logger.error(f\"Error estimating gas: {e}\")\n            return 200000  # Default gas limit\n    \n    async def wait_for_transaction(self, tx_hash: str, timeout: int = 120) -> ExecutionResult:\n        \"\"\"Wait for transaction confirmation\"\"\"\n        try:\n            receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=timeout)\n            \n            return ExecutionResult(\n                tx_hash=tx_hash,\n                status=\"success\" if receipt.status == 1 else \"failed\",\n                gas_used=receipt.gasUsed,\n                gas_price=receipt.effectiveGasPrice\n            )\n        except Exception as e:\n            logger.error(f\"Error waiting for transaction {tx_hash}: {e}\")\n            return ExecutionResult(\n                tx_hash=tx_hash,\n                status=\"failed\",\n                gas_used=0,\n                gas_price=0,\n                error_message=str(e)\n            )","size_bytes":8304},"dex/ethereum_service/erc20_helper.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional\nfrom web3 import Web3\nfrom eth_abi import encode, decode\n\nlogger = logging.getLogger(__name__)\n\nclass ERC20Helper:\n    \"\"\"Helper class for ERC20 token operations\"\"\"\n    \n    # Standard ERC20 ABI (minimal)\n    ERC20_ABI = [\n        {\n            \"constant\": True,\n            \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n            \"name\": \"balanceOf\",\n            \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": True,\n            \"inputs\": [\n                {\"name\": \"_owner\", \"type\": \"address\"},\n                {\"name\": \"_spender\", \"type\": \"address\"}\n            ],\n            \"name\": \"allowance\", \n            \"outputs\": [{\"name\": \"remaining\", \"type\": \"uint256\"}],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": False,\n            \"inputs\": [\n                {\"name\": \"_spender\", \"type\": \"address\"},\n                {\"name\": \"_value\", \"type\": \"uint256\"}\n            ],\n            \"name\": \"approve\",\n            \"outputs\": [{\"name\": \"success\", \"type\": \"bool\"}],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": True,\n            \"inputs\": [],\n            \"name\": \"decimals\",\n            \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": True,\n            \"inputs\": [],\n            \"name\": \"symbol\",\n            \"outputs\": [{\"name\": \"\", \"type\": \"string\"}],\n            \"type\": \"function\"\n        }\n    ]\n    \n    def __init__(self, w3, wallet_address: str):\n        self.w3 = w3\n        self.wallet_address = wallet_address\n        \n    async def get_balance(self, token_address: str) -> Decimal:\n        \"\"\"Get ERC20 token balance\"\"\"\n        try:\n            if token_address.lower() == \"0x0\" or token_address.upper() == \"ETH\":\n                # Native ETH balance\n                balance_wei = await self.w3.eth.get_balance(self.wallet_address)\n                return Decimal(str(balance_wei)) / Decimal(\"1e18\")\n            \n            # Get token contract\n            contract = self.w3.eth.contract(\n                address=Web3.to_checksum_address(token_address),\n                abi=self.ERC20_ABI\n            )\n            \n            # Get balance\n            balance = await contract.functions.balanceOf(self.wallet_address).call()\n            \n            # Get decimals\n            decimals = await contract.functions.decimals().call()\n            \n            # Convert to decimal with proper scaling\n            return Decimal(str(balance)) / Decimal(f\"1e{decimals}\")\n            \n        except Exception as e:\n            logger.error(f\"Error getting ERC20 balance for {token_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_allowance(self, token_address: str, spender_address: str) -> Decimal:\n        \"\"\"Get ERC20 allowance for spender\"\"\"\n        try:\n            contract = self.w3.eth.contract(\n                address=Web3.to_checksum_address(token_address),\n                abi=self.ERC20_ABI\n            )\n            \n            allowance = await contract.functions.allowance(\n                self.wallet_address,\n                spender_address\n            ).call()\n            \n            # Get decimals for proper scaling\n            decimals = await contract.functions.decimals().call()\n            \n            return Decimal(str(allowance)) / Decimal(f\"1e{decimals}\")\n            \n        except Exception as e:\n            logger.error(f\"Error getting allowance: {e}\")\n            return Decimal(\"0\")\n    \n    async def build_approve_transaction(self, token_address: str, spender_address: str, amount: Decimal) -> Dict[str, Any]:\n        \"\"\"Build approve transaction data\"\"\"\n        try:\n            contract = self.w3.eth.contract(\n                address=Web3.to_checksum_address(token_address),\n                abi=self.ERC20_ABI\n            )\n            \n            # Get decimals\n            decimals = await contract.functions.decimals().call()\n            \n            # Convert amount to wei\n            amount_wei = int(amount * Decimal(f\"1e{decimals}\"))\n            \n            # Build transaction\n            transaction = contract.functions.approve(\n                spender_address,\n                amount_wei\n            ).build_transaction({\n                'from': self.wallet_address,\n                'gas': 60000,  # Standard approve gas\n                'gasPrice': 0,  # Will be set by engine\n                'nonce': 0      # Will be set by engine\n            })\n            \n            return transaction\n            \n        except Exception as e:\n            logger.error(f\"Error building approve transaction: {e}\")\n            return {}\n    \n    async def get_token_info(self, token_address: str) -> Dict[str, Any]:\n        \"\"\"Get basic token information\"\"\"\n        try:\n            contract = self.w3.eth.contract(\n                address=Web3.to_checksum_address(token_address),\n                abi=self.ERC20_ABI\n            )\n            \n            symbol = await contract.functions.symbol().call()\n            decimals = await contract.functions.decimals().call()\n            \n            return {\n                \"address\": token_address,\n                \"symbol\": symbol,\n                \"decimals\": decimals\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting token info: {e}\")\n            return {}\n    \n    def encode_transfer_data(self, to_address: str, amount: int) -> str:\n        \"\"\"Encode transfer function call data\"\"\"\n        try:\n            # transfer(address,uint256) function selector\n            function_selector = \"0xa9059cbb\"\n            \n            # Encode parameters\n            encoded_params = encode(['address', 'uint256'], [to_address, amount])\n            \n            return function_selector + encoded_params.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error encoding transfer data: {e}\")\n            return \"\"","size_bytes":6125},"dex/ethereum_service/flashloan_engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import FlashLoanParams, ExecutionResult\n\nfrom .engine import EthereumEngine\nfrom .config import EthereumConfig\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumFlashLoanEngine:\n    \"\"\"Flash loan engine for Ethereum (Aave, dYdX, Balancer)\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.providers = {\n            \"aave\": {\n                \"address\": config.AAVE_LENDING_POOL,\n                \"fee_percentage\": Decimal(\"0.0009\")  # 0.09%\n            },\n            \"dydx\": {\n                \"address\": config.DYDX_SOLO_MARGIN,\n                \"fee_percentage\": Decimal(\"0.0002\")  # 0.02%\n            }\n        }\n        \n    async def initialize(self):\n        \"\"\"Initialize flash loan contracts\"\"\"\n        logger.info(\"Initializing Ethereum flash loan engine...\")\n        # This would load contract ABIs and interfaces\n        pass\n    \n    async def get_available_liquidity(self, token_address: str, provider: str = \"aave\") -> Decimal:\n        \"\"\"Get available liquidity for flash loans\"\"\"\n        try:\n            if provider not in self.providers:\n                raise ValueError(f\"Unknown provider: {provider}\")\n            \n            # This would query the actual protocol for available liquidity\n            # For now, return mock values\n            mock_liquidity = {\n                self.config.TOKENS[\"WETH\"]: Decimal(\"10000\"),    # 10K ETH\n                self.config.TOKENS[\"USDC\"]: Decimal(\"50000000\"), # 50M USDC\n                self.config.TOKENS[\"DAI\"]: Decimal(\"30000000\"),  # 30M DAI\n                self.config.TOKENS[\"USDT\"]: Decimal(\"40000000\")  # 40M USDT\n            }\n            \n            return mock_liquidity.get(token_address, Decimal(\"0\"))\n            \n        except Exception as e:\n            logger.error(f\"Error getting available liquidity: {e}\")\n            return Decimal(\"0\")\n    \n    async def calculate_flash_loan_fee(self, amount: Decimal, token: str, provider: str = \"aave\") -> Decimal:\n        \"\"\"Calculate flash loan fee\"\"\"\n        try:\n            provider_info = self.providers.get(provider)\n            if not provider_info:\n                raise ValueError(f\"Unknown provider: {provider}\")\n            \n            fee = amount * provider_info[\"fee_percentage\"]\n            return fee\n            \n        except Exception as e:\n            logger.error(f\"Error calculating flash loan fee: {e}\")\n            return Decimal(\"0\")\n    \n    async def execute_flash_loan(self, params: FlashLoanParams) -> ExecutionResult:\n        \"\"\"Execute flash loan with callback\"\"\"\n        try:\n            logger.info(f\"Executing flash loan: {params.amount} {params.asset} via {params.provider}\")\n            \n            # Check liquidity\n            available = await self.get_available_liquidity(params.asset, params.provider)\n            if available < params.amount:\n                raise ValueError(\"Insufficient liquidity for flash loan\")\n            \n            # Calculate fee\n            fee = await self.calculate_flash_loan_fee(params.amount, params.asset, params.provider)\n            \n            # Build flash loan transaction\n            tx_data = await self._build_flash_loan_transaction(params, fee)\n            \n            # Execute transaction\n            tx_hash = await self.engine.execute_transaction(tx_data)\n            \n            # Wait for confirmation\n            result = await self.engine.wait_for_transaction(tx_hash)\n            \n            logger.info(f\"Flash loan executed successfully: {tx_hash}\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error executing flash loan: {e}\")\n            return ExecutionResult(\n                tx_hash=\"\",\n                status=\"failed\",\n                gas_used=0,\n                gas_price=0,\n                error_message=str(e)\n            )\n    \n    async def _build_flash_loan_transaction(self, params: FlashLoanParams, fee: Decimal) -> Dict[str, Any]:\n        \"\"\"Build flash loan transaction data\"\"\"\n        try:\n            if params.provider == \"aave\":\n                return await self._build_aave_flash_loan(params, fee)\n            elif params.provider == \"dydx\":\n                return await self._build_dydx_flash_loan(params, fee)\n            else:\n                raise ValueError(f\"Unsupported provider: {params.provider}\")\n                \n        except Exception as e:\n            logger.error(f\"Error building flash loan transaction: {e}\")\n            raise\n    \n    async def _build_aave_flash_loan(self, params: FlashLoanParams, fee: Decimal) -> Dict[str, Any]:\n        \"\"\"Build Aave flash loan transaction\"\"\"\n        # This would encode the actual Aave flash loan function call\n        # For now, return a simplified transaction structure\n        \n        return {\n            \"to\": self.providers[\"aave\"][\"address\"],\n            \"value\": 0,\n            \"gas\": 500000,\n            \"data\": \"0x...\" # Encoded function call with params\n        }\n    \n    async def _build_dydx_flash_loan(self, params: FlashLoanParams, fee: Decimal) -> Dict[str, Any]:\n        \"\"\"Build dYdX flash loan transaction\"\"\"\n        # This would encode the actual dYdX solo margin operation\n        # For now, return a simplified transaction structure\n        \n        return {\n            \"to\": self.providers[\"dydx\"][\"address\"],\n            \"value\": 0,\n            \"gas\": 400000,\n            \"data\": \"0x...\" # Encoded operation with params\n        }\n    \n    async def get_best_provider(self, token: str, amount: Decimal) -> str:\n        \"\"\"Get the best flash loan provider for given token and amount\"\"\"\n        try:\n            best_provider = \"aave\"\n            lowest_fee = Decimal(\"999999\")\n            \n            for provider_name in self.providers:\n                # Check liquidity\n                liquidity = await self.get_available_liquidity(token, provider_name)\n                if liquidity < amount:\n                    continue\n                \n                # Calculate fee\n                fee = await self.calculate_flash_loan_fee(amount, token, provider_name)\n                \n                if fee < lowest_fee:\n                    lowest_fee = fee\n                    best_provider = provider_name\n            \n            logger.info(f\"Best flash loan provider for {amount} {token}: {best_provider} (fee: {lowest_fee})\")\n            return best_provider\n            \n        except Exception as e:\n            logger.error(f\"Error finding best provider: {e}\")\n            return \"aave\"  # Default to Aave\n    \n    async def estimate_gas_cost(self, params: FlashLoanParams) -> int:\n        \"\"\"Estimate gas cost for flash loan execution\"\"\"\n        try:\n            # Base gas cost varies by provider and callback complexity\n            base_costs = {\n                \"aave\": 300000,\n                \"dydx\": 250000\n            }\n            \n            base_cost = base_costs.get(params.provider, 300000)\n            \n            # Add callback complexity cost\n            callback_complexity = len(params.callback_data.get(\"operations\", []))\n            callback_cost = callback_complexity * 50000\n            \n            total_gas = base_cost + callback_cost\n            \n            return min(total_gas, 800000)  # Cap at 800k gas\n            \n        except Exception as e:\n            logger.error(f\"Error estimating gas cost: {e}\")\n            return 500000  # Default estimate","size_bytes":7731},"dex/ethereum_service/mempool_monitor.py":{"content":"import asyncio\nimport logging\nimport json\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Callable\nfrom datetime import datetime\nimport websockets\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity\n\nfrom .engine import EthereumEngine\nfrom .config import EthereumConfig\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumMempoolMonitor:\n    \"\"\"Monitor Ethereum mempool for MEV/backrun opportunities\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.websocket = None\n        self.is_monitoring = False\n        self.pending_txs = {}\n        self.opportunity_callbacks: List[Callable] = []\n        \n    async def initialize(self):\n        \"\"\"Initialize mempool monitoring\"\"\"\n        if not self.config.MEMPOOL_MONITOR_ENABLED:\n            logger.info(\"Mempool monitoring disabled\")\n            return\n            \n        logger.info(\"Initializing Ethereum mempool monitor...\")\n        await self._connect_websocket()\n        \n    async def start_monitoring(self):\n        \"\"\"Start monitoring mempool for opportunities\"\"\"\n        if not self.config.MEMPOOL_MONITOR_ENABLED:\n            return\n            \n        self.is_monitoring = True\n        logger.info(\"Starting mempool monitoring...\")\n        \n        try:\n            await self._monitor_pending_transactions()\n        except Exception as e:\n            logger.error(f\"Error in mempool monitoring: {e}\")\n            self.is_monitoring = False\n    \n    async def stop_monitoring(self):\n        \"\"\"Stop mempool monitoring\"\"\"\n        self.is_monitoring = False\n        if self.websocket:\n            await self.websocket.close()\n        logger.info(\"Mempool monitoring stopped\")\n    \n    def add_opportunity_callback(self, callback: Callable):\n        \"\"\"Add callback for when opportunities are found\"\"\"\n        self.opportunity_callbacks.append(callback)\n    \n    async def _connect_websocket(self):\n        \"\"\"Connect to WebSocket for real-time mempool data\"\"\"\n        try:\n            if not self.config.WSS_URL or \"YOUR_KEY\" in self.config.WSS_URL:\n                logger.warning(\"WebSocket URL not configured for mempool monitoring\")\n                return\n                \n            self.websocket = await websockets.connect(self.config.WSS_URL)\n            \n            # Subscribe to pending transactions\n            subscription = {\n                \"id\": 1,\n                \"method\": \"eth_subscribe\",\n                \"params\": [\"newPendingTransactions\"]\n            }\n            await self.websocket.send(json.dumps(subscription))\n            \n            response = await self.websocket.recv()\n            logger.info(f\"Mempool subscription response: {response}\")\n            \n        except Exception as e:\n            logger.error(f\"Error connecting to mempool WebSocket: {e}\")\n    \n    async def _monitor_pending_transactions(self):\n        \"\"\"Monitor pending transactions for arbitrage opportunities\"\"\"\n        try:\n            while self.is_monitoring and self.websocket:\n                message = await self.websocket.recv()\n                data = json.loads(message)\n                \n                if \"params\" in data:\n                    tx_hash = data[\"params\"][\"result\"]\n                    await self._analyze_pending_transaction(tx_hash)\n                    \n        except Exception as e:\n            logger.error(f\"Error monitoring pending transactions: {e}\")\n    \n    async def _analyze_pending_transaction(self, tx_hash: str):\n        \"\"\"Analyze a pending transaction for backrun opportunities\"\"\"\n        try:\n            # Get transaction details\n            tx_data = await self._get_transaction_data(tx_hash)\n            if not tx_data:\n                return\n            \n            # Check if it's a DEX transaction\n            if not self._is_dex_transaction(tx_data):\n                return\n            \n            # Analyze for sandwich/backrun opportunity\n            opportunity = await self._detect_mev_opportunity(tx_data)\n            if opportunity:\n                logger.info(f\"MEV opportunity detected: {opportunity.opportunity_id}\")\n                \n                # Notify callbacks\n                for callback in self.opportunity_callbacks:\n                    try:\n                        await callback(opportunity)\n                    except Exception as e:\n                        logger.error(f\"Error in opportunity callback: {e}\")\n                        \n        except Exception as e:\n            logger.error(f\"Error analyzing pending transaction {tx_hash}: {e}\")\n    \n    async def _get_transaction_data(self, tx_hash: str) -> Optional[Dict]:\n        \"\"\"Get transaction data from mempool\"\"\"\n        try:\n            # In production, this would get full transaction details\n            # For now, return mock data\n            return {\n                \"hash\": tx_hash,\n                \"to\": self.config.UNISWAP_V2_ROUTER,\n                \"value\": \"1000000000000000000\",  # 1 ETH\n                \"gasPrice\": \"20000000000\",       # 20 gwei\n                \"data\": \"0x7ff36ab5...\"         # Swap function call\n            }\n        except Exception as e:\n            logger.error(f\"Error getting transaction data for {tx_hash}: {e}\")\n            return None\n    \n    def _is_dex_transaction(self, tx_data: Dict) -> bool:\n        \"\"\"Check if transaction is a DEX swap\"\"\"\n        dex_addresses = {\n            self.config.UNISWAP_V2_ROUTER.lower(),\n            self.config.UNISWAP_V3_ROUTER.lower(),\n            self.config.SUSHISWAP_ROUTER.lower()\n        }\n        \n        to_address = tx_data.get(\"to\", \"\").lower()\n        return to_address in dex_addresses\n    \n    async def _detect_mev_opportunity(self, tx_data: Dict) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Detect MEV/backrun opportunity from transaction\"\"\"\n        try:\n            # Analyze the transaction for potential price impact\n            estimated_impact = await self._estimate_price_impact(tx_data)\n            \n            if estimated_impact < self.config.MIN_MEV_OPPORTUNITY_USD:\n                return None\n            \n            # Create MEV opportunity\n            return ArbitrageOpportunity(\n                opportunity_id=f\"mempool_{tx_data['hash']}_{int(datetime.now().timestamp())}\",\n                strategy_type=\"mempool_backrun\",\n                chain=\"ethereum\",\n                profit_percentage=Decimal(\"0.5\"),  # Estimated\n                profit_amount_usd=estimated_impact,\n                gas_cost_usd=Decimal(\"30\"),       # Estimated gas cost\n                net_profit_usd=estimated_impact - Decimal(\"30\"),\n                detected_at=datetime.now(),\n                target_tx_hash=tx_data[\"hash\"],\n                backrun_strategy=\"price_impact_arbitrage\"\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error detecting MEV opportunity: {e}\")\n            return None\n    \n    async def _estimate_price_impact(self, tx_data: Dict) -> Decimal:\n        \"\"\"Estimate price impact of the transaction\"\"\"\n        try:\n            # Simplified price impact calculation\n            # In production, this would decode the transaction data\n            # and calculate actual price impact based on pool reserves\n            \n            value_eth = int(tx_data.get(\"value\", \"0\")) / 1e18\n            \n            # Rough estimate: larger trades = more impact\n            if value_eth > 10:\n                return Decimal(\"200\")  # $200 opportunity\n            elif value_eth > 1:\n                return Decimal(\"50\")   # $50 opportunity\n            else:\n                return Decimal(\"10\")   # $10 opportunity\n                \n        except Exception as e:\n            logger.error(f\"Error estimating price impact: {e}\")\n            return Decimal(\"0\")\n    \n    async def execute_backrun(self, opportunity: ArbitrageOpportunity) -> Dict[str, Any]:\n        \"\"\"Execute a backrun strategy\"\"\"\n        try:\n            logger.info(f\"Executing backrun for: {opportunity.target_tx_hash}\")\n            \n            # This would:\n            # 1. Wait for target transaction to be included\n            # 2. Submit backrun transaction with higher gas price\n            # 3. Capture the price impact/arbitrage\n            \n            # Placeholder implementation\n            return {\n                \"status\": \"success\",\n                \"tx_hash\": \"0x789...\",\n                \"profit_realized\": str(opportunity.profit_amount_usd),\n                \"gas_used\": 180000\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing backrun: {e}\")\n            return {\n                \"status\": \"failed\",\n                \"error\": str(e)\n            }","size_bytes":8870},"dex/ethereum_service/quoter_helper.py":{"content":"import logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional\nfrom web3 import Web3\n\nlogger = logging.getLogger(__name__)\n\nclass UniswapV3QuoterHelper:\n    \"\"\"Helper for Uniswap V3 Quoter contract integration\"\"\"\n    \n    # Quoter V2 ABI (minimal)\n    QUOTER_V2_ABI = [\n        {\n            \"inputs\": [\n                {\"name\": \"tokenIn\", \"type\": \"address\"},\n                {\"name\": \"tokenOut\", \"type\": \"address\"},\n                {\"name\": \"fee\", \"type\": \"uint24\"},\n                {\"name\": \"amountIn\", \"type\": \"uint256\"},\n                {\"name\": \"sqrtPriceLimitX96\", \"type\": \"uint160\"}\n            ],\n            \"name\": \"quoteExactInputSingle\",\n            \"outputs\": [\n                {\"name\": \"amountOut\", \"type\": \"uint256\"},\n                {\"name\": \"sqrtPriceX96After\", \"type\": \"uint160\"},\n                {\"name\": \"initializedTicksCrossed\", \"type\": \"uint32\"},\n                {\"name\": \"gasEstimate\", \"type\": \"uint256\"}\n            ],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [\n                {\"name\": \"tokenIn\", \"type\": \"address\"},\n                {\"name\": \"tokenOut\", \"type\": \"address\"},\n                {\"name\": \"fee\", \"type\": \"uint24\"},\n                {\"name\": \"amountOut\", \"type\": \"uint256\"},\n                {\"name\": \"sqrtPriceLimitX96\", \"type\": \"uint160\"}\n            ],\n            \"name\": \"quoteExactOutputSingle\", \n            \"outputs\": [\n                {\"name\": \"amountIn\", \"type\": \"uint256\"},\n                {\"name\": \"sqrtPriceX96After\", \"type\": \"uint160\"},\n                {\"name\": \"initializedTicksCrossed\", \"type\": \"uint32\"},\n                {\"name\": \"gasEstimate\", \"type\": \"uint256\"}\n            ],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        }\n    ]\n    \n    def __init__(self, w3, quoter_address: str):\n        self.w3 = w3\n        self.quoter_address = quoter_address\n        \n        # Initialize quoter contract (async compatible)\n        self.quoter = w3.eth.contract(\n            address=Web3.to_checksum_address(quoter_address),\n            abi=self.QUOTER_V2_ABI\n        )\n    \n    async def quote_exact_input_single(\n        self,\n        token_in: str,\n        token_out: str,\n        fee: int,\n        amount_in: int,\n        sqrt_price_limit_x96: int = 0\n    ) -> Optional[Dict[str, int]]:\n        \"\"\"Get exact input quote from Quoter V2\"\"\"\n        try:\n            result = await self.quoter.functions.quoteExactInputSingle(\n                Web3.to_checksum_address(token_in),\n                Web3.to_checksum_address(token_out),\n                fee,\n                amount_in,\n                sqrt_price_limit_x96\n            ).call()\n            \n            amount_out, sqrt_price_x96_after, ticks_crossed, gas_estimate = result\n            \n            return {\n                \"amountOut\": amount_out,\n                \"sqrtPriceX96After\": sqrt_price_x96_after,\n                \"initializedTicksCrossed\": ticks_crossed,\n                \"gasEstimate\": gas_estimate\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 quote: {e}\")\n            return None\n    \n    async def quote_exact_output_single(\n        self,\n        token_in: str,\n        token_out: str,\n        fee: int,\n        amount_out: int,\n        sqrt_price_limit_x96: int = 0\n    ) -> Optional[Dict[str, int]]:\n        \"\"\"Get exact output quote from Quoter V2\"\"\"\n        try:\n            result = await self.quoter.functions.quoteExactOutputSingle(\n                Web3.to_checksum_address(token_in),\n                Web3.to_checksum_address(token_out),\n                fee,\n                amount_out,\n                sqrt_price_limit_x96\n            ).call()\n            \n            amount_in, sqrt_price_x96_after, ticks_crossed, gas_estimate = result\n            \n            return {\n                \"amountIn\": amount_in,\n                \"sqrtPriceX96After\": sqrt_price_x96_after,\n                \"initializedTicksCrossed\": ticks_crossed,\n                \"gasEstimate\": gas_estimate\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 output quote: {e}\")\n            return None\n    \n    async def get_optimal_amount_out(\n        self,\n        token_in: str,\n        token_out: str,\n        amount_in: Decimal,\n        token_in_decimals: int,\n        token_out_decimals: int,\n        fee_tier: int = 3000\n    ) -> Decimal:\n        \"\"\"Get accurate amount out using Quoter with proper decimal handling\"\"\"\n        try:\n            # Convert to wei with proper decimals\n            amount_in_wei = int(amount_in * Decimal(f\"1e{token_in_decimals}\"))\n            \n            # Get quote from quoter\n            quote_result = await self.quote_exact_input_single(\n                token_in,\n                token_out,\n                fee_tier,\n                amount_in_wei\n            )\n            \n            if not quote_result:\n                return Decimal(\"0\")\n            \n            # Convert back to decimal units\n            amount_out_wei = quote_result[\"amountOut\"]\n            amount_out = Decimal(str(amount_out_wei)) / Decimal(f\"1e{token_out_decimals}\")\n            \n            return amount_out\n            \n        except Exception as e:\n            logger.error(f\"Error getting optimal amount out: {e}\")\n            return Decimal(\"0\")","size_bytes":5408},"dex/ethereum_service/service.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .config import EthereumConfig\nfrom .engine import EthereumEngine\nfrom .cross_arbitrage import EthereumCrossArbitrage\nfrom .triangular_arbitrage import EthereumTriangularArbitrage\nfrom .mempool_monitor import EthereumMempoolMonitor\nfrom .flashloan_engine import EthereumFlashLoanEngine\nfrom .protocols.v2.uniswap_v2 import UniswapV2Adapter\nfrom .protocols.v3.uniswap_v3 import UniswapV3Adapter\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumArbitrageService:\n    \"\"\"Main Ethereum arbitrage microservice orchestrator\"\"\"\n    \n    def __init__(self):\n        self.config = EthereumConfig()\n        \n        # Core components\n        self.engine = EthereumEngine(self.config)\n        self.cross_arbitrage = EthereumCrossArbitrage(self.engine, self.config)\n        self.triangular_arbitrage = EthereumTriangularArbitrage(self.engine, self.config)\n        self.mempool_monitor = EthereumMempoolMonitor(self.engine, self.config)\n        self.flashloan_engine = EthereumFlashLoanEngine(self.engine, self.config)\n        \n        # Protocol adapters\n        self.uniswap_v2 = UniswapV2Adapter(self.engine, self.config)\n        self.uniswap_v3 = UniswapV3Adapter(self.engine, self.config)\n        \n        # State\n        self.is_running = False\n        self.active_opportunities = {}\n        self.execution_locks = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize all components\"\"\"\n        try:\n            logger.info(\"Initializing Ethereum arbitrage service...\")\n            \n            # Validate configuration\n            self.config.validate()\n            \n            # Initialize core components\n            await self.engine.initialize()\n            await self.cross_arbitrage.initialize()\n            await self.triangular_arbitrage.initialize()\n            await self.mempool_monitor.initialize()\n            await self.flashloan_engine.initialize()\n            \n            # Initialize protocol adapters\n            await self.uniswap_v2.initialize()\n            await self.uniswap_v3.initialize()\n            \n            # Setup mempool opportunity callback\n            self.mempool_monitor.add_opportunity_callback(self._handle_mempool_opportunity)\n            \n            logger.info(\"Ethereum arbitrage service initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Ethereum service: {e}\")\n            raise\n    \n    async def start(self):\n        \"\"\"Start the arbitrage service\"\"\"\n        try:\n            if self.is_running:\n                logger.warning(\"Service already running\")\n                return\n            \n            self.is_running = True\n            logger.info(\"Starting Ethereum arbitrage service...\")\n            \n            # Start background tasks\n            tasks = [\n                asyncio.create_task(self._opportunity_scanner()),\n                asyncio.create_task(self._mempool_monitoring()),\n                asyncio.create_task(self._health_monitor())\n            ]\n            \n            # Wait for all tasks\n            await asyncio.gather(*tasks)\n            \n        except Exception as e:\n            logger.error(f\"Error in Ethereum service: {e}\")\n            self.is_running = False\n    \n    async def stop(self):\n        \"\"\"Stop the arbitrage service\"\"\"\n        logger.info(\"Stopping Ethereum arbitrage service...\")\n        self.is_running = False\n        await self.mempool_monitor.stop_monitoring()\n    \n    async def _opportunity_scanner(self):\n        \"\"\"Main opportunity scanning loop\"\"\"\n        while self.is_running:\n            try:\n                # Scan for cross-exchange arbitrage\n                cross_opportunities = await self.cross_arbitrage.scan_opportunities()\n                for opportunity in cross_opportunities:\n                    await self._evaluate_opportunity(opportunity)\n                \n                # Scan for triangular arbitrage\n                triangular_opportunities = await self.triangular_arbitrage.scan_opportunities()\n                for opportunity in triangular_opportunities:\n                    await self._evaluate_opportunity(opportunity)\n                \n                # Wait before next scan\n                await asyncio.sleep(1)  # Scan every second\n                \n            except Exception as e:\n                logger.error(f\"Error in opportunity scanner: {e}\")\n                await asyncio.sleep(5)  # Wait longer on error\n    \n    async def _mempool_monitoring(self):\n        \"\"\"Start mempool monitoring\"\"\"\n        try:\n            if self.config.MEMPOOL_MONITOR_ENABLED:\n                await self.mempool_monitor.start_monitoring()\n        except Exception as e:\n            logger.error(f\"Error in mempool monitoring: {e}\")\n    \n    async def _health_monitor(self):\n        \"\"\"Monitor service health\"\"\"\n        while self.is_running:\n            try:\n                # Check blockchain connection\n                block_number = await self.engine.get_block_number()\n                logger.debug(f\"Current block: {block_number}\")\n                \n                # Check wallet balance\n                if self.engine.wallet_address:\n                    eth_balance = await self.engine.get_balance(\"ETH\", self.engine.wallet_address)\n                    logger.debug(f\"ETH balance: {eth_balance}\")\n                \n                await asyncio.sleep(30)  # Check every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Health monitor error: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _evaluate_opportunity(self, opportunity: ArbitrageOpportunity):\n        \"\"\"Evaluate and potentially execute an opportunity\"\"\"\n        try:\n            # Skip if already being processed\n            if opportunity.opportunity_id in self.execution_locks:\n                return\n            \n            # Calculate detailed profit\n            if opportunity.strategy_type == \"cross\":\n                profit = await self.cross_arbitrage.calculate_profit(opportunity)\n            elif opportunity.strategy_type == \"triangular\":\n                profit = await self.triangular_arbitrage.calculate_profit(opportunity)\n            else:\n                return\n            \n            # Check if profitable after costs\n            if profit <= 0:\n                return\n            \n            logger.info(f\"Profitable opportunity found: {opportunity.opportunity_id}, profit: ${profit}\")\n            \n            # Execute if profitable\n            await self._execute_opportunity(opportunity)\n            \n        except Exception as e:\n            logger.error(f\"Error evaluating opportunity {opportunity.opportunity_id}: {e}\")\n    \n    async def _execute_opportunity(self, opportunity: ArbitrageOpportunity):\n        \"\"\"Execute an arbitrage opportunity\"\"\"\n        try:\n            # Acquire execution lock\n            self.execution_locks[opportunity.opportunity_id] = asyncio.Lock()\n            \n            async with self.execution_locks[opportunity.opportunity_id]:\n                logger.info(f\"Executing opportunity: {opportunity.opportunity_id}\")\n                \n                # Execute based on strategy type\n                if opportunity.strategy_type == \"cross\":\n                    result = await self.cross_arbitrage.execute_arbitrage(opportunity)\n                elif opportunity.strategy_type == \"triangular\":\n                    result = await self.triangular_arbitrage.execute_arbitrage(opportunity)\n                elif opportunity.strategy_type == \"mempool_backrun\":\n                    result = await self.mempool_monitor.execute_backrun(opportunity)\n                else:\n                    logger.warning(f\"Unknown strategy type: {opportunity.strategy_type}\")\n                    return\n                \n                # Log result\n                if result.get(\"status\") == \"success\":\n                    logger.info(f\"Successfully executed {opportunity.opportunity_id}: {result}\")\n                else:\n                    logger.error(f\"Failed to execute {opportunity.opportunity_id}: {result}\")\n            \n        except Exception as e:\n            logger.error(f\"Error executing opportunity {opportunity.opportunity_id}: {e}\")\n        finally:\n            # Clean up lock\n            if opportunity.opportunity_id in self.execution_locks:\n                del self.execution_locks[opportunity.opportunity_id]\n    \n    async def _handle_mempool_opportunity(self, opportunity: ArbitrageOpportunity):\n        \"\"\"Handle mempool opportunity callback\"\"\"\n        try:\n            logger.info(f\"Mempool opportunity detected: {opportunity.opportunity_id}\")\n            await self._evaluate_opportunity(opportunity)\n        except Exception as e:\n            logger.error(f\"Error handling mempool opportunity: {e}\")\n    \n    async def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get service status\"\"\"\n        try:\n            # Get the actual connected chain ID from web3 connection\n            actual_chain_id = await self.engine.w3.eth.chain_id if self.engine.w3 else self.config.CHAIN_ID\n            \n            return {\n                \"service\": \"ethereum_arbitrage\",\n                \"status\": \"running\" if self.is_running else \"stopped\",\n                \"chain_id\": actual_chain_id,\n                \"config_chain_id\": self.config.CHAIN_ID,\n                \"wallet_address\": self.engine.wallet_address,\n                \"block_number\": await self.engine.get_block_number() if self.engine.w3 else 0,\n                \"active_opportunities\": len(self.active_opportunities),\n                \"mempool_monitoring\": self.config.MEMPOOL_MONITOR_ENABLED,\n                \"last_update\": datetime.now().isoformat()\n            }\n        except Exception as e:\n            logger.error(f\"Error getting status: {e}\")\n            return {\"status\": \"error\", \"error\": str(e)}\n\n# Main entry point for the microservice\nasync def main():\n    \"\"\"Main entry point\"\"\"\n    logging.basicConfig(level=logging.INFO)\n    \n    service = EthereumArbitrageService()\n    \n    try:\n        await service.initialize()\n        await service.start()\n    except KeyboardInterrupt:\n        logger.info(\"Received shutdown signal\")\n    finally:\n        await service.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":10577},"dex/ethereum_service/swap_orchestrator.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom .engine import EthereumEngine\nfrom .erc20_helper import ERC20Helper\nfrom .abi_encoder import SwapCallDataEncoder\n\nlogger = logging.getLogger(__name__)\n\nclass SwapOrchestrator:\n    \"\"\"Orchestrates the complete swap flow including approvals\"\"\"\n    \n    def __init__(self, engine: EthereumEngine):\n        self.engine = engine\n        \n    async def execute_swap_with_approval(\n        self,\n        token_in: str,\n        token_out: str,\n        amount_in: Decimal,\n        router_address: str,\n        swap_calldata: str,\n        min_allowance: Decimal = None\n    ) -> Dict[str, Any]:\n        \"\"\"Execute a complete swap including approval if needed\"\"\"\n        try:\n            if not self.engine.erc20_helper:\n                raise ValueError(\"ERC20Helper not available\")\n            \n            # Get token info for proper unit handling\n            token_info = await self.engine.erc20_helper.get_token_info(token_in)\n            if not token_info:\n                raise ValueError(f\"Could not get token info for {token_in}\")\n            \n            # Check current allowance (returns in decimal units)\n            current_allowance = await self.engine.erc20_helper.get_allowance(\n                token_in, \n                router_address\n            )\n            \n            # Determine if approval is needed (both in decimal units)\n            required_amount = min_allowance or amount_in\n            needs_approval = current_allowance < required_amount\n            \n            transactions = []\n            \n            if needs_approval:\n                # Build approval transaction (helper handles decimal to wei conversion)\n                approve_amount = required_amount * 2  # Approve 2x for gas efficiency\n                approve_tx = await self.engine.erc20_helper.build_approve_transaction(\n                    token_in,\n                    router_address,\n                    approve_amount\n                )\n                \n                if approve_tx:\n                    transactions.append({\n                        \"type\": \"approve\",\n                        \"tx_data\": approve_tx\n                    })\n                    logger.info(f\"Approval needed for {token_in} -> {router_address}\")\n            \n            # Add swap transaction\n            transactions.append({\n                \"type\": \"swap\", \n                \"tx_data\": {\n                    \"to\": router_address,\n                    \"value\": 0,\n                    \"data\": swap_calldata\n                }\n            })\n            \n            # Execute transactions sequentially\n            tx_hashes = []\n            for tx in transactions:\n                try:\n                    tx_hash = await self.engine.execute_transaction(tx[\"tx_data\"])\n                    tx_hashes.append({\n                        \"type\": tx[\"type\"],\n                        \"hash\": tx_hash\n                    })\n                    \n                    # Wait for approval before swap\n                    if tx[\"type\"] == \"approve\":\n                        await self._wait_for_confirmation(tx_hash)\n                        \n                except Exception as e:\n                    logger.error(f\"Transaction failed ({tx['type']}): {e}\")\n                    return {\n                        \"success\": False,\n                        \"error\": str(e),\n                        \"completed_transactions\": tx_hashes\n                    }\n            \n            return {\n                \"success\": True,\n                \"transactions\": tx_hashes,\n                \"needs_approval\": needs_approval\n            }\n            \n        except Exception as e:\n            logger.error(f\"Swap orchestration failed: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def _wait_for_confirmation(self, tx_hash: str, max_wait: int = 60) -> bool:\n        \"\"\"Wait for transaction confirmation\"\"\"\n        try:\n            for _ in range(max_wait):\n                try:\n                    receipt = await self.engine.w3.eth.get_transaction_receipt(tx_hash)\n                    if receipt and receipt.blockNumber:\n                        return receipt.status == 1\n                except Exception:\n                    # Transaction not yet mined\n                    pass\n                await asyncio.sleep(1)\n            \n            logger.warning(f\"Transaction {tx_hash} not confirmed within {max_wait}s\")\n            return False\n            \n        except Exception as e:\n            logger.error(f\"Error waiting for confirmation: {e}\")\n            return False\n    \n    async def build_multicall_transaction(\n        self,\n        router_address: str,\n        calls: List[str]\n    ) -> Dict[str, Any]:\n        \"\"\"Build a multicall transaction combining multiple operations\"\"\"\n        try:\n            multicall_data = SwapCallDataEncoder.encode_multicall(calls)\n            \n            return {\n                \"to\": router_address,\n                \"value\": 0,\n                \"data\": multicall_data,\n                \"gas\": len(calls) * 100000  # Estimate based on call count\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error building multicall: {e}\")\n            return {}\n    \n    async def estimate_swap_gas(\n        self,\n        token_in: str,\n        token_out: str,\n        amount_in: Decimal,\n        router_address: str,\n        swap_calldata: str\n    ) -> int:\n        \"\"\"Estimate total gas including potential approval\"\"\"\n        try:\n            base_gas = 21000  # Base transaction cost\n            swap_gas = 150000  # Estimated swap gas\n            \n            # Check if approval is needed\n            if self.engine.erc20_helper:\n                allowance = await self.engine.erc20_helper.get_allowance(\n                    token_in, \n                    router_address\n                )\n                \n                if allowance < amount_in:\n                    base_gas += 60000  # Add approval gas\n            \n            return base_gas + swap_gas\n            \n        except Exception as e:\n            logger.error(f\"Error estimating gas: {e}\")\n            return 250000  # Conservative fallback","size_bytes":6306},"dex/ethereum_service/triangular_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageStrategy\nfrom models.arbitrage_models import ArbitrageOpportunity, Token\n\nfrom .engine import EthereumEngine\nfrom .config import EthereumConfig\n\nlogger = logging.getLogger(__name__)\n\nclass EthereumTriangularArbitrage(BaseArbitrageStrategy):\n    \"\"\"Triangular arbitrage within same DEX (e.g., ETH->USDC->DAI->ETH on Uniswap)\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.triangular_paths = []\n        \n    async def initialize(self):\n        \"\"\"Initialize triangular arbitrage paths\"\"\"\n        logger.info(\"Initializing Ethereum triangular arbitrage engine...\")\n        self.triangular_paths = self._generate_triangular_paths()\n        \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for triangular arbitrage opportunities\"\"\"\n        opportunities = []\n        \n        try:\n            for path in self.triangular_paths:\n                opportunity = await self._analyze_triangular_path(path)\n                if opportunity:\n                    opportunities.append(opportunity)\n                    \n        except Exception as e:\n            logger.error(f\"Error scanning triangular opportunities: {e}\")\n        \n        return opportunities\n    \n    async def calculate_profit(self, opportunity: ArbitrageOpportunity) -> Decimal:\n        \"\"\"Calculate triangular arbitrage profit\"\"\"\n        try:\n            # Simulate the triangular trade path\n            if not opportunity.tokens_path or len(opportunity.tokens_path) != 3:\n                return Decimal(\"0\")\n            \n            # Start with base amount\n            amount = Decimal(str(self.config.MAX_TRADE_SIZE_ETH))\n            \n            # Simulate each hop in the triangular path\n            for i in range(len(opportunity.tokens_path) - 1):\n                token_from = opportunity.tokens_path[i]\n                token_to = opportunity.tokens_path[i + 1]\n                \n                # Get exchange rate (simplified)\n                rate = await self._get_exchange_rate(token_from, token_to)\n                amount = amount * rate\n            \n            # Calculate profit\n            initial_amount = Decimal(str(self.config.MAX_TRADE_SIZE_ETH))\n            profit = amount - initial_amount\n            \n            # Subtract gas costs\n            gas_cost = await self._estimate_triangular_gas_cost()\n            net_profit = profit - gas_cost\n            \n            return net_profit\n            \n        except Exception as e:\n            logger.error(f\"Error calculating triangular profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def execute_arbitrage(self, opportunity: ArbitrageOpportunity) -> Dict[str, Any]:\n        \"\"\"Execute triangular arbitrage with flash loan\"\"\"\n        try:\n            logger.info(f\"Executing triangular arbitrage: {opportunity.opportunity_id}\")\n            \n            # This would:\n            # 1. Request flash loan for starting token\n            # 2. Execute three swaps in sequence\n            # 3. Repay flash loan\n            # 4. Keep profit\n            \n            # Placeholder implementation\n            return {\n                \"status\": \"success\",\n                \"tx_hash\": \"0x456...\",\n                \"profit_realized\": \"0.3\",\n                \"gas_used\": 250000\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error executing triangular arbitrage: {e}\")\n            return {\n                \"status\": \"failed\",\n                \"error\": str(e)\n            }\n    \n    def _generate_triangular_paths(self) -> List[List[str]]:\n        \"\"\"Generate profitable triangular arbitrage paths\"\"\"\n        paths = []\n        \n        # Common triangular paths on Ethereum\n        paths.extend([\n            [\"WETH\", \"USDC\", \"DAI\"],      # ETH -> USDC -> DAI -> ETH\n            [\"WETH\", \"USDT\", \"DAI\"],      # ETH -> USDT -> DAI -> ETH\n            [\"WETH\", \"WBTC\", \"USDC\"],     # ETH -> WBTC -> USDC -> ETH\n            [\"USDC\", \"USDT\", \"DAI\"],      # USDC -> USDT -> DAI -> USDC\n            [\"WETH\", \"DAI\", \"USDT\"],      # ETH -> DAI -> USDT -> ETH\n        ])\n        \n        return paths\n    \n    async def _analyze_triangular_path(self, path: List[str]) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Analyze a triangular path for arbitrage opportunity\"\"\"\n        try:\n            # Calculate the effective exchange rate for the full path\n            effective_rate = Decimal(\"1\")\n            \n            for i in range(len(path)):\n                token_from = path[i]\n                token_to = path[(i + 1) % len(path)]  # Wrap around to close the triangle\n                \n                rate = await self._get_exchange_rate(token_from, token_to)\n                effective_rate *= rate\n            \n            # Check if completing the triangle results in profit\n            profit_pct = (effective_rate - 1) * 100\n            \n            if profit_pct < self.config.MIN_PROFIT_THRESHOLD:\n                return None\n            \n            # Create tokens for the path\n            tokens = [Token(\n                address=self.config.TOKENS.get(symbol, \"0x0\"),\n                symbol=symbol,\n                decimals=18,\n                name=symbol\n            ) for symbol in path]\n            \n            return ArbitrageOpportunity(\n                opportunity_id=f\"triangular_{'_'.join(path)}_{int(datetime.now().timestamp())}\",\n                strategy_type=\"triangular\",\n                chain=\"ethereum\",\n                profit_percentage=profit_pct,\n                profit_amount_usd=Decimal(\"0\"),  # Will be calculated later\n                gas_cost_usd=Decimal(\"0\"),      # Will be calculated later\n                net_profit_usd=Decimal(\"0\"),    # Will be calculated later\n                detected_at=datetime.now(),\n                tokens_path=tokens\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing triangular path {path}: {e}\")\n            return None\n    \n    async def _get_exchange_rate(self, token_from: str, token_to: str) -> Decimal:\n        \"\"\"Get exchange rate between two tokens (simplified)\"\"\"\n        # Placeholder implementation with mock rates\n        rates = {\n            (\"WETH\", \"USDC\"): Decimal(\"1800\"),\n            (\"USDC\", \"DAI\"): Decimal(\"1.001\"),\n            (\"DAI\", \"WETH\"): Decimal(\"0.000555\"),\n            (\"WETH\", \"USDT\"): Decimal(\"1799\"),\n            (\"USDT\", \"DAI\"): Decimal(\"0.9995\"),\n            (\"WETH\", \"WBTC\"): Decimal(\"0.045\"),\n            (\"WBTC\", \"USDC\"): Decimal(\"40000\"),\n        }\n        \n        # Try direct rate\n        direct_rate = rates.get((token_from, token_to))\n        if direct_rate:\n            return direct_rate\n        \n        # Try inverse rate\n        inverse_rate = rates.get((token_to, token_from))\n        if inverse_rate:\n            return Decimal(\"1\") / inverse_rate\n        \n        # Default rate\n        return Decimal(\"1\")\n    \n    async def _estimate_triangular_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for triangular arbitrage\"\"\"\n        try:\n            # Estimate for flash loan + 3 swaps\n            estimated_gas = 350000\n            gas_price = await self.engine.get_gas_price()\n            \n            # Convert to USD (simplified)\n            eth_price_usd = Decimal(\"1800\")\n            gas_cost_eth = Decimal(str(estimated_gas * gas_price)) / Decimal(\"1e18\")\n            gas_cost_usd = gas_cost_eth * eth_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception as e:\n            logger.error(f\"Error estimating triangular gas cost: {e}\")\n            return Decimal(\"40\")  # Default $40 estimate","size_bytes":8013},"dex/ethereum_service/uniswap_helper.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom web3 import Web3\nfrom eth_abi import encode, decode\n\nlogger = logging.getLogger(__name__)\n\nclass UniswapHelper:\n    \"\"\"Helper class for real Uniswap contract interactions\"\"\"\n    \n    # Uniswap V2 Factory ABI (minimal)\n    FACTORY_V2_ABI = [\n        {\n            \"constant\": True,\n            \"inputs\": [\n                {\"name\": \"tokenA\", \"type\": \"address\"},\n                {\"name\": \"tokenB\", \"type\": \"address\"}\n            ],\n            \"name\": \"getPair\",\n            \"outputs\": [{\"name\": \"pair\", \"type\": \"address\"}],\n            \"type\": \"function\"\n        }\n    ]\n    \n    # Uniswap V2 Pair ABI (minimal)\n    PAIR_V2_ABI = [\n        {\n            \"constant\": True,\n            \"inputs\": [],\n            \"name\": \"getReserves\",\n            \"outputs\": [\n                {\"name\": \"reserve0\", \"type\": \"uint112\"},\n                {\"name\": \"reserve1\", \"type\": \"uint112\"},\n                {\"name\": \"blockTimestampLast\", \"type\": \"uint32\"}\n            ],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": True,\n            \"inputs\": [],\n            \"name\": \"token0\",\n            \"outputs\": [{\"name\": \"\", \"type\": \"address\"}],\n            \"type\": \"function\"\n        },\n        {\n            \"constant\": True,\n            \"inputs\": [],\n            \"name\": \"token1\",\n            \"outputs\": [{\"name\": \"\", \"type\": \"address\"}],\n            \"type\": \"function\"\n        }\n    ]\n    \n    # Uniswap V3 Factory ABI (minimal)\n    FACTORY_V3_ABI = [\n        {\n            \"inputs\": [\n                {\"name\": \"tokenA\", \"type\": \"address\"},\n                {\"name\": \"tokenB\", \"type\": \"address\"},\n                {\"name\": \"fee\", \"type\": \"uint24\"}\n            ],\n            \"name\": \"getPool\",\n            \"outputs\": [{\"name\": \"pool\", \"type\": \"address\"}],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        }\n    ]\n    \n    # Uniswap V3 Pool ABI (minimal)\n    POOL_V3_ABI = [\n        {\n            \"inputs\": [],\n            \"name\": \"slot0\",\n            \"outputs\": [\n                {\"name\": \"sqrtPriceX96\", \"type\": \"uint160\"},\n                {\"name\": \"tick\", \"type\": \"int24\"},\n                {\"name\": \"observationIndex\", \"type\": \"uint16\"},\n                {\"name\": \"observationCardinality\", \"type\": \"uint16\"},\n                {\"name\": \"observationCardinalityNext\", \"type\": \"uint16\"},\n                {\"name\": \"feeProtocol\", \"type\": \"uint8\"},\n                {\"name\": \"unlocked\", \"type\": \"bool\"}\n            ],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"liquidity\",\n            \"outputs\": [{\"name\": \"\", \"type\": \"uint128\"}],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        }\n    ]\n    \n    def __init__(self, w3, factory_v2_address: str, factory_v3_address: str):\n        self.w3 = w3\n        self.factory_v2_address = factory_v2_address\n        self.factory_v3_address = factory_v3_address\n        \n        # Initialize contracts\n        self.factory_v2 = w3.eth.contract(\n            address=Web3.to_checksum_address(factory_v2_address),\n            abi=self.FACTORY_V2_ABI\n        )\n        self.factory_v3 = w3.eth.contract(\n            address=Web3.to_checksum_address(factory_v3_address),\n            abi=self.FACTORY_V3_ABI\n        )\n    \n    async def get_v2_pair_reserves(self, token_a: str, token_b: str) -> Optional[Tuple[Decimal, Decimal]]:\n        \"\"\"Get actual V2 pair reserves from blockchain\"\"\"\n        try:\n            # Get pair address\n            pair_address = await self.factory_v2.functions.getPair(\n                Web3.to_checksum_address(token_a),\n                Web3.to_checksum_address(token_b)\n            ).call()\n            \n            if pair_address == \"0x0000000000000000000000000000000000000000\":\n                return None\n            \n            # Get pair contract\n            pair_contract = self.w3.eth.contract(\n                address=pair_address,\n                abi=self.PAIR_V2_ABI\n            )\n            \n            # Get reserves\n            reserves = await pair_contract.functions.getReserves().call()\n            reserve0, reserve1, _ = reserves\n            \n            # Get token order\n            token0 = await pair_contract.functions.token0().call()\n            \n            # Ensure correct order (token_a, token_b)\n            if token0.lower() == token_a.lower():\n                return (Decimal(str(reserve0)), Decimal(str(reserve1)))\n            else:\n                return (Decimal(str(reserve1)), Decimal(str(reserve0)))\n                \n        except Exception as e:\n            logger.error(f\"Error getting V2 reserves for {token_a}/{token_b}: {e}\")\n            return None\n    \n    async def get_v3_pool_data(self, token_a: str, token_b: str, fee_tier: int) -> Optional[Dict]:\n        \"\"\"Get actual V3 pool data from blockchain\"\"\"\n        try:\n            # Get pool address\n            pool_address = await self.factory_v3.functions.getPool(\n                Web3.to_checksum_address(token_a),\n                Web3.to_checksum_address(token_b),\n                fee_tier\n            ).call()\n            \n            if pool_address == \"0x0000000000000000000000000000000000000000\":\n                return None\n            \n            # Get pool contract\n            pool_contract = self.w3.eth.contract(\n                address=pool_address,\n                abi=self.POOL_V3_ABI\n            )\n            \n            # Get slot0 data\n            slot0 = await pool_contract.functions.slot0().call()\n            sqrt_price_x96, tick, _, _, _, _, _ = slot0\n            \n            # Get liquidity\n            liquidity = await pool_contract.functions.liquidity().call()\n            \n            return {\n                \"pool_address\": pool_address,\n                \"sqrtPriceX96\": sqrt_price_x96,\n                \"tick\": tick,\n                \"liquidity\": liquidity,\n                \"fee\": fee_tier\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 pool data for {token_a}/{token_b}: {e}\")\n            return None\n    \n    def calculate_v2_price(self, reserve_a: Decimal, reserve_b: Decimal) -> Decimal:\n        \"\"\"Calculate V2 price from reserves\"\"\"\n        if reserve_a == 0:\n            return Decimal(\"0\")\n        return reserve_b / reserve_a\n    \n    def calculate_v2_amount_out(self, amount_in: Decimal, reserve_in: Decimal, reserve_out: Decimal) -> Decimal:\n        \"\"\"Calculate V2 amount out using the constant product formula\"\"\"\n        try:\n            if reserve_in == 0 or reserve_out == 0:\n                return Decimal(\"0\")\n            \n            # Uniswap V2 formula with 0.3% fee\n            amount_in_with_fee = amount_in * 997\n            numerator = amount_in_with_fee * reserve_out\n            denominator = reserve_in * 1000 + amount_in_with_fee\n            \n            return numerator / denominator\n            \n        except Exception as e:\n            logger.error(f\"Error calculating V2 amount out: {e}\")\n            return Decimal(\"0\")\n    \n    def sqrt_price_to_price(self, sqrt_price_x96: int, decimals_a: int = 18, decimals_b: int = 18) -> Decimal:\n        \"\"\"Convert V3 sqrtPriceX96 to actual price\"\"\"\n        try:\n            # Calculate price from sqrt price\n            sqrt_price = Decimal(str(sqrt_price_x96)) / Decimal(str(2 ** 96))\n            price = sqrt_price ** 2\n            \n            # Adjust for decimals\n            decimal_adjustment = Decimal(str(10 ** (decimals_b - decimals_a)))\n            adjusted_price = price * decimal_adjustment\n            \n            return adjusted_price\n            \n        except Exception as e:\n            logger.error(f\"Error converting sqrt price: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_best_v3_fee_tier(self, token_a: str, token_b: str) -> int:\n        \"\"\"Find the V3 fee tier with the most liquidity\"\"\"\n        try:\n            fee_tiers = [100, 500, 3000, 10000]  # 0.01%, 0.05%, 0.3%, 1%\n            best_tier = 3000\n            best_liquidity = 0\n            \n            for fee_tier in fee_tiers:\n                pool_data = await self.get_v3_pool_data(token_a, token_b, fee_tier)\n                if pool_data and pool_data[\"liquidity\"] > best_liquidity:\n                    best_liquidity = pool_data[\"liquidity\"]\n                    best_tier = fee_tier\n            \n            return best_tier\n            \n        except Exception as e:\n            logger.error(f\"Error finding best V3 fee tier: {e}\")\n            return 3000  # Default to 0.3%","size_bytes":8670},"dex/orchestrator/__init__.py":{"content":"# DEX Arbitrage Orchestrator","size_bytes":28},"dex/orchestrator/execution_coordinator.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport json\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nlogger = logging.getLogger(__name__)\n\nclass ExecutionStatus(Enum):\n    PENDING = \"pending\"\n    EXECUTING = \"executing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass ExecutionPlan:\n    opportunity_id: str\n    execution_type: str  # \"cross\", \"triangular\", \"flash_loan\"\n    steps: List[Dict[str, Any]]\n    estimated_gas: int\n    estimated_time: float\n    risk_level: str\n    required_balance: Decimal\n\n@dataclass\nclass ExecutionMetrics:\n    total_executions: int\n    successful_executions: int\n    failed_executions: int\n    total_profit_usd: Decimal\n    total_gas_cost_usd: Decimal\n    average_execution_time: float\n    success_rate: float\n\nclass ExecutionCoordinator:\n    \"\"\"Coordinates arbitrage opportunity execution across all chains\"\"\"\n    \n    def __init__(self):\n        self.active_executions: Dict[str, Dict[str, Any]] = {}\n        self.execution_history: List[ExecutionResult] = {}\n        self.execution_queue: List[Tuple[ArbitrageOpportunity, ExecutionPlan]] = []\n        \n        # Configuration\n        self.config = {\n            \"max_concurrent_executions\": 3,\n            \"execution_timeout\": 300,  # 5 minutes\n            \"retry_attempts\": 2,\n            \"min_success_rate\": 70.0,  # %\n            \"gas_price_multiplier\": 1.1,\n            \"slippage_tolerance\": 0.5  # %\n        }\n        \n        # Metrics\n        self.metrics = ExecutionMetrics(\n            total_executions=0,\n            successful_executions=0,\n            failed_executions=0,\n            total_profit_usd=Decimal(\"0\"),\n            total_gas_cost_usd=Decimal(\"0\"),\n            average_execution_time=0.0,\n            success_rate=0.0\n        )\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize execution coordinator\"\"\"\n        logger.info(\"Initializing Execution Coordinator...\")\n        \n        # Start background tasks\n        asyncio.create_task(self._execution_monitor())\n        asyncio.create_task(self._metrics_updater())\n        \n        logger.info(\"Execution Coordinator initialized\")\n    \n    async def execute_opportunity(\n        self, \n        service: Any, \n        opportunity: ArbitrageOpportunity\n    ) -> ExecutionResult:\n        \"\"\"Execute an arbitrage opportunity using the appropriate service\"\"\"\n        try:\n            execution_id = f\"exec_{opportunity.id}_{datetime.now().timestamp()}\"\n            \n            logger.info(f\"Starting execution {execution_id} for opportunity {opportunity.id}\")\n            \n            # Create execution plan\n            execution_plan = await self._create_execution_plan(opportunity)\n            if not execution_plan:\n                raise ValueError(\"Failed to create execution plan\")\n            \n            # Register execution\n            self.active_executions[execution_id] = {\n                \"opportunity\": opportunity,\n                \"plan\": execution_plan,\n                \"service\": service,\n                \"status\": ExecutionStatus.PENDING,\n                \"start_time\": datetime.now(),\n                \"retry_count\": 0\n            }\n            \n            # Execute based on opportunity type\n            if opportunity.type == \"cross_exchange\":\n                result = await self._execute_cross_exchange(execution_id, service, opportunity, execution_plan)\n            elif opportunity.type == \"triangular\":\n                result = await self._execute_triangular(execution_id, service, opportunity, execution_plan)\n            elif opportunity.type == \"flash_loan\":\n                result = await self._execute_flash_loan(execution_id, service, opportunity, execution_plan)\n            else:\n                raise ValueError(f\"Unknown opportunity type: {opportunity.type}\")\n            \n            # Update execution status\n            self.active_executions[execution_id][\"status\"] = (\n                ExecutionStatus.COMPLETED if result.success else ExecutionStatus.FAILED\n            )\n            \n            # Record result\n            self.execution_history.append(result)\n            await self._update_metrics(result)\n            \n            logger.info(f\"Execution {execution_id} completed: Success={result.success}, Profit=${result.profit_usd}\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error executing opportunity {opportunity.id}: {e}\")\n            \n            # Mark as failed\n            if execution_id in self.active_executions:\n                self.active_executions[execution_id][\"status\"] = ExecutionStatus.FAILED\n            \n            # Create error result\n            error_result = ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n            \n            self.execution_history.append(error_result)\n            await self._update_metrics(error_result)\n            \n            return error_result\n        \n        finally:\n            # Clean up active execution\n            if execution_id in self.active_executions:\n                del self.active_executions[execution_id]\n    \n    async def _create_execution_plan(self, opportunity: ArbitrageOpportunity) -> Optional[ExecutionPlan]:\n        \"\"\"Create detailed execution plan for opportunity\"\"\"\n        try:\n            steps = []\n            estimated_gas = 0\n            \n            if opportunity.type == \"cross_exchange\":\n                # Plan for cross-exchange arbitrage\n                steps = [\n                    {\n                        \"action\": \"check_balances\",\n                        \"tokens\": [opportunity.token_a, opportunity.token_b]\n                    },\n                    {\n                        \"action\": \"approve_tokens\",\n                        \"token\": opportunity.token_a,\n                        \"spender\": opportunity.exchange_a,\n                        \"amount\": opportunity.amount_in\n                    },\n                    {\n                        \"action\": \"swap\",\n                        \"exchange\": opportunity.exchange_a,\n                        \"token_in\": opportunity.token_a,\n                        \"token_out\": opportunity.token_b,\n                        \"amount_in\": opportunity.amount_in\n                    },\n                    {\n                        \"action\": \"approve_tokens\",\n                        \"token\": opportunity.token_b,\n                        \"spender\": opportunity.exchange_b,\n                        \"amount\": opportunity.amount_out\n                    },\n                    {\n                        \"action\": \"swap\",\n                        \"exchange\": opportunity.exchange_b,\n                        \"token_in\": opportunity.token_b,\n                        \"token_out\": opportunity.token_a,\n                        \"amount_in\": opportunity.amount_out\n                    }\n                ]\n                estimated_gas = 400000  # Estimated for 2 swaps + approvals\n                \n            elif opportunity.type == \"triangular\":\n                # Plan for triangular arbitrage\n                steps = [\n                    {\n                        \"action\": \"check_balances\",\n                        \"tokens\": [opportunity.token_a, opportunity.token_b, opportunity.token_c]\n                    },\n                    {\n                        \"action\": \"multi_swap\",\n                        \"path\": [opportunity.token_a, opportunity.token_b, opportunity.token_c, opportunity.token_a],\n                        \"amounts\": [opportunity.amount_in, opportunity.amount_ab, opportunity.amount_bc, opportunity.amount_out]\n                    }\n                ]\n                estimated_gas = 500000  # Estimated for triangular swap\n                \n            elif opportunity.type == \"flash_loan\":\n                # Plan for flash loan arbitrage\n                steps = [\n                    {\n                        \"action\": \"flash_loan\",\n                        \"token\": opportunity.token_a,\n                        \"amount\": opportunity.loan_amount,\n                        \"callback_data\": {\n                            \"swaps\": opportunity.swap_sequence,\n                            \"expected_profit\": opportunity.profit_usd\n                        }\n                    }\n                ]\n                estimated_gas = 600000  # Estimated for flash loan execution\n            \n            return ExecutionPlan(\n                opportunity_id=opportunity.id,\n                execution_type=opportunity.type,\n                steps=steps,\n                estimated_gas=estimated_gas,\n                estimated_time=estimated_gas / 100000,  # Rough time estimate\n                risk_level=self._assess_risk_level(opportunity),\n                required_balance=opportunity.amount_in if hasattr(opportunity, 'amount_in') else Decimal(\"0\")\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error creating execution plan: {e}\")\n            return None\n    \n    def _assess_risk_level(self, opportunity: ArbitrageOpportunity) -> str:\n        \"\"\"Assess risk level for opportunity\"\"\"\n        risk_score = getattr(opportunity, 'risk_score', 50)\n        \n        if risk_score < 30:\n            return \"low\"\n        elif risk_score < 60:\n            return \"medium\"\n        else:\n            return \"high\"\n    \n    async def _execute_cross_exchange(\n        self,\n        execution_id: str,\n        service: Any,\n        opportunity: ArbitrageOpportunity,\n        plan: ExecutionPlan\n    ) -> ExecutionResult:\n        \"\"\"Execute cross-exchange arbitrage\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            self.active_executions[execution_id][\"status\"] = ExecutionStatus.EXECUTING\n            \n            # Execute through service's cross arbitrage engine\n            if hasattr(service, 'cross_arbitrage'):\n                result = await service.cross_arbitrage.execute_opportunity(opportunity)\n                \n                execution_time = asyncio.get_event_loop().time() - start_time\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=result.get(\"success\", False),\n                    profit_usd=result.get(\"profit_usd\", Decimal(\"0\")),\n                    gas_cost_usd=result.get(\"gas_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    transaction_hashes=result.get(\"transaction_hashes\", []),\n                    error=result.get(\"error\")\n                )\n            else:\n                raise ValueError(\"Service does not support cross-exchange arbitrage\")\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Cross-exchange execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _execute_triangular(\n        self,\n        execution_id: str,\n        service: Any,\n        opportunity: ArbitrageOpportunity,\n        plan: ExecutionPlan\n    ) -> ExecutionResult:\n        \"\"\"Execute triangular arbitrage\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            self.active_executions[execution_id][\"status\"] = ExecutionStatus.EXECUTING\n            \n            # Execute through service's triangular arbitrage engine\n            if hasattr(service, 'triangular_arbitrage'):\n                result = await service.triangular_arbitrage.execute_opportunity(opportunity)\n                \n                execution_time = asyncio.get_event_loop().time() - start_time\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=result.get(\"success\", False),\n                    profit_usd=result.get(\"profit_usd\", Decimal(\"0\")),\n                    gas_cost_usd=result.get(\"gas_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    transaction_hashes=result.get(\"transaction_hashes\", []),\n                    error=result.get(\"error\")\n                )\n            else:\n                raise ValueError(\"Service does not support triangular arbitrage\")\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Triangular execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _execute_flash_loan(\n        self,\n        execution_id: str,\n        service: Any,\n        opportunity: ArbitrageOpportunity,\n        plan: ExecutionPlan\n    ) -> ExecutionResult:\n        \"\"\"Execute flash loan arbitrage\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            self.active_executions[execution_id][\"status\"] = ExecutionStatus.EXECUTING\n            \n            # Execute through service's flash loan engine\n            if hasattr(service, 'flash_loan'):\n                result = await service.flash_loan.execute_opportunity(opportunity)\n                \n                execution_time = asyncio.get_event_loop().time() - start_time\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=result.get(\"success\", False),\n                    profit_usd=result.get(\"profit_usd\", Decimal(\"0\")),\n                    gas_cost_usd=result.get(\"gas_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    transaction_hashes=result.get(\"transaction_hashes\", []),\n                    error=result.get(\"error\")\n                )\n            else:\n                raise ValueError(\"Service does not support flash loan arbitrage\")\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Flash loan execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _execution_monitor(self) -> None:\n        \"\"\"Monitor active executions for timeouts\"\"\"\n        while True:\n            try:\n                current_time = datetime.now()\n                timed_out_executions = []\n                \n                for execution_id, execution_data in self.active_executions.items():\n                    start_time = execution_data[\"start_time\"]\n                    timeout = timedelta(seconds=self.config[\"execution_timeout\"])\n                    \n                    if current_time - start_time > timeout:\n                        timed_out_executions.append(execution_id)\n                \n                # Handle timeouts\n                for execution_id in timed_out_executions:\n                    logger.warning(f\"Execution {execution_id} timed out\")\n                    self.active_executions[execution_id][\"status\"] = ExecutionStatus.FAILED\n                    \n                    # Create timeout result\n                    execution_data = self.active_executions[execution_id]\n                    timeout_result = ExecutionResult(\n                        opportunity_id=execution_data[\"opportunity\"].id,\n                        success=False,\n                        profit_usd=Decimal(\"0\"),\n                        gas_cost_usd=Decimal(\"0\"),\n                        execution_time=self.config[\"execution_timeout\"],\n                        error=\"Execution timeout\"\n                    )\n                    \n                    self.execution_history.append(timeout_result)\n                    await self._update_metrics(timeout_result)\n                    \n                    del self.active_executions[execution_id]\n                \n                await asyncio.sleep(30)  # Check every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in execution monitor: {e}\")\n                await asyncio.sleep(30)\n    \n    async def _update_metrics(self, result: ExecutionResult) -> None:\n        \"\"\"Update execution metrics\"\"\"\n        self.metrics.total_executions += 1\n        \n        if result.success:\n            self.metrics.successful_executions += 1\n            self.metrics.total_profit_usd += result.profit_usd\n        else:\n            self.metrics.failed_executions += 1\n        \n        self.metrics.total_gas_cost_usd += result.gas_cost_usd\n        \n        # Update averages\n        if self.metrics.total_executions > 0:\n            self.metrics.success_rate = (\n                self.metrics.successful_executions / self.metrics.total_executions * 100\n            )\n        \n        # Update average execution time\n        if self.execution_history:\n            total_time = sum(r.execution_time for r in self.execution_history)\n            self.metrics.average_execution_time = total_time / len(self.execution_history)\n    \n    async def _metrics_updater(self) -> None:\n        \"\"\"Periodically update metrics\"\"\"\n        while True:\n            try:\n                # Clean old history (keep last 1000 executions)\n                if len(self.execution_history) > 1000:\n                    self.execution_history = self.execution_history[-1000:]\n                \n                await asyncio.sleep(60)  # Update every minute\n                \n            except Exception as e:\n                logger.error(f\"Error in metrics updater: {e}\")\n                await asyncio.sleep(60)\n    \n    async def get_execution_status(self, execution_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get status of specific execution\"\"\"\n        return self.active_executions.get(execution_id)\n    \n    async def get_active_executions(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get all active executions\"\"\"\n        return self.active_executions.copy()\n    \n    async def get_metrics(self) -> ExecutionMetrics:\n        \"\"\"Get execution metrics\"\"\"\n        return self.metrics\n    \n    async def cancel_execution(self, execution_id: str) -> bool:\n        \"\"\"Cancel an active execution\"\"\"\n        if execution_id in self.active_executions:\n            self.active_executions[execution_id][\"status\"] = ExecutionStatus.CANCELLED\n            logger.info(f\"Cancelled execution {execution_id}\")\n            return True\n        return False\n    \n    async def get_execution_history(\n        self, \n        limit: int = 100, \n        success_only: bool = False\n    ) -> List[ExecutionResult]:\n        \"\"\"Get execution history\"\"\"\n        history = self.execution_history[-limit:] if limit else self.execution_history\n        \n        if success_only:\n            history = [r for r in history if r.success]\n        \n        return history","size_bytes":19881},"dex/orchestrator/main.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport json\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult, CrossChainOpportunity\n\n# Microservice imports\nfrom ..ethereum_service.arbitrage import EthereumArbitrageService\nfrom .service_registry import ServiceRegistry\nfrom .opportunity_agregator import OpportunityAggregator\nfrom .execution_coordinator import ExecutionCoordinator\nfrom .risk_manager import RiskManager\n\nlogger = logging.getLogger(__name__)\n\nclass ChainStatus(Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\" \n    MAINTENANCE = \"maintenance\"\n    ERROR = \"error\"\n\n@dataclass\nclass SystemHealth:\n    overall_status: str\n    active_chains: List[str]\n    inactive_chains: List[str]\n    total_opportunities: int\n    execution_success_rate: float\n    last_updated: str\n\nclass DEXArbitrageOrchestrator:\n    \"\"\"Main orchestrator for multi-chain DEX arbitrage system\"\"\"\n    \n    def __init__(self):\n        self.service_registry = ServiceRegistry()\n        self.opportunity_aggregator = OpportunityAggregator()\n        self.execution_coordinator = ExecutionCoordinator()\n        self.risk_manager = RiskManager()\n        \n        # Service instances\n        self.blockchain_services: Dict[str, Any] = {}\n        self.chain_status: Dict[str, ChainStatus] = {}\n        \n        # System state\n        self.is_running = False\n        self.execution_queue: List[ArbitrageOpportunity] = []\n        self.active_executions: Dict[str, Any] = {}\n        \n        # Configuration\n        self.config = {\n            \"max_concurrent_executions\": 5,\n            \"min_profit_threshold_usd\": 50.0,\n            \"max_position_size_usd\": 10000.0,\n            \"execution_timeout\": 300,  # 5 minutes\n            \"health_check_interval\": 30  # seconds\n        }\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize all blockchain services and components\"\"\"\n        try:\n            logger.info(\"Initializing DEX Arbitrage Orchestrator...\")\n            \n            # Initialize components\n            await self.service_registry.initialize()\n            await self.opportunity_aggregator.initialize()\n            await self.execution_coordinator.initialize()\n            await self.risk_manager.initialize()\n            \n            # Register and initialize blockchain services\n            await self._initialize_blockchain_services()\n            \n            # Start background tasks\n            asyncio.create_task(self._opportunity_scanner())\n            asyncio.create_task(self._execution_processor())\n            asyncio.create_task(self._health_monitor())\n            \n            self.is_running = True\n            logger.info(\"DEX Arbitrage Orchestrator initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize orchestrator: {e}\")\n            raise\n    \n    async def _initialize_blockchain_services(self) -> None:\n        \"\"\"Initialize all blockchain microservices\"\"\"\n        services_to_init = [\n            (\"ethereum\", EthereumArbitrageService),\n            # Will add more services: BSC, Polygon, Solana\n        ]\n        \n        for chain_name, service_class in services_to_init:\n            try:\n                logger.info(f\"Initializing {chain_name} service...\")\n                service = service_class()\n                await service.initialize()\n                \n                self.blockchain_services[chain_name] = service\n                self.chain_status[chain_name] = ChainStatus.ACTIVE\n                await self.service_registry.register_service(chain_name, service)\n                \n                logger.info(f\"{chain_name} service initialized successfully\")\n                \n            except Exception as e:\n                logger.error(f\"Failed to initialize {chain_name} service: {e}\")\n                self.chain_status[chain_name] = ChainStatus.ERROR\n    \n    async def _opportunity_scanner(self) -> None:\n        \"\"\"Continuously scan for arbitrage opportunities across all chains\"\"\"\n        logger.info(\"Starting opportunity scanner...\")\n        \n        while self.is_running:\n            try:\n                # Scan each active blockchain service\n                all_opportunities = []\n                \n                for chain_name, service in self.blockchain_services.items():\n                    if self.chain_status[chain_name] == ChainStatus.ACTIVE:\n                        try:\n                            # Get cross-exchange arbitrage opportunities\n                            cross_opportunities = await service.cross_arbitrage.scan_opportunities()\n                            \n                            # Get triangular arbitrage opportunities  \n                            triangular_opportunities = await service.triangular_arbitrage.scan_opportunities()\n                            \n                            all_opportunities.extend(cross_opportunities)\n                            all_opportunities.extend(triangular_opportunities)\n                            \n                        except Exception as e:\n                            logger.error(f\"Error scanning {chain_name}: {e}\")\n                            self.chain_status[chain_name] = ChainStatus.ERROR\n                \n                # Aggregate and filter opportunities\n                if all_opportunities:\n                    filtered_opportunities = await self.opportunity_aggregator.process_opportunities(\n                        all_opportunities\n                    )\n                    \n                    # Add profitable opportunities to execution queue\n                    for opportunity in filtered_opportunities:\n                        if await self.risk_manager.validate_opportunity(opportunity):\n                            self.execution_queue.append(opportunity)\n                \n                await asyncio.sleep(5)  # Scan every 5 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in opportunity scanner: {e}\")\n                await asyncio.sleep(10)\n    \n    async def _execution_processor(self) -> None:\n        \"\"\"Process execution queue and coordinate trades\"\"\"\n        logger.info(\"Starting execution processor...\")\n        \n        while self.is_running:\n            try:\n                # Process execution queue\n                while (self.execution_queue and \n                       len(self.active_executions) < self.config[\"max_concurrent_executions\"]):\n                    \n                    opportunity = self.execution_queue.pop(0)\n                    \n                    # Create execution task\n                    execution_id = f\"exec_{len(self.active_executions)}_{opportunity.id}\"\n                    execution_task = asyncio.create_task(\n                        self._execute_opportunity(execution_id, opportunity)\n                    )\n                    \n                    self.active_executions[execution_id] = {\n                        \"task\": execution_task,\n                        \"opportunity\": opportunity,\n                        \"start_time\": asyncio.get_event_loop().time()\n                    }\n                \n                # Clean up completed executions\n                completed_executions = []\n                for exec_id, execution in self.active_executions.items():\n                    if execution[\"task\"].done():\n                        completed_executions.append(exec_id)\n                \n                for exec_id in completed_executions:\n                    del self.active_executions[exec_id]\n                \n                await asyncio.sleep(1)\n                \n            except Exception as e:\n                logger.error(f\"Error in execution processor: {e}\")\n                await asyncio.sleep(5)\n    \n    async def _execute_opportunity(self, execution_id: str, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute a single arbitrage opportunity\"\"\"\n        try:\n            logger.info(f\"Executing opportunity {opportunity.id} ({execution_id})\")\n            \n            # Get the appropriate service for execution\n            service = self.blockchain_services.get(opportunity.chain)\n            if not service:\n                raise ValueError(f\"No service available for chain: {opportunity.chain}\")\n            \n            # Execute through coordination layer\n            result = await self.execution_coordinator.execute_opportunity(\n                service, opportunity\n            )\n            \n            # Log result\n            if result.success:\n                logger.info(f\"Successfully executed {execution_id}: Profit ${result.profit_usd}\")\n            else:\n                logger.warning(f\"Failed to execute {execution_id}: {result.error}\")\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error executing opportunity {execution_id}: {e}\")\n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n    \n    async def _health_monitor(self) -> None:\n        \"\"\"Monitor system health and service status\"\"\"\n        logger.info(\"Starting health monitor...\")\n        \n        while self.is_running:\n            try:\n                # Check each service health\n                for chain_name, service in self.blockchain_services.items():\n                    try:\n                        # Ping service for health check\n                        health = await service.get_health_status()\n                        \n                        if health.get(\"status\") == \"healthy\":\n                            if self.chain_status[chain_name] == ChainStatus.ERROR:\n                                logger.info(f\"{chain_name} service recovered\")\n                            self.chain_status[chain_name] = ChainStatus.ACTIVE\n                        else:\n                            self.chain_status[chain_name] = ChainStatus.ERROR\n                            logger.warning(f\"{chain_name} service unhealthy: {health}\")\n                            \n                    except Exception as e:\n                        logger.error(f\"Health check failed for {chain_name}: {e}\")\n                        self.chain_status[chain_name] = ChainStatus.ERROR\n                \n                await asyncio.sleep(self.config[\"health_check_interval\"])\n                \n            except Exception as e:\n                logger.error(f\"Error in health monitor: {e}\")\n                await asyncio.sleep(30)\n    \n    async def get_system_status(self) -> SystemHealth:\n        \"\"\"Get current system health and status\"\"\"\n        active_chains = [\n            chain for chain, status in self.chain_status.items() \n            if status == ChainStatus.ACTIVE\n        ]\n        \n        inactive_chains = [\n            chain for chain, status in self.chain_status.items() \n            if status != ChainStatus.ACTIVE\n        ]\n        \n        return SystemHealth(\n            overall_status=\"healthy\" if active_chains else \"degraded\",\n            active_chains=active_chains,\n            inactive_chains=inactive_chains,\n            total_opportunities=len(self.execution_queue),\n            execution_success_rate=await self._calculate_success_rate(),\n            last_updated=str(asyncio.get_event_loop().time())\n        )\n    \n    async def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate recent execution success rate\"\"\"\n        # This would track execution history\n        return 85.5  # Placeholder\n    \n    async def get_opportunities(self, chain: Optional[str] = None) -> List[ArbitrageOpportunity]:\n        \"\"\"Get current arbitrage opportunities\"\"\"\n        opportunities = self.execution_queue.copy()\n        \n        if chain:\n            opportunities = [op for op in opportunities if op.chain == chain]\n        \n        return opportunities\n    \n    async def force_execution(self, opportunity_id: str) -> ExecutionResult:\n        \"\"\"Force execute a specific opportunity\"\"\"\n        opportunity = next(\n            (op for op in self.execution_queue if op.id == opportunity_id), \n            None\n        )\n        \n        if not opportunity:\n            raise ValueError(f\"Opportunity {opportunity_id} not found\")\n        \n        # Remove from queue and execute immediately\n        self.execution_queue.remove(opportunity)\n        return await self._execute_opportunity(f\"force_{opportunity_id}\", opportunity)\n    \n    async def shutdown(self) -> None:\n        \"\"\"Gracefully shutdown the orchestrator\"\"\"\n        logger.info(\"Shutting down DEX Arbitrage Orchestrator...\")\n        \n        self.is_running = False\n        \n        # Wait for active executions to complete\n        if self.active_executions:\n            logger.info(f\"Waiting for {len(self.active_executions)} active executions...\")\n            for execution in self.active_executions.values():\n                try:\n                    await asyncio.wait_for(execution[\"task\"], timeout=30)\n                except asyncio.TimeoutError:\n                    execution[\"task\"].cancel()\n        \n        # Shutdown blockchain services\n        for chain_name, service in self.blockchain_services.items():\n            try:\n                await service.shutdown()\n                logger.info(f\"Shutdown {chain_name} service\")\n            except Exception as e:\n                logger.error(f\"Error shutting down {chain_name}: {e}\")\n        \n        logger.info(\"DEX Arbitrage Orchestrator shutdown complete\")\n\n# Main entry point\nasync def main():\n    \"\"\"Main orchestrator entry point\"\"\"\n    orchestrator = DEXArbitrageOrchestrator()\n    \n    try:\n        await orchestrator.initialize()\n        \n        # Keep running until interrupted\n        while True:\n            await asyncio.sleep(1)\n            \n    except KeyboardInterrupt:\n        logger.info(\"Received shutdown signal\")\n    except Exception as e:\n        logger.error(f\"Orchestrator error: {e}\")\n    finally:\n        await orchestrator.shutdown()\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    asyncio.run(main())","size_bytes":14454},"dex/orchestrator/opportunity_agregator.py":{"content":"import asyncio\nimport logging\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport json\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, CrossChainOpportunity\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass OpportunityMetrics:\n    total_opportunities: int\n    profitable_opportunities: int\n    average_profit_usd: Decimal\n    max_profit_usd: Decimal\n    average_execution_time: float\n    success_rate: float\n\nclass OpportunityAggregator:\n    \"\"\"Aggregates and filters arbitrage opportunities from multiple chains\"\"\"\n    \n    def __init__(self):\n        self.opportunity_history: List[ArbitrageOpportunity] = []\n        self.cross_chain_opportunities: List[CrossChainOpportunity] = []\n        self.profitability_cache: Dict[str, Decimal] = {}\n        \n        # Configuration\n        self.config = {\n            \"min_profit_threshold_usd\": 50.0,\n            \"max_gas_cost_percentage\": 30.0,  # Max gas cost as % of profit\n            \"min_liquidity_usd\": 10000.0,\n            \"max_price_impact\": 2.0,  # Max 2% price impact\n            \"opportunity_ttl\": 60,  # seconds\n            \"history_retention\": 3600  # 1 hour\n        }\n        \n        # Metrics tracking\n        self.metrics: OpportunityMetrics = OpportunityMetrics(\n            total_opportunities=0,\n            profitable_opportunities=0,\n            average_profit_usd=Decimal(\"0\"),\n            max_profit_usd=Decimal(\"0\"),\n            average_execution_time=0.0,\n            success_rate=0.0\n        )\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize opportunity aggregator\"\"\"\n        logger.info(\"Initializing Opportunity Aggregator...\")\n        \n        # Start background tasks\n        asyncio.create_task(self._cleanup_expired_opportunities())\n        asyncio.create_task(self._cross_chain_analyzer())\n        asyncio.create_task(self._metrics_updater())\n        \n        logger.info(\"Opportunity Aggregator initialized\")\n    \n    async def process_opportunities(\n        self, \n        raw_opportunities: List[ArbitrageOpportunity]\n    ) -> List[ArbitrageOpportunity]:\n        \"\"\"Process and filter raw opportunities\"\"\"\n        try:\n            logger.debug(f\"Processing {len(raw_opportunities)} raw opportunities\")\n            \n            # Filter and validate opportunities\n            filtered_opportunities = []\n            \n            for opportunity in raw_opportunities:\n                if await self._validate_opportunity(opportunity):\n                    # Enhance opportunity with additional data\n                    enhanced_opportunity = await self._enhance_opportunity(opportunity)\n                    if enhanced_opportunity:\n                        filtered_opportunities.append(enhanced_opportunity)\n            \n            # Sort by profitability\n            filtered_opportunities.sort(\n                key=lambda x: x.profit_usd, \n                reverse=True\n            )\n            \n            # Update history and cache\n            self.opportunity_history.extend(filtered_opportunities)\n            await self._update_profitability_cache(filtered_opportunities)\n            \n            logger.info(f\"Processed {len(filtered_opportunities)} profitable opportunities\")\n            return filtered_opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error processing opportunities: {e}\")\n            return []\n    \n    async def _validate_opportunity(self, opportunity: ArbitrageOpportunity) -> bool:\n        \"\"\"Validate if opportunity meets criteria\"\"\"\n        try:\n            # Check minimum profit threshold\n            if opportunity.profit_usd < Decimal(str(self.config[\"min_profit_threshold_usd\"])):\n                return False\n            \n            # Check gas cost ratio\n            if opportunity.gas_cost_usd > 0:\n                gas_percentage = (opportunity.gas_cost_usd / opportunity.profit_usd) * 100\n                if gas_percentage > self.config[\"max_gas_cost_percentage\"]:\n                    return False\n            \n            # Check liquidity requirements\n            if opportunity.total_liquidity_usd < Decimal(str(self.config[\"min_liquidity_usd\"])):\n                return False\n            \n            # Check price impact\n            if opportunity.price_impact > self.config[\"max_price_impact\"]:\n                return False\n            \n            # Check opportunity freshness\n            if hasattr(opportunity, 'timestamp'):\n                age_seconds = (datetime.now() - opportunity.timestamp).total_seconds()\n                if age_seconds > self.config[\"opportunity_ttl\"]:\n                    return False\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error validating opportunity: {e}\")\n            return False\n    \n    async def _enhance_opportunity(\n        self, \n        opportunity: ArbitrageOpportunity\n    ) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Enhance opportunity with additional data\"\"\"\n        try:\n            # Calculate risk score\n            risk_score = await self._calculate_risk_score(opportunity)\n            opportunity.risk_score = risk_score\n            \n            # Calculate execution priority\n            priority = await self._calculate_priority(opportunity)\n            opportunity.priority = priority\n            \n            # Add profitability confidence\n            confidence = await self._calculate_confidence(opportunity)\n            opportunity.confidence = confidence\n            \n            return opportunity\n            \n        except Exception as e:\n            logger.error(f\"Error enhancing opportunity: {e}\")\n            return opportunity\n    \n    async def _calculate_risk_score(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Calculate risk score for opportunity (0-100, lower is better)\"\"\"\n        risk_factors = []\n        \n        # Gas cost risk\n        if opportunity.gas_cost_usd > 0:\n            gas_ratio = float(opportunity.gas_cost_usd / opportunity.profit_usd)\n            risk_factors.append(gas_ratio * 30)  # Weight: 30\n        \n        # Price impact risk\n        risk_factors.append(opportunity.price_impact * 10)  # Weight: 10\n        \n        # Liquidity risk\n        if opportunity.total_liquidity_usd > 0:\n            liquidity_score = min(50000, float(opportunity.total_liquidity_usd)) / 50000\n            risk_factors.append((1 - liquidity_score) * 20)  # Weight: 20\n        \n        # Chain congestion risk (placeholder)\n        chain_risk = 10  # Would be calculated based on network conditions\n        risk_factors.append(chain_risk)\n        \n        return min(100, sum(risk_factors))\n    \n    async def _calculate_priority(self, opportunity: ArbitrageOpportunity) -> int:\n        \"\"\"Calculate execution priority (1-10, higher is better)\"\"\"\n        # Base priority on profit\n        profit_score = min(10, float(opportunity.profit_usd) / 100)\n        \n        # Adjust for risk\n        risk_adjustment = (100 - opportunity.risk_score) / 100\n        \n        # Adjust for confidence\n        confidence_adjustment = opportunity.confidence / 100\n        \n        priority = profit_score * risk_adjustment * confidence_adjustment\n        return max(1, min(10, int(priority * 10)))\n    \n    async def _calculate_confidence(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Calculate confidence in opportunity (0-100)\"\"\"\n        confidence_factors = []\n        \n        # Historical success rate for similar opportunities\n        historical_success = await self._get_historical_success_rate(opportunity)\n        confidence_factors.append(historical_success * 0.4)\n        \n        # Liquidity depth confidence\n        liquidity_confidence = min(100, float(opportunity.total_liquidity_usd) / 100000 * 100)\n        confidence_factors.append(liquidity_confidence * 0.3)\n        \n        # Gas price stability\n        gas_confidence = 80  # Would be calculated based on gas price volatility\n        confidence_factors.append(gas_confidence * 0.2)\n        \n        # Market conditions\n        market_confidence = 75  # Would be calculated based on market volatility\n        confidence_factors.append(market_confidence * 0.1)\n        \n        return sum(confidence_factors)\n    \n    async def _get_historical_success_rate(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Get historical success rate for similar opportunities\"\"\"\n        # This would analyze historical data\n        # For now, return a reasonable default\n        return 85.0\n    \n    async def _update_profitability_cache(\n        self, \n        opportunities: List[ArbitrageOpportunity]\n    ) -> None:\n        \"\"\"Update profitability cache for fast lookups\"\"\"\n        for opportunity in opportunities:\n            cache_key = f\"{opportunity.chain}_{opportunity.type}_{opportunity.token_a}_{opportunity.token_b}\"\n            self.profitability_cache[cache_key] = opportunity.profit_usd\n    \n    async def _cleanup_expired_opportunities(self) -> None:\n        \"\"\"Clean up expired opportunities from history\"\"\"\n        while True:\n            try:\n                cutoff_time = datetime.now() - timedelta(seconds=self.config[\"history_retention\"])\n                \n                # Clean up history\n                self.opportunity_history = [\n                    op for op in self.opportunity_history\n                    if hasattr(op, 'timestamp') and op.timestamp > cutoff_time\n                ]\n                \n                # Clean up cache\n                expired_keys = []\n                for key in self.profitability_cache.keys():\n                    # Simple expiration logic - would be enhanced with timestamps\n                    if len(self.profitability_cache) > 1000:  # Max cache size\n                        expired_keys.append(key)\n                \n                for key in expired_keys[:100]:  # Remove oldest 100 entries\n                    del self.profitability_cache[key]\n                \n                await asyncio.sleep(300)  # Clean up every 5 minutes\n                \n            except Exception as e:\n                logger.error(f\"Error in cleanup task: {e}\")\n                await asyncio.sleep(300)\n    \n    async def _cross_chain_analyzer(self) -> None:\n        \"\"\"Analyze cross-chain arbitrage opportunities\"\"\"\n        while True:\n            try:\n                # Look for arbitrage opportunities across different chains\n                # This would compare prices between Ethereum, BSC, Polygon, etc.\n                \n                # Group opportunities by token pair\n                token_pairs = {}\n                for opportunity in self.opportunity_history[-100:]:  # Recent opportunities\n                    pair_key = f\"{opportunity.token_a}_{opportunity.token_b}\"\n                    if pair_key not in token_pairs:\n                        token_pairs[pair_key] = []\n                    token_pairs[pair_key].append(opportunity)\n                \n                # Find cross-chain opportunities\n                for pair_key, opportunities in token_pairs.items():\n                    if len(opportunities) > 1:\n                        # Check for price differences across chains\n                        chain_prices = {}\n                        for op in opportunities:\n                            if op.chain not in chain_prices:\n                                chain_prices[op.chain] = []\n                            chain_prices[op.chain].append(op.price_difference)\n                        \n                        # If we have multiple chains for the same pair\n                        if len(chain_prices) > 1:\n                            await self._create_cross_chain_opportunity(pair_key, chain_prices)\n                \n                await asyncio.sleep(60)  # Analyze every minute\n                \n            except Exception as e:\n                logger.error(f\"Error in cross-chain analyzer: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _create_cross_chain_opportunity(\n        self, \n        pair_key: str, \n        chain_prices: Dict[str, List[Decimal]]\n    ) -> None:\n        \"\"\"Create cross-chain arbitrage opportunity\"\"\"\n        try:\n            # Find the chains with highest and lowest prices\n            avg_prices = {\n                chain: sum(prices) / len(prices) \n                for chain, prices in chain_prices.items()\n            }\n            \n            min_chain = min(avg_prices, key=avg_prices.get)\n            max_chain = max(avg_prices, key=avg_prices.get)\n            \n            price_diff = avg_prices[max_chain] - avg_prices[min_chain]\n            \n            # If price difference is significant\n            if price_diff > Decimal(\"0.01\"):  # 1% difference\n                cross_chain_op = CrossChainOpportunity(\n                    id=f\"cross_{pair_key}_{datetime.now().timestamp()}\",\n                    buy_chain=min_chain,\n                    sell_chain=max_chain,\n                    token_pair=pair_key,\n                    price_difference=price_diff,\n                    estimated_profit=price_diff * Decimal(\"1000\"),  # Assuming $1000 trade\n                    confidence=75.0,\n                    timestamp=datetime.now()\n                )\n                \n                self.cross_chain_opportunities.append(cross_chain_op)\n                logger.info(f\"Found cross-chain opportunity: {cross_chain_op.id}\")\n        \n        except Exception as e:\n            logger.error(f\"Error creating cross-chain opportunity: {e}\")\n    \n    async def _metrics_updater(self) -> None:\n        \"\"\"Update aggregator metrics\"\"\"\n        while True:\n            try:\n                if self.opportunity_history:\n                    profitable_ops = [\n                        op for op in self.opportunity_history \n                        if op.profit_usd > 0\n                    ]\n                    \n                    self.metrics.total_opportunities = len(self.opportunity_history)\n                    self.metrics.profitable_opportunities = len(profitable_ops)\n                    \n                    if profitable_ops:\n                        profits = [float(op.profit_usd) for op in profitable_ops]\n                        self.metrics.average_profit_usd = Decimal(str(sum(profits) / len(profits)))\n                        self.metrics.max_profit_usd = Decimal(str(max(profits)))\n                    \n                    self.metrics.success_rate = (\n                        len(profitable_ops) / len(self.opportunity_history) * 100\n                        if self.opportunity_history else 0\n                    )\n                \n                await asyncio.sleep(30)  # Update every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error updating metrics: {e}\")\n                await asyncio.sleep(30)\n    \n    async def get_metrics(self) -> OpportunityMetrics:\n        \"\"\"Get current aggregator metrics\"\"\"\n        return self.metrics\n    \n    async def get_cross_chain_opportunities(self) -> List[CrossChainOpportunity]:\n        \"\"\"Get current cross-chain opportunities\"\"\"\n        return self.cross_chain_opportunities.copy()\n    \n    async def get_opportunity_history(\n        self, \n        limit: int = 100, \n        chain: Optional[str] = None\n    ) -> List[ArbitrageOpportunity]:\n        \"\"\"Get recent opportunity history\"\"\"\n        history = self.opportunity_history[-limit:] if limit else self.opportunity_history\n        \n        if chain:\n            history = [op for op in history if op.chain == chain]\n        \n        return history","size_bytes":15787},"dex/orchestrator/risk_manager.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport json\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity\n\nlogger = logging.getLogger(__name__)\n\nclass RiskLevel(Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\n@dataclass\nclass RiskAssessment:\n    opportunity_id: str\n    overall_risk: RiskLevel\n    risk_score: float  # 0-100\n    risk_factors: Dict[str, float]\n    recommendations: List[str]\n    max_position_size: Decimal\n    confidence_level: float\n\n@dataclass\nclass PortfolioLimits:\n    max_single_trade_usd: Decimal\n    max_daily_volume_usd: Decimal\n    max_gas_cost_percentage: float\n    max_slippage_tolerance: float\n    max_concurrent_trades: int\n    min_liquidity_ratio: float\n\nclass RiskManager:\n    \"\"\"Comprehensive risk management for DEX arbitrage operations\"\"\"\n    \n    def __init__(self):\n        # Risk configuration\n        self.limits = PortfolioLimits(\n            max_single_trade_usd=Decimal(\"5000\"),\n            max_daily_volume_usd=Decimal(\"50000\"),\n            max_gas_cost_percentage=25.0,  # 25% of profit\n            max_slippage_tolerance=2.0,    # 2%\n            max_concurrent_trades=3,\n            min_liquidity_ratio=5.0        # Trade size should be <20% of liquidity\n        )\n        \n        # Risk tracking\n        self.daily_volume: Dict[str, Decimal] = {}  # chain -> volume\n        self.active_trades: Dict[str, ArbitrageOpportunity] = {}\n        self.risk_history: List[RiskAssessment] = []\n        self.blacklisted_tokens: List[str] = []\n        self.blacklisted_exchanges: List[str] = []\n        \n        # Market conditions\n        self.market_volatility: Dict[str, float] = {}  # token -> volatility\n        self.gas_price_trends: Dict[str, List[Tuple[datetime, float]]] = {}\n        self.network_congestion: Dict[str, float] = {}  # chain -> congestion level\n        \n        # Performance tracking\n        self.success_rates: Dict[str, float] = {}  # opportunity_type -> success_rate\n        self.profit_distributions: Dict[str, List[Decimal]] = {}\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize risk manager\"\"\"\n        logger.info(\"Initializing Risk Manager...\")\n        \n        # Start background risk monitoring\n        asyncio.create_task(self._market_monitor())\n        asyncio.create_task(self._volatility_tracker())\n        asyncio.create_task(self._daily_reset())\n        \n        # Load risk configuration from environment\n        await self._load_risk_configuration()\n        \n        logger.info(\"Risk Manager initialized\")\n    \n    async def validate_opportunity(self, opportunity: ArbitrageOpportunity) -> bool:\n        \"\"\"Validate if opportunity passes risk checks\"\"\"\n        try:\n            # Perform comprehensive risk assessment\n            assessment = await self.assess_opportunity_risk(opportunity)\n            \n            # Check if risk level is acceptable\n            if assessment.overall_risk == RiskLevel.CRITICAL:\n                logger.warning(f\"Rejecting opportunity {opportunity.id}: Critical risk level\")\n                return False\n            \n            # Check position size limits\n            if not await self._check_position_limits(opportunity):\n                logger.warning(f\"Rejecting opportunity {opportunity.id}: Position size limits\")\n                return False\n            \n            # Check daily volume limits\n            if not await self._check_daily_limits(opportunity):\n                logger.warning(f\"Rejecting opportunity {opportunity.id}: Daily volume limits\")\n                return False\n            \n            # Check concurrent trade limits\n            if len(self.active_trades) >= self.limits.max_concurrent_trades:\n                logger.warning(f\"Rejecting opportunity {opportunity.id}: Max concurrent trades\")\n                return False\n            \n            # Check blacklists\n            if await self._is_blacklisted(opportunity):\n                logger.warning(f\"Rejecting opportunity {opportunity.id}: Blacklisted asset/exchange\")\n                return False\n            \n            # Store assessment for tracking\n            self.risk_history.append(assessment)\n            \n            logger.info(f\"Opportunity {opportunity.id} passed risk validation (Risk: {assessment.overall_risk.value}, Score: {assessment.risk_score})\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error validating opportunity risk: {e}\")\n            return False\n    \n    async def assess_opportunity_risk(self, opportunity: ArbitrageOpportunity) -> RiskAssessment:\n        \"\"\"Comprehensive risk assessment for opportunity\"\"\"\n        try:\n            risk_factors = {}\n            \n            # 1. Profit Risk Assessment\n            profit_risk = await self._assess_profit_risk(opportunity)\n            risk_factors[\"profit_risk\"] = profit_risk\n            \n            # 2. Liquidity Risk Assessment\n            liquidity_risk = await self._assess_liquidity_risk(opportunity)\n            risk_factors[\"liquidity_risk\"] = liquidity_risk\n            \n            # 3. Gas Cost Risk Assessment\n            gas_risk = await self._assess_gas_risk(opportunity)\n            risk_factors[\"gas_risk\"] = gas_risk\n            \n            # 4. Market Risk Assessment\n            market_risk = await self._assess_market_risk(opportunity)\n            risk_factors[\"market_risk\"] = market_risk\n            \n            # 5. Technical Risk Assessment\n            technical_risk = await self._assess_technical_risk(opportunity)\n            risk_factors[\"technical_risk\"] = technical_risk\n            \n            # 6. Execution Risk Assessment\n            execution_risk = await self._assess_execution_risk(opportunity)\n            risk_factors[\"execution_risk\"] = execution_risk\n            \n            # Calculate overall risk score (weighted average)\n            weights = {\n                \"profit_risk\": 0.25,\n                \"liquidity_risk\": 0.20,\n                \"gas_risk\": 0.15,\n                \"market_risk\": 0.15,\n                \"technical_risk\": 0.15,\n                \"execution_risk\": 0.10\n            }\n            \n            overall_score = sum(\n                risk_factors[factor] * weights[factor] \n                for factor in weights.keys()\n            )\n            \n            # Determine risk level\n            if overall_score < 25:\n                risk_level = RiskLevel.LOW\n            elif overall_score < 50:\n                risk_level = RiskLevel.MEDIUM\n            elif overall_score < 75:\n                risk_level = RiskLevel.HIGH\n            else:\n                risk_level = RiskLevel.CRITICAL\n            \n            # Generate recommendations\n            recommendations = await self._generate_recommendations(risk_factors, opportunity)\n            \n            # Calculate max position size based on risk\n            max_position = await self._calculate_max_position_size(opportunity, overall_score)\n            \n            # Calculate confidence level\n            confidence = await self._calculate_confidence(opportunity, risk_factors)\n            \n            return RiskAssessment(\n                opportunity_id=opportunity.id,\n                overall_risk=risk_level,\n                risk_score=overall_score,\n                risk_factors=risk_factors,\n                recommendations=recommendations,\n                max_position_size=max_position,\n                confidence_level=confidence\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error assessing opportunity risk: {e}\")\n            # Return high-risk assessment on error\n            return RiskAssessment(\n                opportunity_id=opportunity.id,\n                overall_risk=RiskLevel.CRITICAL,\n                risk_score=100.0,\n                risk_factors={\"error\": 100.0},\n                recommendations=[\"Manual review required due to assessment error\"],\n                max_position_size=Decimal(\"0\"),\n                confidence_level=0.0\n            )\n    \n    async def _assess_profit_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess profit-related risks\"\"\"\n        risk_score = 0.0\n        \n        # Check profit margin\n        if opportunity.profit_usd < Decimal(\"10\"):\n            risk_score += 30  # Low profit, high risk\n        elif opportunity.profit_usd < Decimal(\"50\"):\n            risk_score += 15  # Medium profit\n        \n        # Check profit-to-investment ratio\n        if hasattr(opportunity, 'amount_in') and opportunity.amount_in > 0:\n            profit_ratio = float(opportunity.profit_usd / (opportunity.amount_in * Decimal(\"0.01\")))  # Assume 1% of amount_in as reference\n            if profit_ratio < 2.0:  # Less than 2% profit margin\n                risk_score += 25\n        \n        return min(100, risk_score)\n    \n    async def _assess_liquidity_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess liquidity-related risks\"\"\"\n        risk_score = 0.0\n        \n        # Check total liquidity\n        if opportunity.total_liquidity_usd < Decimal(\"10000\"):\n            risk_score += 40  # Very low liquidity\n        elif opportunity.total_liquidity_usd < Decimal(\"50000\"):\n            risk_score += 20  # Low liquidity\n        \n        # Check liquidity ratio (trade size vs available liquidity)\n        if hasattr(opportunity, 'amount_in') and opportunity.amount_in > 0:\n            if opportunity.total_liquidity_usd > 0:\n                liquidity_ratio = float(opportunity.amount_in / opportunity.total_liquidity_usd) * 100\n                if liquidity_ratio > 20:  # Trade is >20% of liquidity\n                    risk_score += 30\n                elif liquidity_ratio > 10:  # Trade is >10% of liquidity\n                    risk_score += 15\n        \n        return min(100, risk_score)\n    \n    async def _assess_gas_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess gas cost risks\"\"\"\n        risk_score = 0.0\n        \n        # Check gas cost as percentage of profit\n        if opportunity.gas_cost_usd > 0 and opportunity.profit_usd > 0:\n            gas_percentage = float(opportunity.gas_cost_usd / opportunity.profit_usd) * 100\n            \n            if gas_percentage > 50:  # Gas cost >50% of profit\n                risk_score += 50\n            elif gas_percentage > 30:  # Gas cost >30% of profit\n                risk_score += 30\n            elif gas_percentage > 15:  # Gas cost >15% of profit\n                risk_score += 15\n        \n        # Check absolute gas cost\n        if opportunity.gas_cost_usd > Decimal(\"100\"):\n            risk_score += 20  # High absolute gas cost\n        \n        return min(100, risk_score)\n    \n    async def _assess_market_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess market condition risks\"\"\"\n        risk_score = 0.0\n        \n        # Check token volatility\n        tokens = [opportunity.token_a, opportunity.token_b]\n        if hasattr(opportunity, 'token_c'):\n            tokens.append(opportunity.token_c)\n        \n        for token in tokens:\n            volatility = self.market_volatility.get(token, 0.1)  # Default 10% volatility\n            if volatility > 0.3:  # >30% volatility\n                risk_score += 20\n            elif volatility > 0.2:  # >20% volatility\n                risk_score += 10\n        \n        # Check network congestion\n        chain_congestion = self.network_congestion.get(opportunity.chain, 0.5)\n        if chain_congestion > 0.8:  # High congestion\n            risk_score += 25\n        elif chain_congestion > 0.6:  # Medium congestion\n            risk_score += 10\n        \n        return min(100, risk_score)\n    \n    async def _assess_technical_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess technical execution risks\"\"\"\n        risk_score = 0.0\n        \n        # Check price impact\n        if opportunity.price_impact > 5.0:  # >5% price impact\n            risk_score += 40\n        elif opportunity.price_impact > 2.0:  # >2% price impact\n            risk_score += 20\n        \n        # Check execution complexity\n        if opportunity.type == \"triangular\":\n            risk_score += 15  # More complex than simple swaps\n        elif opportunity.type == \"flash_loan\":\n            risk_score += 25  # Most complex execution\n        \n        return min(100, risk_score)\n    \n    async def _assess_execution_risk(self, opportunity: ArbitrageOpportunity) -> float:\n        \"\"\"Assess execution-specific risks\"\"\"\n        risk_score = 0.0\n        \n        # Check historical success rate for similar opportunities\n        opportunity_type = f\"{opportunity.chain}_{opportunity.type}\"\n        historical_success = self.success_rates.get(opportunity_type, 0.8)  # Default 80%\n        \n        if historical_success < 0.5:  # <50% success rate\n            risk_score += 40\n        elif historical_success < 0.7:  # <70% success rate\n            risk_score += 20\n        \n        # Check opportunity age (if available)\n        if hasattr(opportunity, 'timestamp'):\n            age_seconds = (datetime.now() - opportunity.timestamp).total_seconds()\n            if age_seconds > 30:  # Opportunity older than 30 seconds\n                risk_score += 15\n        \n        return min(100, risk_score)\n    \n    async def _generate_recommendations(\n        self, \n        risk_factors: Dict[str, float], \n        opportunity: ArbitrageOpportunity\n    ) -> List[str]:\n        \"\"\"Generate risk mitigation recommendations\"\"\"\n        recommendations = []\n        \n        if risk_factors.get(\"profit_risk\", 0) > 20:\n            recommendations.append(\"Consider increasing trade size for better profit margins\")\n        \n        if risk_factors.get(\"liquidity_risk\", 0) > 30:\n            recommendations.append(\"Reduce trade size due to low liquidity\")\n        \n        if risk_factors.get(\"gas_risk\", 0) > 25:\n            recommendations.append(\"Monitor gas prices and consider delaying execution\")\n        \n        if risk_factors.get(\"market_risk\", 0) > 30:\n            recommendations.append(\"High market volatility - consider reduced position size\")\n        \n        if risk_factors.get(\"technical_risk\", 0) > 30:\n            recommendations.append(\"High price impact detected - use smaller trade size\")\n        \n        if risk_factors.get(\"execution_risk\", 0) > 25:\n            recommendations.append(\"Low historical success rate - proceed with caution\")\n        \n        return recommendations\n    \n    async def _calculate_max_position_size(\n        self, \n        opportunity: ArbitrageOpportunity, \n        risk_score: float\n    ) -> Decimal:\n        \"\"\"Calculate maximum recommended position size\"\"\"\n        # Base position size (from config)\n        base_size = self.limits.max_single_trade_usd\n        \n        # Risk-based adjustment\n        risk_multiplier = max(0.1, (100 - risk_score) / 100)\n        \n        # Liquidity-based adjustment\n        liquidity_multiplier = min(1.0, float(opportunity.total_liquidity_usd) / 100000)\n        \n        max_size = base_size * Decimal(str(risk_multiplier)) * Decimal(str(liquidity_multiplier))\n        \n        return max_size\n    \n    async def _calculate_confidence(\n        self, \n        opportunity: ArbitrageOpportunity, \n        risk_factors: Dict[str, float]\n    ) -> float:\n        \"\"\"Calculate confidence level in the opportunity\"\"\"\n        # Base confidence starts at 100\n        confidence = 100.0\n        \n        # Reduce confidence based on risk factors\n        for factor, score in risk_factors.items():\n            confidence -= score * 0.1  # Each risk point reduces confidence\n        \n        # Adjust based on historical performance\n        opportunity_type = f\"{opportunity.chain}_{opportunity.type}\"\n        historical_success = self.success_rates.get(opportunity_type, 0.8)\n        confidence *= historical_success\n        \n        return max(0.0, min(100.0, confidence))\n    \n    async def _check_position_limits(self, opportunity: ArbitrageOpportunity) -> bool:\n        \"\"\"Check if opportunity respects position size limits\"\"\"\n        if hasattr(opportunity, 'amount_in'):\n            # Convert to USD value (simplified)\n            trade_value_usd = opportunity.amount_in * Decimal(\"1000\")  # Placeholder conversion\n            \n            return trade_value_usd <= self.limits.max_single_trade_usd\n        \n        return True  # Allow if we can't determine size\n    \n    async def _check_daily_limits(self, opportunity: ArbitrageOpportunity) -> bool:\n        \"\"\"Check daily volume limits\"\"\"\n        today = datetime.now().date().isoformat()\n        chain_key = f\"{opportunity.chain}_{today}\"\n        \n        current_volume = self.daily_volume.get(chain_key, Decimal(\"0\"))\n        \n        if hasattr(opportunity, 'amount_in'):\n            trade_value_usd = opportunity.amount_in * Decimal(\"1000\")  # Placeholder conversion\n            \n            return current_volume + trade_value_usd <= self.limits.max_daily_volume_usd\n        \n        return True\n    \n    async def _is_blacklisted(self, opportunity: ArbitrageOpportunity) -> bool:\n        \"\"\"Check if opportunity involves blacklisted assets or exchanges\"\"\"\n        # Check tokens\n        tokens = [opportunity.token_a, opportunity.token_b]\n        if hasattr(opportunity, 'token_c'):\n            tokens.append(opportunity.token_c)\n        \n        for token in tokens:\n            if token in self.blacklisted_tokens:\n                return True\n        \n        # Check exchanges\n        exchanges = [opportunity.exchange_a]\n        if hasattr(opportunity, 'exchange_b'):\n            exchanges.append(opportunity.exchange_b)\n        \n        for exchange in exchanges:\n            if exchange in self.blacklisted_exchanges:\n                return True\n        \n        return False\n    \n    async def _load_risk_configuration(self) -> None:\n        \"\"\"Load risk configuration from environment or config file\"\"\"\n        # This would load from environment variables or config files\n        # For now, using defaults\n        logger.info(\"Using default risk configuration\")\n    \n    async def _market_monitor(self) -> None:\n        \"\"\"Monitor market conditions\"\"\"\n        while True:\n            try:\n                # Update market volatility data\n                # This would fetch real volatility data from price feeds\n                \n                # Update network congestion\n                # This would check network stats\n                \n                await asyncio.sleep(60)  # Update every minute\n                \n            except Exception as e:\n                logger.error(f\"Error in market monitor: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _volatility_tracker(self) -> None:\n        \"\"\"Track token volatility\"\"\"\n        while True:\n            try:\n                # Calculate volatility for tracked tokens\n                # This would use price history to calculate volatility\n                \n                await asyncio.sleep(300)  # Update every 5 minutes\n                \n            except Exception as e:\n                logger.error(f\"Error in volatility tracker: {e}\")\n                await asyncio.sleep(300)\n    \n    async def _daily_reset(self) -> None:\n        \"\"\"Reset daily tracking data\"\"\"\n        while True:\n            try:\n                # Wait until midnight\n                now = datetime.now()\n                tomorrow = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n                sleep_seconds = (tomorrow - now).total_seconds()\n                \n                await asyncio.sleep(sleep_seconds)\n                \n                # Reset daily volume tracking\n                self.daily_volume.clear()\n                logger.info(\"Reset daily volume tracking\")\n                \n            except Exception as e:\n                logger.error(f\"Error in daily reset: {e}\")\n                await asyncio.sleep(3600)  # Retry in 1 hour\n    \n    async def add_to_blacklist(self, item_type: str, item_value: str) -> None:\n        \"\"\"Add item to blacklist\"\"\"\n        if item_type == \"token\":\n            self.blacklisted_tokens.append(item_value)\n        elif item_type == \"exchange\":\n            self.blacklisted_exchanges.append(item_value)\n        \n        logger.info(f\"Added {item_type} {item_value} to blacklist\")\n    \n    async def remove_from_blacklist(self, item_type: str, item_value: str) -> None:\n        \"\"\"Remove item from blacklist\"\"\"\n        if item_type == \"token\" and item_value in self.blacklisted_tokens:\n            self.blacklisted_tokens.remove(item_value)\n        elif item_type == \"exchange\" and item_value in self.blacklisted_exchanges:\n            self.blacklisted_exchanges.remove(item_value)\n        \n        logger.info(f\"Removed {item_type} {item_value} from blacklist\")\n    \n    async def get_risk_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get current risk metrics\"\"\"\n        return {\n            \"active_trades\": len(self.active_trades),\n            \"daily_volume\": dict(self.daily_volume),\n            \"blacklisted_tokens\": len(self.blacklisted_tokens),\n            \"blacklisted_exchanges\": len(self.blacklisted_exchanges),\n            \"risk_assessments_today\": len([\n                a for a in self.risk_history \n                if hasattr(a, 'timestamp') and \n                a.timestamp.date() == datetime.now().date()\n            ]) if self.risk_history and hasattr(self.risk_history[0], 'timestamp') else 0,\n            \"success_rates\": dict(self.success_rates)\n        }","size_bytes":21836},"dex/polygon_service/__init__.py":{"content":"# Polygon Arbitrage Service","size_bytes":27},"dex/polygon_service/arbitrage.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom datetime import datetime\n\nfrom .engine import PolygonEngine\nfrom .config import PolygonConfig\nfrom .cross_arbitrage import PolygonCrossArbitrageEngine\nfrom .triangular_arbitrage import PolygonTriangularArbitrageEngine\nfrom .flashloan_engine import PolygonFlashLoanEngine\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nlogger = logging.getLogger(__name__)\n\nclass PolygonArbitrageService:\n    \"\"\"Main Polygon arbitrage service coordinating all arbitrage engines\"\"\"\n    \n    def __init__(self, config: PolygonConfig = None):\n        self.config = config or PolygonConfig()\n        self.chain = \"polygon\"\n        self.chain_id = self.config.CHAIN_ID\n        \n        # Core engine\n        self.engine = PolygonEngine(self.config)\n        \n        # Arbitrage engines\n        self.cross_arbitrage = PolygonCrossArbitrageEngine(self.engine, self.config)\n        self.triangular_arbitrage = PolygonTriangularArbitrageEngine(self.engine, self.config)\n        self.flash_loan = PolygonFlashLoanEngine(self.engine, self.config)\n        \n        self.is_initialized = False\n        self.last_health_check = datetime.now()\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize all components\"\"\"\n        try:\n            logger.info(\"Initializing Polygon Arbitrage Service...\")\n            \n            # Initialize core engine\n            await self.engine.initialize()\n            \n            # Initialize arbitrage engines\n            await self.cross_arbitrage.initialize()\n            await self.triangular_arbitrage.initialize()\n            await self.flash_loan.initialize()\n            \n            self.is_initialized = True\n            logger.info(\"Polygon Arbitrage Service initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Polygon Arbitrage Service: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for all types of arbitrage opportunities\"\"\"\n        if not self.is_initialized:\n            logger.warning(\"Polygon Service not initialized\")\n            return []\n        \n        try:\n            all_opportunities = []\n            \n            # Get cross-exchange opportunities\n            cross_ops = await self.cross_arbitrage.scan_opportunities()\n            all_opportunities.extend(cross_ops)\n            \n            # Get triangular arbitrage opportunities\n            triangular_ops = await self.triangular_arbitrage.scan_opportunities()\n            all_opportunities.extend(triangular_ops)\n            \n            # Get flash loan opportunities\n            flash_ops = await self.flash_loan.scan_opportunities()\n            all_opportunities.extend(flash_ops)\n            \n            logger.info(f\"Found {len(all_opportunities)} opportunities on Polygon\")\n            return all_opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Polygon opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute a specific arbitrage opportunity\"\"\"\n        if not self.is_initialized:\n            raise RuntimeError(\"Polygon Service not initialized\")\n        \n        try:\n            logger.info(f\"Executing Polygon opportunity {opportunity.id} of type {opportunity.type}\")\n            \n            if opportunity.type == \"cross_exchange\":\n                return await self.cross_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"triangular\":\n                return await self.triangular_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"flash_loan\":\n                return await self.flash_loan.execute_opportunity(opportunity)\n            else:\n                raise ValueError(f\"Unknown opportunity type: {opportunity.type}\")\n                \n        except Exception as e:\n            logger.error(f\"Error executing Polygon opportunity {opportunity.id}: {e}\")\n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get service health status\"\"\"\n        try:\n            self.last_health_check = datetime.now()\n            \n            # Check engine health\n            engine_health = await self._check_engine_health()\n            \n            # Check component health\n            components_health = await self._check_components_health()\n            \n            overall_healthy = (\n                engine_health[\"status\"] == \"healthy\" and\n                all(comp[\"status\"] == \"healthy\" for comp in components_health.values())\n            )\n            \n            return {\n                \"status\": \"healthy\" if overall_healthy else \"degraded\",\n                \"timestamp\": self.last_health_check.isoformat(),\n                \"chain\": self.chain,\n                \"chain_id\": self.chain_id,\n                \"engine\": engine_health,\n                \"components\": components_health,\n                \"initialized\": self.is_initialized\n            }\n            \n        except Exception as e:\n            logger.error(f\"Polygon Health check failed: {e}\")\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": str(e),\n                \"timestamp\": datetime.now().isoformat()\n            }\n    \n    async def _check_engine_health(self) -> Dict[str, Any]:\n        \"\"\"Check core engine health\"\"\"\n        try:\n            if not self.engine or not self.engine.w3:\n                return {\"status\": \"unhealthy\", \"error\": \"Engine not initialized\"}\n            \n            # Test connection\n            is_connected = await self.engine.w3.is_connected()\n            if not is_connected:\n                return {\"status\": \"unhealthy\", \"error\": \"Web3 connection failed\"}\n            \n            # Test wallet\n            if self.engine.wallet_address:\n                balance = await self.engine.get_balance(\"0x0\")  # MATIC balance\n                return {\n                    \"status\": \"healthy\",\n                    \"wallet_address\": self.engine.wallet_address,\n                    \"matic_balance\": str(balance)\n                }\n            else:\n                return {\"status\": \"degraded\", \"warning\": \"No wallet configured\"}\n                \n        except Exception as e:\n            return {\"status\": \"unhealthy\", \"error\": str(e)}\n    \n    async def _check_components_health(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Check arbitrage components health\"\"\"\n        components = {\n            \"cross_arbitrage\": self.cross_arbitrage,\n            \"triangular_arbitrage\": self.triangular_arbitrage,\n            \"flash_loan\": self.flash_loan\n        }\n        \n        health_status = {}\n        \n        for name, component in components.items():\n            try:\n                if hasattr(component, 'get_health_status'):\n                    health_status[name] = await component.get_health_status()\n                else:\n                    # Basic health check\n                    health_status[name] = {\n                        \"status\": \"healthy\" if hasattr(component, 'initialized') else \"unknown\",\n                        \"initialized\": getattr(component, 'initialized', False)\n                    }\n            except Exception as e:\n                health_status[name] = {\n                    \"status\": \"unhealthy\",\n                    \"error\": str(e)\n                }\n        \n        return health_status\n    \n    async def ping(self) -> bool:\n        \"\"\"Simple ping for heartbeat monitoring\"\"\"\n        try:\n            if not self.is_initialized:\n                return False\n            \n            # Quick Web3 connection test\n            if self.engine and self.engine.w3:\n                return await self.engine.w3.is_connected()\n            \n            return False\n            \n        except Exception:\n            return False\n    \n    async def shutdown(self) -> None:\n        \"\"\"Graceful shutdown\"\"\"\n        try:\n            logger.info(\"Shutting down Polygon Arbitrage Service...\")\n            \n            # Close engine connections\n            if self.engine:\n                await self.engine.shutdown()\n            \n            self.is_initialized = False\n            logger.info(\"Polygon Arbitrage Service shutdown complete\")\n            \n        except Exception as e:\n            logger.error(f\"Error during Polygon shutdown: {e}\")\n    \n    async def restart(self) -> None:\n        \"\"\"Restart the service\"\"\"\n        await self.shutdown()\n        await self.initialize()\n        logger.info(\"Polygon Arbitrage Service restarted\")","size_bytes":9102},"dex/polygon_service/config.py":{"content":"import os\nfrom typing import List, Dict\n\nclass PolygonConfig:\n    # Network Configuration\n    CHAIN_ID = int(os.getenv(\"POLYGON_CHAIN_ID\", \"137\"))  # 137=mainnet, 80001=mumbai testnet\n    RPC_URL = os.getenv(\"POLYGON_RPC_URL\", \"https://polygon-rpc.com/\")\n    WSS_URL = os.getenv(\"POLYGON_WSS_URL\", \"wss://polygon-rpc.com/\")\n    \n    # Wallet Configuration\n    PRIVATE_KEY = os.getenv(\"POLYGON_PRIVATE_KEY\", \"\")\n    WALLET_ADDRESS = os.getenv(\"POLYGON_WALLET_ADDRESS\", \"\")\n    \n    # Gas Configuration (Polygon uses EIP-1559)\n    MAX_FEE_PER_GAS_GWEI = int(os.getenv(\"POLYGON_MAX_FEE_PER_GAS_GWEI\", \"100\"))\n    MAX_PRIORITY_FEE_PER_GAS_GWEI = int(os.getenv(\"POLYGON_MAX_PRIORITY_FEE_GWEI\", \"30\"))\n    GAS_PRICE_MULTIPLIER = float(os.getenv(\"POLYGON_GAS_PRICE_MULTIPLIER\", \"1.1\"))\n    \n    # Trading Configuration\n    MIN_PROFIT_THRESHOLD = float(os.getenv(\"POLYGON_MIN_PROFIT_THRESHOLD\", \"0.3\"))  # %\n    MAX_SLIPPAGE = float(os.getenv(\"POLYGON_MAX_SLIPPAGE\", \"0.5\"))  # %\n    MAX_TRADE_SIZE_MATIC = float(os.getenv(\"POLYGON_MAX_TRADE_SIZE\", \"1000.0\"))\n    \n    # DEX Addresses (Polygon)\n    UNISWAP_V3_ROUTER = \"0xE592427A0AEce92De3Edee1F18E0157C05861564\"\n    UNISWAP_V3_FACTORY = \"0x1F98431c8aD98523631AE4a59f267346ea31F984\"\n    UNISWAP_V3_QUOTER_V2 = \"0x61fFE014bA17989E743c5F6cB21bF9697530B21e\"\n    \n    QUICKSWAP_V2_ROUTER = \"0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff\"\n    QUICKSWAP_V2_FACTORY = \"0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32\"\n    \n    SUSHISWAP_ROUTER = \"0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506\"\n    SUSHISWAP_FACTORY = \"0xc35DADB65012eC5796536bD9864eD8773aBc74C4\"\n    \n    CURVE_REGISTRY = \"0x094d12e5b541784701FD8d65F11fc0598FBC6332\"\n    \n    # Flash Loan Providers (Polygon)\n    AAVE_V3_LENDING_POOL = \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\"\n    AAVE_V3_PRICE_ORACLE = \"0xb023e699F5a33916Ea823A16485e259257cA8Bd1\"\n    \n    # Common Tokens (Polygon addresses)\n    TOKENS = {\n        \"WMATIC\": \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n        \"USDC\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n        \"USDT\": \"0xc2132D05D31c914a87C6611C10748AEb04B58e8F\",\n        \"DAI\": \"0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063\",\n        \"WETH\": \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n        \"WBTC\": \"0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6\",\n        \"QUICK\": \"0x831753DD7087CaC61aB5644b308642cc1c33Dc13\",\n        \"SUSHI\": \"0x0b3F868E0BE5597D5DB7fEB59E1CADBb0fdDa50a\",\n        \"CRV\": \"0x172370d5Cd63279eFa6d502DAB29171933a610AF\"\n    }\n    \n    # Mempool Configuration\n    MEMPOOL_MONITOR_ENABLED = os.getenv(\"POLYGON_MEMPOOL_MONITOR\", \"False\") == \"True\"\n    MIN_MEV_OPPORTUNITY_USD = float(os.getenv(\"POLYGON_MIN_MEV_OPPORTUNITY\", \"30.0\"))\n    \n    @classmethod\n    def validate(cls):\n        errors = []\n        if not cls.RPC_URL:\n            errors.append(\"POLYGON_RPC_URL not properly configured\")\n        if not cls.PRIVATE_KEY:\n            errors.append(\"POLYGON_PRIVATE_KEY not set\")\n        if errors:\n            raise RuntimeError(f\"Polygon config validation errors: {'; '.join(errors)}\")","size_bytes":3033},"dex/polygon_service/cross_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import PolygonEngine\nfrom .config import PolygonConfig\n\nlogger = logging.getLogger(__name__)\n\nclass PolygonCrossArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"Polygon Cross-exchange arbitrage engine\"\"\"\n    \n    def __init__(self, engine: PolygonEngine, config: PolygonConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Polygon DEX configurations\n        self.dexes = {\n            \"uniswap_v3\": {\n                \"router\": config.UNISWAP_V3_ROUTER,\n                \"factory\": config.UNISWAP_V3_FACTORY,\n                \"quoter\": config.UNISWAP_V3_QUOTER_V2,\n                \"fee_tiers\": [100, 500, 3000, 10000],  # 0.01%, 0.05%, 0.3%, 1%\n                \"type\": \"v3\"\n            },\n            \"quickswap\": {\n                \"router\": config.QUICKSWAP_V2_ROUTER,\n                \"factory\": config.QUICKSWAP_V2_FACTORY,\n                \"fee\": 0.003,  # 0.3%\n                \"type\": \"v2\"\n            },\n            \"sushiswap\": {\n                \"router\": config.SUSHISWAP_ROUTER,\n                \"factory\": config.SUSHISWAP_FACTORY,\n                \"fee\": 0.003,  # 0.3%\n                \"type\": \"v2\"\n            },\n            \"curve\": {\n                \"registry\": config.CURVE_REGISTRY,\n                \"fee\": 0.0004,  # Variable, 0.04% average\n                \"type\": \"curve\"\n            }\n        }\n        \n        # Common trading pairs on Polygon\n        self.trading_pairs = [\n            (config.TOKENS[\"WMATIC\"], config.TOKENS[\"USDC\"]),\n            (config.TOKENS[\"WMATIC\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"WMATIC\"], config.TOKENS[\"DAI\"]),\n            (config.TOKENS[\"WMATIC\"], config.TOKENS[\"WETH\"]),\n            (config.TOKENS[\"WMATIC\"], config.TOKENS[\"WBTC\"]),\n            (config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"USDC\"], config.TOKENS[\"DAI\"]),\n            (config.TOKENS[\"WETH\"], config.TOKENS[\"USDC\"]),\n            (config.TOKENS[\"WBTC\"], config.TOKENS[\"USDC\"])\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize cross arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing Polygon Cross Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"Polygon Cross Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Polygon cross arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for cross-exchange arbitrage opportunities on Polygon\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for token_a, token_b in self.trading_pairs:\n                # Check prices across different DEXes\n                prices = await self._get_prices_across_dexes(token_a, token_b)\n                \n                if len(prices) >= 2:\n                    # Find best buy and sell prices\n                    best_buy = min(prices, key=lambda x: x[\"price\"])\n                    best_sell = max(prices, key=lambda x: x[\"price\"])\n                    \n                    if best_buy[\"dex\"] != best_sell[\"dex\"]:\n                        price_diff = best_sell[\"price\"] - best_buy[\"price\"]\n                        profit_percentage = (price_diff / best_buy[\"price\"]) * 100\n                        \n                        if profit_percentage > self.config.MIN_PROFIT_THRESHOLD:\n                            # Calculate potential profit\n                            trade_amount = Decimal(\"100.0\")  # 100 units of token_a\n                            \n                            profit_usd = await self._calculate_profit(\n                                token_a, token_b, trade_amount,\n                                best_buy, best_sell\n                            )\n                            \n                            if profit_usd > Decimal(\"15\"):  # Minimum $15 profit\n                                opportunity = ArbitrageOpportunity(\n                                    id=f\"polygon_cross_{best_buy['dex']}_{best_sell['dex']}_{datetime.now().timestamp()}\",\n                                    type=\"cross_exchange\",\n                                    chain=\"polygon\",\n                                    token_a=token_a,\n                                    token_b=token_b,\n                                    exchange_a=best_buy[\"dex\"],\n                                    exchange_b=best_sell[\"dex\"],\n                                    price_a=best_buy[\"price\"],\n                                    price_b=best_sell[\"price\"],\n                                    price_difference=price_diff,\n                                    profit_usd=profit_usd,\n                                    gas_cost_usd=await self._estimate_gas_cost(),\n                                    amount_in=trade_amount,\n                                    amount_out=trade_amount * best_sell[\"price\"],\n                                    total_liquidity_usd=await self._estimate_liquidity(token_a, token_b),\n                                    price_impact=await self._estimate_price_impact(trade_amount, best_buy, best_sell),\n                                    timestamp=datetime.now()\n                                )\n                                \n                                opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Polygon cross-arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Polygon cross arbitrage opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute cross-exchange arbitrage on Polygon\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Polygon cross arbitrage: {opportunity.id}\")\n            \n            # Step 1: Buy on exchange A\n            buy_result = await self._execute_buy(\n                opportunity.exchange_a,\n                opportunity.token_a,\n                opportunity.token_b,\n                opportunity.amount_in\n            )\n            \n            if not buy_result[\"success\"]:\n                raise Exception(f\"Buy failed: {buy_result['error']}\")\n            \n            # Step 2: Sell on exchange B\n            sell_result = await self._execute_sell(\n                opportunity.exchange_b,\n                opportunity.token_b,\n                opportunity.token_a,\n                buy_result[\"amount_out\"]\n            )\n            \n            if not sell_result[\"success\"]:\n                raise Exception(f\"Sell failed: {sell_result['error']}\")\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            # Calculate actual profit\n            actual_profit = sell_result[\"amount_out\"] - opportunity.amount_in\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=True,\n                profit_usd=actual_profit * opportunity.price_a,  # Convert to USD\n                gas_cost_usd=buy_result[\"gas_cost\"] + sell_result[\"gas_cost\"],\n                execution_time=execution_time,\n                transaction_hashes=[buy_result[\"tx_hash\"], sell_result[\"tx_hash\"]]\n            )\n            \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Polygon cross arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _get_prices_across_dexes(self, token_a: str, token_b: str) -> List[Dict[str, Any]]:\n        \"\"\"Get prices for token pair across all DEXes\"\"\"\n        prices = []\n        \n        for dex_name, dex_config in self.dexes.items():\n            try:\n                if dex_config[\"type\"] == \"v2\":\n                    price = await self._get_v2_price(token_a, token_b, dex_config)\n                elif dex_config[\"type\"] == \"v3\":\n                    price = await self._get_v3_price(token_a, token_b, dex_config)\n                elif dex_config[\"type\"] == \"curve\":\n                    price = await self._get_curve_price(token_a, token_b, dex_config)\n                \n                if price and price > 0:\n                    prices.append({\n                        \"dex\": dex_name,\n                        \"price\": price,\n                        \"config\": dex_config\n                    })\n                    \n            except Exception as e:\n                logger.debug(f\"Error getting price from {dex_name}: {e}\")\n                continue\n        \n        return prices\n    \n    async def _get_v2_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from V2 DEX\"\"\"\n        try:\n            # Mock price with DEX-specific variations\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.005\") * (hash(dex_config[\"router\"]) % 20 - 10)  # -5% to +5%\n            return base_price * (1 + variation)\n            \n        except Exception as e:\n            logger.debug(f\"Error getting V2 price: {e}\")\n            return None\n    \n    async def _get_v3_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from V3 DEX using quoter\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.003\") * (hash(dex_config[\"quoter\"]) % 20 - 10)  # -3% to +3%\n            return base_price * (1 + variation)\n            \n        except Exception as e:\n            logger.debug(f\"Error getting V3 price: {e}\")\n            return None\n    \n    async def _get_curve_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from Curve (stablecoin pairs mainly)\"\"\"\n        try:\n            # Curve is mainly for stablecoins, should have tight spreads\n            if self._is_stablecoin_pair(token_a, token_b):\n                base_price = Decimal(\"1.0\")  # Near 1:1 for stablecoins\n                variation = Decimal(\"0.001\") * (hash(dex_config[\"registry\"]) % 10 - 5)  # -0.5% to +0.5%\n                return base_price * (1 + variation)\n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error getting Curve price: {e}\")\n            return None\n    \n    def _is_stablecoin_pair(self, token_a: str, token_b: str) -> bool:\n        \"\"\"Check if pair consists of stablecoins\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"],\n            self.config.TOKENS[\"DAI\"]\n        ]\n        return token_a in stablecoins and token_b in stablecoins\n    \n    async def _get_base_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get base price for token pair\"\"\"\n        # Mock base prices for common pairs\n        if token_a == self.config.TOKENS[\"WMATIC\"]:\n            if token_b == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"0.85\")  # MATIC/USDC\n            elif token_b == self.config.TOKENS[\"WETH\"]:\n                return Decimal(\"0.00026\")  # MATIC/WETH\n        elif self._is_stablecoin_pair(token_a, token_b):\n            return Decimal(\"1.0\")  # Stablecoin pairs\n        \n        return Decimal(\"1.0\")  # Default\n    \n    async def _calculate_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        amount: Decimal,\n        buy_data: Dict,\n        sell_data: Dict\n    ) -> Decimal:\n        \"\"\"Calculate expected profit in USD\"\"\"\n        try:\n            buy_cost = amount * buy_data[\"price\"]\n            sell_revenue = amount * sell_data[\"price\"]\n            \n            # Subtract fees\n            buy_fee = buy_cost * Decimal(str(buy_data[\"config\"].get(\"fee\", 0.003)))\n            sell_fee = sell_revenue * Decimal(str(sell_data[\"config\"].get(\"fee\", 0.003)))\n            \n            gross_profit = sell_revenue - buy_cost\n            net_profit = gross_profit - buy_fee - sell_fee\n            \n            # Convert to USD\n            token_price_usd = await self._get_token_price_usd(token_a)\n            return net_profit * token_price_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating Polygon profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        # Mock USD prices\n        prices = {\n            self.config.TOKENS[\"WMATIC\"]: Decimal(\"0.85\"),\n            self.config.TOKENS[\"USDC\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDT\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"DAI\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"WETH\"]: Decimal(\"3200.00\"),\n            self.config.TOKENS[\"WBTC\"]: Decimal(\"65000.00\")\n        }\n        return prices.get(token, Decimal(\"1.00\"))\n    \n    async def _estimate_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for cross arbitrage in USD\"\"\"\n        try:\n            # Polygon gas is very low\n            gas_price_gwei = 30  # 30 Gwei typical\n            gas_used = 200000  # Two swaps\n            \n            matic_price_usd = Decimal(\"0.85\")\n            \n            gas_cost_matic = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_matic * matic_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"0.50\")  # Fallback - very low\n    \n    async def _estimate_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate available liquidity\"\"\"\n        return Decimal(\"500000\")  # $500K mock liquidity\n    \n    async def _estimate_price_impact(\n        self, \n        amount: Decimal, \n        buy_data: Dict, \n        sell_data: Dict\n    ) -> float:\n        \"\"\"Estimate price impact\"\"\"\n        return 0.08  # 0.08% estimated impact\n    \n    async def _execute_buy(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute buy order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing buy on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"0.997\"),  # After fees\n                \"tx_hash\": f\"0x{'polygon_buy' * 7}\",\n                \"gas_cost\": Decimal(\"0.25\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost\": Decimal(\"0\")\n            }\n    \n    async def _execute_sell(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute sell order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing sell on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"1.005\"),  # Favorable rate\n                \"tx_hash\": f\"0x{'polygon_sell' * 7}\",\n                \"gas_cost\": Decimal(\"0.25\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"supported_dexes\": list(self.dexes.keys()),\n            \"trading_pairs\": len(self.trading_pairs)\n        }","size_bytes":16682},"dex/polygon_service/engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional, Union\nfrom web3 import Web3, AsyncWeb3\nfrom web3.exceptions import Web3Exception\nfrom eth_account import Account\nfrom eth_utils import to_wei, from_wei\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseEngine\nfrom models.arbitrage_models import ExecutionResult\n\nfrom .config import PolygonConfig\n\nlogger = logging.getLogger(__name__)\n\nclass PolygonEngine(BaseEngine):\n    \"\"\"Polygon blockchain engine for Web3 operations\"\"\"\n    \n    def __init__(self, config: PolygonConfig):\n        self.config = config\n        self.w3: Optional[AsyncWeb3] = None\n        self.account: Optional[Account] = None\n        self.wallet_address: Optional[str] = None\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize Web3 connection and wallet\"\"\"\n        try:\n            # Initialize Web3 connection\n            self.w3 = AsyncWeb3(AsyncWeb3.AsyncHTTPProvider(self.config.RPC_URL))\n            \n            # Check connection\n            if not await self.w3.is_connected():\n                raise ConnectionError(\"Failed to connect to Polygon RPC\")\n            \n            # Initialize wallet\n            if self.config.PRIVATE_KEY:\n                self.account = Account.from_key(self.config.PRIVATE_KEY)\n                self.wallet_address = self.account.address\n                logger.info(f\"Polygon Wallet initialized: {self.wallet_address}\")\n            \n            # Verify network\n            chain_id = await self.w3.eth.chain_id\n            if chain_id != self.config.CHAIN_ID:\n                logger.warning(f\"Polygon Chain ID mismatch: expected {self.config.CHAIN_ID}, got {chain_id}\")\n            \n            logger.info(f\"Polygon engine initialized on chain {chain_id}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Polygon engine: {e}\")\n            raise\n    \n    async def get_balance(self, token_address: str, wallet_address: str = None) -> Decimal:\n        \"\"\"Get token balance for wallet\"\"\"\n        try:\n            target_wallet = wallet_address or self.wallet_address\n            if not target_wallet:\n                raise ValueError(\"No wallet address provided\")\n            \n            # MATIC balance\n            if token_address.lower() == \"0x0\" or token_address.upper() == \"MATIC\":\n                balance_wei = await self.w3.eth.get_balance(target_wallet)\n                return Decimal(from_wei(balance_wei, 'ether'))\n            else:\n                # ERC20 token balance\n                erc20_abi = [\n                    {\n                        \"constant\": True,\n                        \"inputs\": [{\"name\": \"_owner\", \"type\": \"address\"}],\n                        \"name\": \"balanceOf\",\n                        \"outputs\": [{\"name\": \"balance\", \"type\": \"uint256\"}],\n                        \"type\": \"function\"\n                    },\n                    {\n                        \"constant\": True,\n                        \"inputs\": [],\n                        \"name\": \"decimals\",\n                        \"outputs\": [{\"name\": \"\", \"type\": \"uint8\"}],\n                        \"type\": \"function\"\n                    }\n                ]\n                \n                contract = self.w3.eth.contract(address=Web3.to_checksum_address(token_address), abi=erc20_abi)\n                balance_wei = await contract.functions.balanceOf(target_wallet).call()\n                decimals = await contract.functions.decimals().call()\n                \n                return Decimal(balance_wei) / Decimal(10 ** decimals)\n                \n        except Exception as e:\n            logger.error(f\"Error getting Polygon balance for {token_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_gas_price(self) -> Dict[str, int]:\n        \"\"\"Get current gas price (Polygon uses EIP-1559)\"\"\"\n        try:\n            # Get gas price data\n            latest_block = await self.w3.eth.get_block('latest')\n            base_fee = latest_block.get('baseFeePerGas', to_wei(30, 'gwei'))\n            \n            # Calculate priority fee\n            priority_fee = to_wei(self.config.MAX_PRIORITY_FEE_PER_GAS_GWEI, 'gwei')\n            \n            # Calculate max fee per gas\n            max_fee = base_fee + priority_fee\n            max_fee_cap = to_wei(self.config.MAX_FEE_PER_GAS_GWEI, 'gwei')\n            \n            final_max_fee = min(max_fee, max_fee_cap)\n            \n            return {\n                \"maxFeePerGas\": int(final_max_fee * self.config.GAS_PRICE_MULTIPLIER),\n                \"maxPriorityFeePerGas\": priority_fee,\n                \"type\": \"eip1559\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting Polygon gas price: {e}\")\n            # Fallback to legacy pricing\n            return {\n                \"gasPrice\": to_wei(50, 'gwei'),\n                \"type\": \"legacy\"\n            }\n    \n    async def estimate_gas(self, transaction: Dict[str, Any]) -> int:\n        \"\"\"Estimate gas for transaction\"\"\"\n        try:\n            gas_estimate = await self.w3.eth.estimate_gas(transaction)\n            # Add 20% buffer for Polygon\n            return int(gas_estimate * 1.2)\n            \n        except Exception as e:\n            logger.error(f\"Error estimating Polygon gas: {e}\")\n            return 150000  # Default fallback\n    \n    async def execute_transaction(self, transaction_data: Dict[str, Any]) -> str:\n        \"\"\"Execute transaction on Polygon\"\"\"\n        try:\n            if not self.account or not self.wallet_address:\n                raise ValueError(\"Wallet not initialized\")\n            \n            # Get current nonce\n            nonce = await self.w3.eth.get_transaction_count(self.wallet_address)\n            \n            # Get gas price\n            gas_info = await self.get_gas_price()\n            \n            # Build transaction\n            transaction = {\n                \"to\": transaction_data.get(\"to\"),\n                \"value\": transaction_data.get(\"value\", 0),\n                \"data\": transaction_data.get(\"data\", \"0x\"),\n                \"gas\": transaction_data.get(\"gas\") or await self.estimate_gas(transaction_data),\n                \"nonce\": nonce,\n                \"chainId\": self.config.CHAIN_ID\n            }\n            \n            # Add gas pricing\n            if gas_info[\"type\"] == \"eip1559\":\n                transaction[\"maxFeePerGas\"] = gas_info[\"maxFeePerGas\"]\n                transaction[\"maxPriorityFeePerGas\"] = gas_info[\"maxPriorityFeePerGas\"]\n            else:\n                transaction[\"gasPrice\"] = gas_info[\"gasPrice\"]\n            \n            # Sign transaction\n            signed_txn = self.account.sign_transaction(transaction)\n            \n            # Send transaction\n            tx_hash = await self.w3.eth.send_raw_transaction(signed_txn.rawTransaction)\n            \n            logger.info(f\"Polygon Transaction sent: {tx_hash.hex()}\")\n            return tx_hash.hex()\n            \n        except Exception as e:\n            logger.error(f\"Error executing Polygon transaction: {e}\")\n            raise\n    \n    async def wait_for_transaction_receipt(self, tx_hash: str, timeout: int = 60) -> Dict[str, Any]:\n        \"\"\"Wait for transaction confirmation\"\"\"\n        try:\n            receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=timeout)\n            return {\n                \"success\": receipt.status == 1,\n                \"blockNumber\": receipt.blockNumber,\n                \"gasUsed\": receipt.gasUsed,\n                \"receipt\": receipt\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error waiting for Polygon transaction receipt: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def get_current_block(self) -> int:\n        \"\"\"Get current block number\"\"\"\n        try:\n            return await self.w3.eth.block_number\n        except Exception as e:\n            logger.error(f\"Error getting Polygon block number: {e}\")\n            return 0\n    \n    async def shutdown(self) -> None:\n        \"\"\"Shutdown engine\"\"\"\n        try:\n            if self.w3:\n                # Close any open connections\n                pass\n            logger.info(\"Polygon engine shutdown complete\")\n        except Exception as e:\n            logger.error(f\"Error shutting down Polygon engine: {e}\")","size_bytes":8465},"dex/polygon_service/flashloan_engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import PolygonEngine\nfrom .config import PolygonConfig\n\nlogger = logging.getLogger(__name__)\n\nclass PolygonFlashLoanEngine(BaseArbitrageEngine):\n    \"\"\"Polygon Flash loan arbitrage engine\"\"\"\n    \n    def __init__(self, engine: PolygonEngine, config: PolygonConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Flash loan providers on Polygon\n        self.flash_loan_providers = {\n            \"aave_v3\": {\n                \"address\": config.AAVE_V3_LENDING_POOL,\n                \"fee\": 0.0009,  # 0.09%\n                \"max_amount\": {\n                    config.TOKENS[\"WMATIC\"]: Decimal(\"1000000\"),  # 1M MATIC\n                    config.TOKENS[\"USDC\"]: Decimal(\"10000000\"),   # 10M USDC\n                    config.TOKENS[\"USDT\"]: Decimal(\"10000000\"),   # 10M USDT\n                    config.TOKENS[\"DAI\"]: Decimal(\"10000000\"),    # 10M DAI\n                    config.TOKENS[\"WETH\"]: Decimal(\"5000\"),       # 5K WETH\n                    config.TOKENS[\"WBTC\"]: Decimal(\"500\")         # 500 WBTC\n                }\n            }\n        }\n        \n        # DEX combinations for flash loan arbitrage\n        self.dex_combinations = [\n            (\"uniswap_v3\", \"quickswap\"),\n            (\"uniswap_v3\", \"sushiswap\"),\n            (\"quickswap\", \"sushiswap\"),\n            (\"quickswap\", \"curve\"),  # For stablecoin arbitrage\n            (\"sushiswap\", \"curve\")\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize flash loan engine\"\"\"\n        try:\n            logger.info(\"Initializing Polygon Flash Loan Engine...\")\n            self.initialized = True\n            logger.info(\"Polygon Flash Loan Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Polygon flash loan engine: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for flash loan arbitrage opportunities on Polygon\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            # Check major token pairs for flash loan opportunities\n            major_tokens = [\n                self.config.TOKENS[\"WMATIC\"],\n                self.config.TOKENS[\"USDC\"],\n                self.config.TOKENS[\"USDT\"],\n                self.config.TOKENS[\"DAI\"],\n                self.config.TOKENS[\"WETH\"],\n                self.config.TOKENS[\"WBTC\"]\n            ]\n            \n            for i, token_a in enumerate(major_tokens):\n                for token_b in major_tokens[i+1:]:\n                    for dex_a, dex_b in self.dex_combinations:\n                        opportunity = await self._check_flash_loan_opportunity(\n                            token_a, token_b, dex_a, dex_b\n                        )\n                        if opportunity:\n                            opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Polygon flash loan opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Polygon flash loan opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute flash loan arbitrage on Polygon\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Polygon flash loan arbitrage: {opportunity.id}\")\n            \n            # Select best flash loan provider\n            provider = await self._select_best_provider(\n                opportunity.token_a, \n                opportunity.loan_amount\n            )\n            \n            if not provider:\n                raise Exception(\"No suitable flash loan provider found\")\n            \n            # Execute flash loan arbitrage\n            result = await self._execute_flash_loan_arbitrage(\n                provider,\n                opportunity\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=result[\"profit_usd\"],\n                    gas_cost_usd=result[\"gas_cost_usd\"],\n                    execution_time=execution_time,\n                    transaction_hashes=[result[\"tx_hash\"]]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"gas_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Polygon flash loan execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_flash_loan_opportunity(\n        self, \n        token_a: str, \n        token_b: str, \n        dex_a: str, \n        dex_b: str\n    ) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check for flash loan arbitrage opportunity between two DEXes\"\"\"\n        try:\n            # Get prices on both DEXes\n            price_dex_a = await self._get_dex_price(token_a, token_b, dex_a)\n            price_dex_b = await self._get_dex_price(token_a, token_b, dex_b)\n            \n            if not price_dex_a or not price_dex_b:\n                return None\n            \n            # Determine which direction is profitable\n            if price_dex_b > price_dex_a:\n                buy_dex, sell_dex = dex_a, dex_b\n                buy_price, sell_price = price_dex_a, price_dex_b\n            else:\n                buy_dex, sell_dex = dex_b, dex_a\n                buy_price, sell_price = price_dex_b, price_dex_a\n            \n            price_diff = sell_price - buy_price\n            profit_percentage = (price_diff / buy_price) * 100\n            \n            if profit_percentage > Decimal(\"0.4\"):  # Minimum 0.4% price difference\n                # Calculate optimal loan amount\n                loan_amount = await self._calculate_optimal_loan_amount(\n                    token_a, buy_price, sell_price\n                )\n                \n                if loan_amount > Decimal(\"1000\"):  # Minimum loan amount\n                    # Calculate expected profit\n                    profit_usd = await self._calculate_flash_loan_profit(\n                        token_a, token_b, loan_amount, buy_price, sell_price\n                    )\n                    \n                    if profit_usd > Decimal(\"10\"):  # Minimum $10 profit\n                        return ArbitrageOpportunity(\n                            id=f\"polygon_flash_{buy_dex}_{sell_dex}_{datetime.now().timestamp()}\",\n                            type=\"flash_loan\",\n                            chain=\"polygon\",\n                            token_a=token_a,\n                            token_b=token_b,\n                            exchange_a=buy_dex,\n                            exchange_b=sell_dex,\n                            price_a=buy_price,\n                            price_b=sell_price,\n                            price_difference=price_diff,\n                            profit_usd=profit_usd,\n                            gas_cost_usd=await self._estimate_flash_loan_gas_cost(),\n                            loan_amount=loan_amount,\n                            amount_in=loan_amount,\n                            amount_out=loan_amount * (sell_price / buy_price),\n                            total_liquidity_usd=await self._estimate_dex_liquidity(token_a, token_b),\n                            price_impact=await self._estimate_flash_loan_price_impact(loan_amount),\n                            timestamp=datetime.now()\n                        )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking flash loan opportunity: {e}\")\n            return None\n    \n    async def _get_dex_price(self, token_a: str, token_b: str, dex: str) -> Optional[Decimal]:\n        \"\"\"Get price from specific DEX\"\"\"\n        try:\n            # Get base price for the pair\n            base_price = await self._get_base_price(token_a, token_b)\n            \n            # Apply DEX-specific variations\n            dex_variations = {\n                \"uniswap_v3\": Decimal(\"0.0\"),\n                \"quickswap\": Decimal(\"0.003\"),   # QuickSwap slightly higher\n                \"sushiswap\": Decimal(\"-0.002\"),  # Sushi slightly lower\n                \"curve\": Decimal(\"0.001\")        # Curve tight spreads\n            }\n            \n            variation = dex_variations.get(dex, Decimal(\"0\"))\n            return base_price * (1 + variation)\n            \n        except Exception as e:\n            logger.debug(f\"Error getting {dex} price: {e}\")\n            return None\n    \n    async def _get_base_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get base price for token pair\"\"\"\n        # Mock base prices\n        if token_a == self.config.TOKENS[\"WMATIC\"]:\n            if token_b == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"0.85\")  # MATIC/USDC\n            elif token_b == self.config.TOKENS[\"WETH\"]:\n                return Decimal(\"0.00026\")  # MATIC/ETH\n        elif self._is_stablecoin_pair(token_a, token_b):\n            return Decimal(\"1.001\")  # Stablecoin pairs\n        \n        return Decimal(\"1.0\")  # Default\n    \n    def _is_stablecoin_pair(self, token_a: str, token_b: str) -> bool:\n        \"\"\"Check if pair consists of stablecoins\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"],\n            self.config.TOKENS[\"DAI\"]\n        ]\n        return token_a in stablecoins and token_b in stablecoins\n    \n    async def _calculate_optimal_loan_amount(\n        self, \n        token: str, \n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate optimal flash loan amount\"\"\"\n        try:\n            # Get available liquidity from providers\n            max_available = self.flash_loan_providers[\"aave_v3\"][\"max_amount\"].get(token, Decimal(\"0\"))\n            \n            # Calculate amount that maximizes profit considering slippage\n            price_diff = sell_price - buy_price\n            profit_percentage = price_diff / buy_price\n            \n            # Conservative amount to minimize slippage on Polygon\n            optimal_amount = min(\n                max_available * Decimal(\"0.05\"),  # 5% of max available\n                Decimal(\"10000\")  # Cap at reasonable amount\n            )\n            \n            return optimal_amount\n            \n        except Exception as e:\n            logger.error(f\"Error calculating optimal loan amount: {e}\")\n            return Decimal(\"1000\")  # Fallback\n    \n    async def _calculate_flash_loan_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        loan_amount: Decimal,\n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate expected profit from flash loan arbitrage\"\"\"\n        try:\n            # Calculate revenue from arbitrage\n            bought_amount = loan_amount / buy_price\n            sold_amount = bought_amount * sell_price\n            gross_profit = sold_amount - loan_amount\n            \n            # Subtract flash loan fee (Aave V3: 0.09%)\n            flash_loan_fee = loan_amount * Decimal(\"0.0009\")\n            \n            # Subtract DEX fees (0.3% each)\n            buy_fee = loan_amount * Decimal(\"0.003\")\n            sell_fee = sold_amount * Decimal(\"0.003\")\n            \n            net_profit = gross_profit - flash_loan_fee - buy_fee - sell_fee\n            \n            # Convert to USD\n            token_price_usd = await self._get_token_price_usd(token_a)\n            profit_usd = net_profit * token_price_usd\n            \n            return profit_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating flash loan profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        # Mock USD prices\n        prices = {\n            self.config.TOKENS[\"WMATIC\"]: Decimal(\"0.85\"),\n            self.config.TOKENS[\"USDC\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDT\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"DAI\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"WETH\"]: Decimal(\"3200.00\"),\n            self.config.TOKENS[\"WBTC\"]: Decimal(\"65000.00\")\n        }\n        return prices.get(token, Decimal(\"1.00\"))\n    \n    async def _estimate_flash_loan_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for flash loan arbitrage\"\"\"\n        try:\n            # Polygon gas cost for flash loan + 2 swaps\n            gas_price_gwei = 30\n            gas_used = 400000  # Flash loan with swaps\n            \n            matic_price_usd = Decimal(\"0.85\")\n            \n            gas_cost_matic = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_matic * matic_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"1.0\")  # Fallback - very low on Polygon\n    \n    async def _estimate_dex_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate DEX liquidity\"\"\"\n        return Decimal(\"1000000\")  # $1M mock liquidity\n    \n    async def _estimate_flash_loan_price_impact(self, loan_amount: Decimal) -> float:\n        \"\"\"Estimate price impact from flash loan arbitrage\"\"\"\n        # Lower impact on Polygon due to good liquidity\n        impact_factor = float(loan_amount) / 50000  # Base factor\n        return min(1.5, 0.05 + impact_factor * 0.001)  # Cap at 1.5%\n    \n    async def _select_best_provider(self, token: str, amount: Decimal) -> Optional[Dict]:\n        \"\"\"Select best flash loan provider\"\"\"\n        try:\n            # Only Aave V3 available on Polygon for now\n            provider_data = self.flash_loan_providers[\"aave_v3\"]\n            max_amount = provider_data[\"max_amount\"].get(token, Decimal(\"0\"))\n            \n            if max_amount >= amount:\n                return {\n                    \"name\": \"aave_v3\",\n                    \"data\": provider_data\n                }\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error selecting flash loan provider: {e}\")\n            return None\n    \n    async def _execute_flash_loan_arbitrage(\n        self, \n        provider: Dict, \n        opportunity: ArbitrageOpportunity\n    ) -> Dict[str, Any]:\n        \"\"\"Execute flash loan arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing flash loan arbitrage via {provider['name']}\")\n            \n            # Mock execution\n            # Simulate successful execution\n            profit_usd = opportunity.profit_usd * Decimal(\"0.92\")  # 92% of expected\n            \n            return {\n                \"success\": True,\n                \"profit_usd\": profit_usd,\n                \"gas_cost_usd\": Decimal(\"1.0\"),\n                \"tx_hash\": f\"0x{'polygon_flash' * 8}\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"gas_cost_usd\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"flash_loan_providers\": list(self.flash_loan_providers.keys()),\n            \"dex_combinations\": len(self.dex_combinations)\n        }","size_bytes":16690},"dex/polygon_service/triangular_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import PolygonEngine\nfrom .config import PolygonConfig\n\nlogger = logging.getLogger(__name__)\n\nclass PolygonTriangularArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"Polygon Triangular arbitrage engine\"\"\"\n    \n    def __init__(self, engine: PolygonEngine, config: PolygonConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Triangular arbitrage paths on Polygon\n        self.triangular_paths = [\n            # WMATIC -> USDC -> USDT -> WMATIC\n            [config.TOKENS[\"WMATIC\"], config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"]],\n            # WMATIC -> USDC -> DAI -> WMATIC\n            [config.TOKENS[\"WMATIC\"], config.TOKENS[\"USDC\"], config.TOKENS[\"DAI\"]],\n            # WMATIC -> WETH -> USDC -> WMATIC\n            [config.TOKENS[\"WMATIC\"], config.TOKENS[\"WETH\"], config.TOKENS[\"USDC\"]],\n            # WMATIC -> WBTC -> USDC -> WMATIC\n            [config.TOKENS[\"WMATIC\"], config.TOKENS[\"WBTC\"], config.TOKENS[\"USDC\"]],\n            # USDC -> USDT -> DAI -> USDC (stablecoin triangle)\n            [config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"], config.TOKENS[\"DAI\"]],\n        ]\n        \n        # Primary DEX for triangular arbitrage (QuickSwap)\n        self.primary_dex = {\n            \"router\": config.QUICKSWAP_V2_ROUTER,\n            \"factory\": config.QUICKSWAP_V2_FACTORY,\n            \"fee\": 0.003  # 0.3%\n        }\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize triangular arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing Polygon Triangular Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"Polygon Triangular Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Polygon triangular arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for triangular arbitrage opportunities on Polygon\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for path in self.triangular_paths:\n                opportunity = await self._check_triangular_path(path)\n                if opportunity:\n                    opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Polygon triangular arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Polygon triangular arbitrage: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute triangular arbitrage on Polygon\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Polygon triangular arbitrage: {opportunity.id}\")\n            \n            # Execute the three swaps in sequence\n            result = await self._execute_triangular_swaps(\n                opportunity.token_a,\n                opportunity.token_b, \n                opportunity.token_c,\n                opportunity.amount_in\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                actual_profit = result[\"final_amount\"] - opportunity.amount_in\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=actual_profit * result[\"token_price\"],  # Convert to USD\n                    gas_cost_usd=result[\"total_gas_cost\"],\n                    execution_time=execution_time,\n                    transaction_hashes=result[\"tx_hashes\"]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"total_gas_cost\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Polygon triangular arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_triangular_path(self, path: List[str]) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check if a triangular path is profitable\"\"\"\n        try:\n            token_a, token_b, token_c = path\n            start_amount = Decimal(\"1000.0\")  # 1000 units of token_a\n            \n            # Get exchange rates for each step\n            rate_ab = await self._get_exchange_rate(token_a, token_b)\n            rate_bc = await self._get_exchange_rate(token_b, token_c)\n            rate_ca = await self._get_exchange_rate(token_c, token_a)\n            \n            if not all([rate_ab, rate_bc, rate_ca]):\n                return None\n            \n            # Calculate final amount after complete cycle\n            amount_b = start_amount * rate_ab * (1 - Decimal(\"0.003\"))  # Subtract fee\n            amount_c = amount_b * rate_bc * (1 - Decimal(\"0.003\"))     # Subtract fee\n            final_amount = amount_c * rate_ca * (1 - Decimal(\"0.003\")) # Subtract fee\n            \n            profit = final_amount - start_amount\n            profit_percentage = (profit / start_amount) * 100\n            \n            if profit_percentage > Decimal(str(self.config.MIN_PROFIT_THRESHOLD)):\n                # Calculate profit in USD\n                token_a_price_usd = await self._get_token_price_usd(token_a)\n                profit_usd = profit * token_a_price_usd\n                \n                # Check if profit exceeds gas costs\n                gas_cost_usd = await self._estimate_triangular_gas_cost()\n                \n                if profit_usd > gas_cost_usd + Decimal(\"5\"):  # Minimum $5 net profit\n                    return ArbitrageOpportunity(\n                        id=f\"polygon_triangular_{token_a[:8]}_{datetime.now().timestamp()}\",\n                        type=\"triangular\",\n                        chain=\"polygon\",\n                        token_a=token_a,\n                        token_b=token_b,\n                        token_c=token_c,\n                        exchange_a=\"quickswap\",\n                        price_a=rate_ab,\n                        price_b=rate_bc,\n                        price_c=rate_ca,\n                        price_difference=profit_percentage,\n                        profit_usd=profit_usd,\n                        gas_cost_usd=gas_cost_usd,\n                        amount_in=start_amount,\n                        amount_out=final_amount,\n                        amount_ab=amount_b,\n                        amount_bc=amount_c,\n                        total_liquidity_usd=await self._estimate_path_liquidity(path),\n                        price_impact=await self._estimate_triangular_price_impact(start_amount, path),\n                        timestamp=datetime.now()\n                    )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking triangular path: {e}\")\n            return None\n    \n    async def _get_exchange_rate(self, token_in: str, token_out: str) -> Optional[Decimal]:\n        \"\"\"Get exchange rate between two tokens\"\"\"\n        try:\n            # Mock rates based on token types\n            if self._is_stablecoin(token_in) and self._is_stablecoin(token_out):\n                return Decimal(\"1.002\")  # Slight premium for stablecoin swaps\n            elif token_in == self.config.TOKENS[\"WMATIC\"]:\n                if token_out == self.config.TOKENS[\"USDC\"]:\n                    return Decimal(\"0.85\")    # WMATIC/USDC rate\n                elif token_out == self.config.TOKENS[\"WETH\"]:\n                    return Decimal(\"0.00026\") # WMATIC/WETH rate\n                elif token_out == self.config.TOKENS[\"WBTC\"]:\n                    return Decimal(\"0.000013\") # WMATIC/WBTC rate\n            elif token_out == self.config.TOKENS[\"WMATIC\"]:\n                # Inverse rates\n                rate = await self._get_exchange_rate(token_out, token_in)\n                return Decimal(\"1\") / rate if rate else None\n            \n            # Default fallback rate\n            return Decimal(\"1.0\")\n            \n        except Exception as e:\n            logger.debug(f\"Error getting exchange rate {token_in}/{token_out}: {e}\")\n            return None\n    \n    def _is_stablecoin(self, token: str) -> bool:\n        \"\"\"Check if token is a stablecoin\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"],\n            self.config.TOKENS[\"DAI\"]\n        ]\n        return token in stablecoins\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        try:\n            # Mock USD prices\n            if token == self.config.TOKENS[\"WMATIC\"]:\n                return Decimal(\"0.85\")\n            elif self._is_stablecoin(token):\n                return Decimal(\"1.00\")\n            elif token == self.config.TOKENS[\"WETH\"]:\n                return Decimal(\"3200.00\")\n            elif token == self.config.TOKENS[\"WBTC\"]:\n                return Decimal(\"65000.00\")\n            else:\n                return Decimal(\"1.00\")  # Fallback\n                \n        except Exception:\n            return Decimal(\"1.00\")\n    \n    async def _estimate_triangular_gas_cost(self) -> Decimal:\n        \"\"\"Estimate gas cost for triangular arbitrage\"\"\"\n        try:\n            # Polygon gas cost for 3 swaps\n            gas_price_gwei = 30\n            gas_used = 300000  # Three swaps\n            \n            matic_price_usd = Decimal(\"0.85\")\n            \n            gas_cost_matic = Decimal(str(gas_price_gwei)) * Decimal(str(gas_used)) / Decimal(\"1e9\")\n            gas_cost_usd = gas_cost_matic * matic_price_usd\n            \n            return gas_cost_usd\n            \n        except Exception:\n            return Decimal(\"0.75\")  # Fallback - very low on Polygon\n    \n    async def _estimate_path_liquidity(self, path: List[str]) -> Decimal:\n        \"\"\"Estimate liquidity for triangular path\"\"\"\n        return Decimal(\"300000\")  # $300K mock liquidity\n    \n    async def _estimate_triangular_price_impact(self, amount: Decimal, path: List[str]) -> float:\n        \"\"\"Estimate price impact for triangular arbitrage\"\"\"\n        return 0.12  # 0.12%\n    \n    async def _execute_triangular_swaps(\n        self, \n        token_a: str, \n        token_b: str, \n        token_c: str, \n        start_amount: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute the three swaps for triangular arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing triangular swaps: {token_a} -> {token_b} -> {token_c} -> {token_a}\")\n            \n            # Mock execution\n            # Simulate the three swaps\n            amount_after_first = start_amount * Decimal(\"0.997\")   # After fees\n            amount_after_second = amount_after_first * Decimal(\"0.997\")\n            final_amount = amount_after_second * Decimal(\"1.005\")  # Profitable final swap\n            \n            return {\n                \"success\": True,\n                \"final_amount\": final_amount,\n                \"token_price\": await self._get_token_price_usd(token_a),\n                \"total_gas_cost\": Decimal(\"0.75\"),\n                \"tx_hashes\": [\n                    f\"0x{'poly_swap1' * 9}\",\n                    f\"0x{'poly_swap2' * 9}\",\n                    f\"0x{'poly_swap3' * 9}\"\n                ]\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"total_gas_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"triangular_paths\": len(self.triangular_paths),\n            \"primary_dex\": \"quickswap\"\n        }","size_bytes":12907},"dex/shared/__init__.py":{"content":"","size_bytes":0},"dex/smart_contracts/FlashLoanArbitrage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@aave/core-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol\";\nimport \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";\nimport \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    \n    function getAmountsOut(uint amountIn, address[] calldata path)\n        external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    \n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external payable returns (uint256 amountOut);\n}\n\ncontract FlashLoanArbitrage is FlashLoanSimpleReceiverBase, Ownable, ReentrancyGuard {\n    \n    // DEX router addresses\n    address public constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address public constant SUSHISWAP_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n    address public constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n    \n    // Events\n    event ArbitrageExecuted(\n        address indexed asset,\n        uint256 amount,\n        uint256 profit,\n        string strategy\n    );\n    \n    event FlashLoanReceived(address asset, uint256 amount, uint256 premium);\n    \n    // Arbitrage parameters\n    struct ArbitrageParams {\n        address tokenA;\n        address tokenB;\n        address tokenC;\n        uint256 amountIn;\n        string strategy; // \"cross\" or \"triangular\"\n        bytes routerData;\n    }\n    \n    constructor(address _addressProvider) \n        FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_addressProvider)) \n    {}\n    \n    /**\n     * @dev Execute cross-DEX arbitrage with flash loan\n     */\n    function executeCrossArbitrage(\n        address asset,\n        uint256 amount,\n        address buyDex,\n        address sellDex,\n        address tokenB,\n        uint256 minProfit\n    ) external onlyOwner nonReentrant {\n        \n        ArbitrageParams memory params = ArbitrageParams({\n            tokenA: asset,\n            tokenB: tokenB,\n            tokenC: address(0),\n            amountIn: amount,\n            strategy: \"cross\",\n            routerData: abi.encode(buyDex, sellDex, minProfit)\n        });\n        \n        // Request flash loan\n        POOL.flashLoanSimple(\n            address(this),\n            asset,\n            amount,\n            abi.encode(params),\n            0 // referralCode\n        );\n    }\n    \n    /**\n     * @dev Execute triangular arbitrage with flash loan\n     */\n    function executeTriangularArbitrage(\n        address tokenA,\n        address tokenB, \n        address tokenC,\n        uint256 amount,\n        address dexRouter,\n        uint256 minProfit\n    ) external onlyOwner nonReentrant {\n        \n        ArbitrageParams memory params = ArbitrageParams({\n            tokenA: tokenA,\n            tokenB: tokenB,\n            tokenC: tokenC,\n            amountIn: amount,\n            strategy: \"triangular\",\n            routerData: abi.encode(dexRouter, minProfit)\n        });\n        \n        // Request flash loan\n        POOL.flashLoanSimple(\n            address(this),\n            tokenA,\n            amount,\n            abi.encode(params),\n            0 // referralCode\n        );\n    }\n    \n    /**\n     * @dev Aave flash loan callback\n     */\n    function executeOperation(\n        address asset,\n        uint256 amount,\n        uint256 premium,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        \n        emit FlashLoanReceived(asset, amount, premium);\n        \n        // Decode parameters\n        ArbitrageParams memory arbParams = abi.decode(params, (ArbitrageParams));\n        \n        uint256 initialBalance = IERC20(asset).balanceOf(address(this));\n        uint256 profit = 0;\n        \n        if (keccak256(bytes(arbParams.strategy)) == keccak256(bytes(\"cross\"))) {\n            profit = _executeCrossArbitrageLogic(arbParams);\n        } else if (keccak256(bytes(arbParams.strategy)) == keccak256(bytes(\"triangular\"))) {\n            profit = _executeTriangularArbitrageLogic(arbParams);\n        }\n        \n        // Ensure we have enough to repay the loan\n        uint256 amountToRepay = amount + premium;\n        uint256 finalBalance = IERC20(asset).balanceOf(address(this));\n        \n        require(finalBalance >= amountToRepay, \"Insufficient funds to repay loan\");\n        \n        // Calculate actual profit\n        if (finalBalance > amountToRepay) {\n            profit = finalBalance - amountToRepay;\n        }\n        \n        // Approve repayment\n        IERC20(asset).approve(address(POOL), amountToRepay);\n        \n        emit ArbitrageExecuted(asset, amount, profit, arbParams.strategy);\n        \n        return true;\n    }\n    \n    /**\n     * @dev Execute cross-DEX arbitrage logic\n     */\n    function _executeCrossArbitrageLogic(ArbitrageParams memory params) \n        internal returns (uint256 profit) {\n        \n        (address buyDex, address sellDex, uint256 minProfit) = \n            abi.decode(params.routerData, (address, address, uint256));\n        \n        uint256 initialAmount = params.amountIn;\n        \n        // Step 1: Buy on cheaper DEX (tokenA -> tokenB)\n        uint256 tokenBAmount = _swapOnDex(\n            buyDex,\n            params.tokenA,\n            params.tokenB,\n            initialAmount,\n            0 // minAmountOut will be calculated\n        );\n        \n        // Step 2: Sell on more expensive DEX (tokenB -> tokenA)\n        uint256 finalTokenAAmount = _swapOnDex(\n            sellDex,\n            params.tokenB,\n            params.tokenA,\n            tokenBAmount,\n            initialAmount + minProfit // Ensure minimum profit\n        );\n        \n        profit = finalTokenAAmount > initialAmount ? finalTokenAAmount - initialAmount : 0;\n        \n        return profit;\n    }\n    \n    /**\n     * @dev Execute triangular arbitrage logic\n     */\n    function _executeTriangularArbitrageLogic(ArbitrageParams memory params) \n        internal returns (uint256 profit) {\n        \n        (address dexRouter, uint256 minProfit) = \n            abi.decode(params.routerData, (address, uint256));\n        \n        uint256 initialAmount = params.amountIn;\n        \n        // Step 1: tokenA -> tokenB\n        uint256 tokenBAmount = _swapOnDex(\n            dexRouter,\n            params.tokenA,\n            params.tokenB,\n            initialAmount,\n            0\n        );\n        \n        // Step 2: tokenB -> tokenC\n        uint256 tokenCAmount = _swapOnDex(\n            dexRouter,\n            params.tokenB,\n            params.tokenC,\n            tokenBAmount,\n            0\n        );\n        \n        // Step 3: tokenC -> tokenA (complete the triangle)\n        uint256 finalTokenAAmount = _swapOnDex(\n            dexRouter,\n            params.tokenC,\n            params.tokenA,\n            tokenCAmount,\n            initialAmount + minProfit // Ensure minimum profit\n        );\n        \n        profit = finalTokenAAmount > initialAmount ? finalTokenAAmount - initialAmount : 0;\n        \n        return profit;\n    }\n    \n    /**\n     * @dev Execute swap on specified DEX\n     */\n    function _swapOnDex(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        \n        // Approve token spending\n        IERC20(tokenIn).approve(router, amountIn);\n        \n        if (router == UNISWAP_V2_ROUTER || router == SUSHISWAP_ROUTER) {\n            // Use V2 router\n            address[] memory path = new address[](2);\n            path[0] = tokenIn;\n            path[1] = tokenOut;\n            \n            uint[] memory amounts = IUniswapV2Router(router).swapExactTokensForTokens(\n                amountIn,\n                minAmountOut,\n                path,\n                address(this),\n                block.timestamp + 300 // 5 minutes deadline\n            );\n            \n            amountOut = amounts[amounts.length - 1];\n            \n        } else if (router == UNISWAP_V3_ROUTER) {\n            // Use V3 router\n            IUniswapV3Router.ExactInputSingleParams memory swapParams = \n                IUniswapV3Router.ExactInputSingleParams({\n                    tokenIn: tokenIn,\n                    tokenOut: tokenOut,\n                    fee: 3000, // 0.3% fee tier\n                    recipient: address(this),\n                    deadline: block.timestamp + 300,\n                    amountIn: amountIn,\n                    amountOutMinimum: minAmountOut,\n                    sqrtPriceLimitX96: 0\n                });\n            \n            amountOut = IUniswapV3Router(router).exactInputSingle(swapParams);\n        }\n        \n        return amountOut;\n    }\n    \n    /**\n     * @dev Withdraw profits (owner only)\n     */\n    function withdrawToken(address token, uint256 amount) external onlyOwner {\n        IERC20(token).transfer(owner(), amount);\n    }\n    \n    /**\n     * @dev Withdraw ETH (owner only)\n     */\n    function withdrawETH(uint256 amount) external onlyOwner {\n        payable(owner()).transfer(amount);\n    }\n    \n    /**\n     * @dev Emergency function to recover stuck funds\n     */\n    function emergencyWithdraw(address token) external onlyOwner {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20(token).transfer(owner(), balance);\n        }\n    }\n    \n    // Receive ETH\n    receive() external payable {}\n}","size_bytes":10083},"dex/smart_contracts/ReadME.md":{"content":"# Smart Contracts for DEX Arbitrage\n\n## FlashLoanArbitrage.sol\n\nThis contract enables flash loan arbitrage execution using Aave V3 as the flash loan provider.\n\n### Features\n\n- **Cross-DEX Arbitrage**: Buy on one DEX, sell on another\n- **Triangular Arbitrage**: Execute 3-hop trades within the same DEX  \n- **Flash Loan Integration**: Uses Aave V3 for capital-free arbitrage\n- **Multi-DEX Support**: Uniswap V2, V3, and SushiSwap\n- **Safety Features**: Minimum profit checks, reentrancy protection\n\n### Deployment\n\n```bash\n# Install dependencies\nnpm install @aave/core-v3 @openzeppelin/contracts\n\n# Compile with Hardhat/Foundry\nnpx hardhat compile\n\n# Deploy using the Python script\npython deploy.py\n```\n\n### Usage\n\n1. **Cross Arbitrage**:\n```solidity\ncontract.executeCrossArbitrage(\n    WETH_ADDRESS,      // asset to flash loan\n    1 ether,           // amount\n    UNISWAP_ROUTER,    // buy DEX\n    SUSHISWAP_ROUTER,  // sell DEX  \n    USDC_ADDRESS,      // intermediate token\n    0.01 ether         // minimum profit\n)\n```\n\n2. **Triangular Arbitrage**:\n```solidity\ncontract.executeTriangularArbitrage(\n    WETH_ADDRESS,      // start token\n    USDC_ADDRESS,      // hop 1\n    DAI_ADDRESS,       // hop 2  \n    1 ether,           // amount\n    UNISWAP_ROUTER,    // DEX router\n    0.01 ether         // minimum profit\n)\n```\n\n### Security Considerations\n\n- Only owner can execute arbitrage\n- Reentrancy protection enabled\n- Emergency withdrawal functions\n- Minimum profit validation\n\n### Gas Optimization\n\n- Efficient swap routing\n- Minimal external calls\n- Optimized for MEV execution","size_bytes":1584},"dex/solana_service/__init__.py":{"content":"# Solana Arbitrage Service","size_bytes":26},"dex/solana_service/arbitrage.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom decimal import Decimal\nfrom datetime import datetime\n\nfrom .engine import SolanaEngine\nfrom .config import SolanaConfig\nfrom .cross_arbitrage import SolanaCrossArbitrageEngine\nfrom .triangular_arbitrage import SolanaTriangularArbitrageEngine\nfrom .flashloan_engine import SolanaFlashLoanEngine\n\n# Shared imports\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nlogger = logging.getLogger(__name__)\n\nclass SolanaArbitrageService:\n    \"\"\"Main Solana arbitrage service coordinating all arbitrage engines\"\"\"\n    \n    def __init__(self, config: SolanaConfig = None):\n        self.config = config or SolanaConfig()\n        self.chain = \"solana\"\n        self.network = self.config.NETWORK\n        \n        # Core engine\n        self.engine = SolanaEngine(self.config)\n        \n        # Arbitrage engines\n        self.cross_arbitrage = SolanaCrossArbitrageEngine(self.engine, self.config)\n        self.triangular_arbitrage = SolanaTriangularArbitrageEngine(self.engine, self.config)\n        self.flash_loan = SolanaFlashLoanEngine(self.engine, self.config)\n        \n        self.is_initialized = False\n        self.last_health_check = datetime.now()\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize all components\"\"\"\n        try:\n            logger.info(\"Initializing Solana Arbitrage Service...\")\n            \n            # Initialize core engine\n            await self.engine.initialize()\n            \n            # Initialize arbitrage engines\n            await self.cross_arbitrage.initialize()\n            await self.triangular_arbitrage.initialize()\n            await self.flash_loan.initialize()\n            \n            self.is_initialized = True\n            logger.info(\"Solana Arbitrage Service initialized successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Solana Arbitrage Service: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for all types of arbitrage opportunities\"\"\"\n        if not self.is_initialized:\n            logger.warning(\"Solana Service not initialized\")\n            return []\n        \n        try:\n            all_opportunities = []\n            \n            # Get cross-exchange opportunities\n            cross_ops = await self.cross_arbitrage.scan_opportunities()\n            all_opportunities.extend(cross_ops)\n            \n            # Get triangular arbitrage opportunities\n            triangular_ops = await self.triangular_arbitrage.scan_opportunities()\n            all_opportunities.extend(triangular_ops)\n            \n            # Get flash loan opportunities\n            flash_ops = await self.flash_loan.scan_opportunities()\n            all_opportunities.extend(flash_ops)\n            \n            logger.info(f\"Found {len(all_opportunities)} opportunities on Solana\")\n            return all_opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Solana opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute a specific arbitrage opportunity\"\"\"\n        if not self.is_initialized:\n            raise RuntimeError(\"Solana Service not initialized\")\n        \n        try:\n            logger.info(f\"Executing Solana opportunity {opportunity.id} of type {opportunity.type}\")\n            \n            if opportunity.type == \"cross_exchange\":\n                return await self.cross_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"triangular\":\n                return await self.triangular_arbitrage.execute_opportunity(opportunity)\n            elif opportunity.type == \"flash_loan\":\n                return await self.flash_loan.execute_opportunity(opportunity)\n            else:\n                raise ValueError(f\"Unknown opportunity type: {opportunity.type}\")\n                \n        except Exception as e:\n            logger.error(f\"Error executing Solana opportunity {opportunity.id}: {e}\")\n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=0.0,\n                error=str(e)\n            )\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get service health status\"\"\"\n        try:\n            self.last_health_check = datetime.now()\n            \n            # Check engine health\n            engine_health = await self._check_engine_health()\n            \n            # Check component health\n            components_health = await self._check_components_health()\n            \n            overall_healthy = (\n                engine_health[\"status\"] == \"healthy\" and\n                all(comp[\"status\"] == \"healthy\" for comp in components_health.values())\n            )\n            \n            return {\n                \"status\": \"healthy\" if overall_healthy else \"degraded\",\n                \"timestamp\": self.last_health_check.isoformat(),\n                \"chain\": self.chain,\n                \"network\": self.network,\n                \"engine\": engine_health,\n                \"components\": components_health,\n                \"initialized\": self.is_initialized\n            }\n            \n        except Exception as e:\n            logger.error(f\"Solana Health check failed: {e}\")\n            return {\n                \"status\": \"unhealthy\",\n                \"error\": str(e),\n                \"timestamp\": datetime.now().isoformat()\n            }\n    \n    async def _check_engine_health(self) -> Dict[str, Any]:\n        \"\"\"Check core engine health\"\"\"\n        try:\n            if not self.engine or not self.engine.client:\n                return {\"status\": \"unhealthy\", \"error\": \"Engine not initialized\"}\n            \n            # Test RPC connection\n            health_result = await self.engine.client.get_health()\n            if health_result.value != \"ok\":\n                return {\"status\": \"unhealthy\", \"error\": \"RPC health check failed\"}\n            \n            # Test wallet\n            if self.engine.wallet_address:\n                balance = await self.engine.get_balance(\"SOL\")  # SOL balance\n                current_slot = await self.engine.get_current_slot()\n                return {\n                    \"status\": \"healthy\",\n                    \"wallet_address\": self.engine.wallet_address,\n                    \"sol_balance\": str(balance),\n                    \"current_slot\": current_slot\n                }\n            else:\n                return {\"status\": \"degraded\", \"warning\": \"No wallet configured\"}\n                \n        except Exception as e:\n            return {\"status\": \"unhealthy\", \"error\": str(e)}\n    \n    async def _check_components_health(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Check arbitrage components health\"\"\"\n        components = {\n            \"cross_arbitrage\": self.cross_arbitrage,\n            \"triangular_arbitrage\": self.triangular_arbitrage,\n            \"flash_loan\": self.flash_loan\n        }\n        \n        health_status = {}\n        \n        for name, component in components.items():\n            try:\n                if hasattr(component, 'get_health_status'):\n                    health_status[name] = await component.get_health_status()\n                else:\n                    # Basic health check\n                    health_status[name] = {\n                        \"status\": \"healthy\" if hasattr(component, 'initialized') else \"unknown\",\n                        \"initialized\": getattr(component, 'initialized', False)\n                    }\n            except Exception as e:\n                health_status[name] = {\n                    \"status\": \"unhealthy\",\n                    \"error\": str(e)\n                }\n        \n        return health_status\n    \n    async def ping(self) -> bool:\n        \"\"\"Simple ping for heartbeat monitoring\"\"\"\n        try:\n            if not self.is_initialized:\n                return False\n            \n            # Quick RPC connection test\n            if self.engine and self.engine.client:\n                health_result = await self.engine.client.get_health()\n                return health_result.value == \"ok\"\n            \n            return False\n            \n        except Exception:\n            return False\n    \n    async def shutdown(self) -> None:\n        \"\"\"Graceful shutdown\"\"\"\n        try:\n            logger.info(\"Shutting down Solana Arbitrage Service...\")\n            \n            # Close engine connections\n            if self.engine:\n                await self.engine.shutdown()\n            \n            self.is_initialized = False\n            logger.info(\"Solana Arbitrage Service shutdown complete\")\n            \n        except Exception as e:\n            logger.error(f\"Error during Solana shutdown: {e}\")\n    \n    async def restart(self) -> None:\n        \"\"\"Restart the service\"\"\"\n        await self.shutdown()\n        await self.initialize()\n        logger.info(\"Solana Arbitrage Service restarted\")","size_bytes":9272},"dex/solana_service/config.py":{"content":"import os\nfrom typing import List, Dict\n\nclass SolanaConfig:\n    # Network Configuration\n    NETWORK = os.getenv(\"SOLANA_NETWORK\", \"mainnet-beta\")  # mainnet-beta, devnet, testnet\n    RPC_URL = os.getenv(\"SOLANA_RPC_URL\", \"https://api.mainnet-beta.solana.com\")\n    WSS_URL = os.getenv(\"SOLANA_WSS_URL\", \"wss://api.mainnet-beta.solana.com\")\n    \n    # Wallet Configuration\n    PRIVATE_KEY = os.getenv(\"SOLANA_PRIVATE_KEY\", \"\")  # Base58 encoded private key\n    WALLET_ADDRESS = os.getenv(\"SOLANA_WALLET_ADDRESS\", \"\")  # Public key\n    \n    # Transaction Configuration\n    MAX_COMPUTE_UNITS = int(os.getenv(\"SOLANA_MAX_COMPUTE_UNITS\", \"400000\"))\n    COMPUTE_UNIT_PRICE = int(os.getenv(\"SOLANA_COMPUTE_UNIT_PRICE\", \"1000\"))  # micro-lamports\n    PRIORITY_FEE_LAMPORTS = int(os.getenv(\"SOLANA_PRIORITY_FEE\", \"5000\"))\n    \n    # Trading Configuration\n    MIN_PROFIT_THRESHOLD = float(os.getenv(\"SOLANA_MIN_PROFIT_THRESHOLD\", \"0.3\"))  # %\n    MAX_SLIPPAGE = float(os.getenv(\"SOLANA_MAX_SLIPPAGE\", \"0.5\"))  # %\n    MAX_TRADE_SIZE_SOL = float(os.getenv(\"SOLANA_MAX_TRADE_SIZE\", \"100.0\"))\n    \n    # DEX Program IDs (Solana)\n    JUPITER_AGGREGATOR = \"JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB\"\n    JUPITER_V6 = \"JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4\"\n    \n    RAYDIUM_AMM = \"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8\"\n    RAYDIUM_CLMM = \"CAMMCzo5YL8w4VFF8KVHrK22GGUQzaMBFhfgv2B6VDw\"\n    \n    ORCA_WHIRLPOOL = \"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\"\n    ORCA_LEGACY = \"9W959DqEETiGZocYWCQPaJ6sBmUzgfxXfqGeTEdp3aQP\"\n    \n    SERUM_V3 = \"9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin\"\n    \n    # Flash Loan Program IDs\n    MANGO_V4 = \"4MangoMjqJ2firMokCjjGgoK8d4MXcrgL7XJaL3w6fVg\"\n    SOLEND = \"So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo\"\n    \n    # Common SPL Tokens (Solana addresses)\n    TOKENS = {\n        \"SOL\": \"So11111111111111111111111111111111111111112\",  # Wrapped SOL\n        \"USDC\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n        \"USDT\": \"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\",\n        \"RAY\": \"4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R\",\n        \"SRM\": \"SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt\",\n        \"ORCA\": \"orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE\",\n        \"MNGO\": \"MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac\",\n        \"BTC\": \"9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E\",  # Bitcoin (Sollet)\n        \"ETH\": \"2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk\",  # Ethereum (Sollet)\n        \"BONK\": \"DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263\"\n    }\n    \n    # Mempool Configuration\n    MEMPOOL_MONITOR_ENABLED = os.getenv(\"SOLANA_MEMPOOL_MONITOR\", \"False\") == \"True\"\n    MIN_MEV_OPPORTUNITY_USD = float(os.getenv(\"SOLANA_MIN_MEV_OPPORTUNITY\", \"25.0\"))\n    \n    # Solana-specific constants\n    LAMPORTS_PER_SOL = 1_000_000_000\n    WSOL_MINT = \"So11111111111111111111111111111111111111112\"\n    \n    @classmethod\n    def validate(cls):\n        errors = []\n        if not cls.RPC_URL:\n            errors.append(\"SOLANA_RPC_URL not properly configured\")\n        if not cls.PRIVATE_KEY:\n            errors.append(\"SOLANA_PRIVATE_KEY not set\")\n        if errors:\n            raise RuntimeError(f\"Solana config validation errors: {'; '.join(errors)}\")","size_bytes":3193},"dex/solana_service/cross_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import SolanaEngine\nfrom .config import SolanaConfig\n\nlogger = logging.getLogger(__name__)\n\nclass SolanaCrossArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"Solana Cross-exchange arbitrage engine\"\"\"\n    \n    def __init__(self, engine: SolanaEngine, config: SolanaConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Solana DEX configurations\n        self.dexes = {\n            \"jupiter\": {\n                \"program_id\": config.JUPITER_V6,\n                \"aggregator\": True,\n                \"fee\": 0.0,  # Jupiter doesn't charge fees, but routes through DEXes that do\n                \"type\": \"aggregator\"\n            },\n            \"raydium\": {\n                \"program_id\": config.RAYDIUM_AMM,\n                \"fee\": 0.0025,  # 0.25%\n                \"type\": \"amm\"\n            },\n            \"raydium_clmm\": {\n                \"program_id\": config.RAYDIUM_CLMM,\n                \"fee\": 0.0025,  # Variable fees\n                \"type\": \"clmm\"\n            },\n            \"orca\": {\n                \"program_id\": config.ORCA_WHIRLPOOL,\n                \"fee\": 0.003,  # Variable fees\n                \"type\": \"whirlpool\"\n            },\n            \"orca_legacy\": {\n                \"program_id\": config.ORCA_LEGACY,\n                \"fee\": 0.003,  # 0.3%\n                \"type\": \"legacy_amm\"\n            },\n            \"serum\": {\n                \"program_id\": config.SERUM_V3,\n                \"fee\": 0.0022,  # 0.22%\n                \"type\": \"orderbook\"\n            }\n        }\n        \n        # Common trading pairs on Solana\n        self.trading_pairs = [\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"USDC\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"RAY\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"ORCA\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"SRM\"]),\n            (config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"]),\n            (config.TOKENS[\"USDC\"], config.TOKENS[\"RAY\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"BTC\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"ETH\"]),\n            (config.TOKENS[\"SOL\"], config.TOKENS[\"BONK\"])\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize cross arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing Solana Cross Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"Solana Cross Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Solana cross arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for cross-exchange arbitrage opportunities on Solana\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for token_a, token_b in self.trading_pairs:\n                # Check prices across different DEXes\n                prices = await self._get_prices_across_dexes(token_a, token_b)\n                \n                if len(prices) >= 2:\n                    # Find best buy and sell prices\n                    best_buy = min(prices, key=lambda x: x[\"price\"])\n                    best_sell = max(prices, key=lambda x: x[\"price\"])\n                    \n                    if best_buy[\"dex\"] != best_sell[\"dex\"]:\n                        price_diff = best_sell[\"price\"] - best_buy[\"price\"]\n                        profit_percentage = (price_diff / best_buy[\"price\"]) * 100\n                        \n                        if profit_percentage > self.config.MIN_PROFIT_THRESHOLD:\n                            # Calculate potential profit\n                            trade_amount = Decimal(\"10.0\")  # 10 units of token_a\n                            \n                            profit_usd = await self._calculate_profit(\n                                token_a, token_b, trade_amount,\n                                best_buy, best_sell\n                            )\n                            \n                            if profit_usd > Decimal(\"5\"):  # Minimum $5 profit\n                                opportunity = ArbitrageOpportunity(\n                                    id=f\"solana_cross_{best_buy['dex']}_{best_sell['dex']}_{datetime.now().timestamp()}\",\n                                    type=\"cross_exchange\",\n                                    chain=\"solana\",\n                                    token_a=token_a,\n                                    token_b=token_b,\n                                    exchange_a=best_buy[\"dex\"],\n                                    exchange_b=best_sell[\"dex\"],\n                                    price_a=best_buy[\"price\"],\n                                    price_b=best_sell[\"price\"],\n                                    price_difference=price_diff,\n                                    profit_usd=profit_usd,\n                                    gas_cost_usd=await self._estimate_transaction_cost(),\n                                    amount_in=trade_amount,\n                                    amount_out=trade_amount * best_sell[\"price\"],\n                                    total_liquidity_usd=await self._estimate_liquidity(token_a, token_b),\n                                    price_impact=await self._estimate_price_impact(trade_amount, best_buy, best_sell),\n                                    timestamp=datetime.now()\n                                )\n                                \n                                opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Solana cross-arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Solana cross arbitrage opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute cross-exchange arbitrage on Solana\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Solana cross arbitrage: {opportunity.id}\")\n            \n            # Step 1: Buy on exchange A\n            buy_result = await self._execute_buy(\n                opportunity.exchange_a,\n                opportunity.token_a,\n                opportunity.token_b,\n                opportunity.amount_in\n            )\n            \n            if not buy_result[\"success\"]:\n                raise Exception(f\"Buy failed: {buy_result['error']}\")\n            \n            # Step 2: Sell on exchange B\n            sell_result = await self._execute_sell(\n                opportunity.exchange_b,\n                opportunity.token_b,\n                opportunity.token_a,\n                buy_result[\"amount_out\"]\n            )\n            \n            if not sell_result[\"success\"]:\n                raise Exception(f\"Sell failed: {sell_result['error']}\")\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            # Calculate actual profit\n            actual_profit = sell_result[\"amount_out\"] - opportunity.amount_in\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=True,\n                profit_usd=actual_profit * opportunity.price_a,  # Convert to USD\n                gas_cost_usd=buy_result[\"transaction_cost\"] + sell_result[\"transaction_cost\"],\n                execution_time=execution_time,\n                transaction_hashes=[buy_result[\"tx_signature\"], sell_result[\"tx_signature\"]]\n            )\n            \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Solana cross arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _get_prices_across_dexes(self, token_a: str, token_b: str) -> List[Dict[str, Any]]:\n        \"\"\"Get prices for token pair across all DEXes\"\"\"\n        prices = []\n        \n        for dex_name, dex_config in self.dexes.items():\n            try:\n                if dex_config[\"type\"] == \"aggregator\":\n                    price = await self._get_jupiter_price(token_a, token_b)\n                elif dex_config[\"type\"] == \"amm\":\n                    price = await self._get_amm_price(token_a, token_b, dex_config)\n                elif dex_config[\"type\"] == \"clmm\":\n                    price = await self._get_clmm_price(token_a, token_b, dex_config)\n                elif dex_config[\"type\"] == \"whirlpool\":\n                    price = await self._get_whirlpool_price(token_a, token_b, dex_config)\n                elif dex_config[\"type\"] == \"orderbook\":\n                    price = await self._get_orderbook_price(token_a, token_b, dex_config)\n                else:\n                    price = await self._get_generic_price(token_a, token_b, dex_config)\n                \n                if price and price > 0:\n                    prices.append({\n                        \"dex\": dex_name,\n                        \"price\": price,\n                        \"config\": dex_config\n                    })\n                    \n            except Exception as e:\n                logger.debug(f\"Error getting price from {dex_name}: {e}\")\n                continue\n        \n        return prices\n    \n    async def _get_jupiter_price(self, token_a: str, token_b: str) -> Optional[Decimal]:\n        \"\"\"Get price from Jupiter aggregator\"\"\"\n        try:\n            # Jupiter aggregator would provide best price across all DEXes\n            price = await self.engine.get_token_price_jupiter(token_a, token_b)\n            return price\n        except Exception as e:\n            logger.debug(f\"Error getting Jupiter price: {e}\")\n            return None\n    \n    async def _get_amm_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from AMM DEX\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.004\") * (hash(dex_config[\"program_id\"]) % 20 - 10)  # -4% to +4%\n            return base_price * (1 + variation)\n        except Exception as e:\n            logger.debug(f\"Error getting AMM price: {e}\")\n            return None\n    \n    async def _get_clmm_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from Concentrated Liquidity Market Maker\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.002\") * (hash(dex_config[\"program_id\"]) % 20 - 10)  # -2% to +2%\n            return base_price * (1 + variation)\n        except Exception as e:\n            logger.debug(f\"Error getting CLMM price: {e}\")\n            return None\n    \n    async def _get_whirlpool_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from Whirlpool DEX\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.003\") * (hash(dex_config[\"program_id\"]) % 20 - 10)  # -3% to +3%\n            return base_price * (1 + variation)\n        except Exception as e:\n            logger.debug(f\"Error getting Whirlpool price: {e}\")\n            return None\n    \n    async def _get_orderbook_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from orderbook DEX (Serum)\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            variation = Decimal(\"0.001\") * (hash(dex_config[\"program_id\"]) % 20 - 10)  # -1% to +1%\n            return base_price * (1 + variation)\n        except Exception as e:\n            logger.debug(f\"Error getting orderbook price: {e}\")\n            return None\n    \n    async def _get_generic_price(self, token_a: str, token_b: str, dex_config: Dict) -> Optional[Decimal]:\n        \"\"\"Get price from generic DEX\"\"\"\n        try:\n            base_price = await self._get_base_price(token_a, token_b)\n            return base_price\n        except Exception as e:\n            logger.debug(f\"Error getting generic price: {e}\")\n            return None\n    \n    async def _get_base_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get base price for token pair\"\"\"\n        # Mock base prices for common Solana pairs\n        if token_a == self.config.TOKENS[\"SOL\"]:\n            if token_b == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"180.50\")  # SOL/USDC\n            elif token_b == self.config.TOKENS[\"RAY\"]:\n                return Decimal(\"120.0\")   # SOL/RAY\n            elif token_b == self.config.TOKENS[\"ORCA\"]:\n                return Decimal(\"45.0\")    # SOL/ORCA\n        elif self._is_stablecoin_pair(token_a, token_b):\n            return Decimal(\"1.001\")  # Stablecoin pairs\n        \n        return Decimal(\"1.0\")  # Default\n    \n    def _is_stablecoin_pair(self, token_a: str, token_b: str) -> bool:\n        \"\"\"Check if pair consists of stablecoins\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"]\n        ]\n        return token_a in stablecoins and token_b in stablecoins\n    \n    async def _calculate_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        amount: Decimal,\n        buy_data: Dict,\n        sell_data: Dict\n    ) -> Decimal:\n        \"\"\"Calculate expected profit in USD\"\"\"\n        try:\n            buy_cost = amount * buy_data[\"price\"]\n            sell_revenue = amount * sell_data[\"price\"]\n            \n            # Subtract DEX fees\n            buy_fee = buy_cost * Decimal(str(buy_data[\"config\"].get(\"fee\", 0.003)))\n            sell_fee = sell_revenue * Decimal(str(sell_data[\"config\"].get(\"fee\", 0.003)))\n            \n            gross_profit = sell_revenue - buy_cost\n            net_profit = gross_profit - buy_fee - sell_fee\n            \n            # Convert to USD\n            token_price_usd = await self._get_token_price_usd(token_a)\n            return net_profit * token_price_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating Solana profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        # Mock USD prices\n        prices = {\n            self.config.TOKENS[\"SOL\"]: Decimal(\"180.00\"),\n            self.config.TOKENS[\"USDC\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDT\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"RAY\"]: Decimal(\"1.50\"),\n            self.config.TOKENS[\"ORCA\"]: Decimal(\"4.00\"),\n            self.config.TOKENS[\"SRM\"]: Decimal(\"0.60\"),\n            self.config.TOKENS[\"BTC\"]: Decimal(\"65000.00\"),\n            self.config.TOKENS[\"ETH\"]: Decimal(\"3200.00\"),\n            self.config.TOKENS[\"BONK\"]: Decimal(\"0.000025\")\n        }\n        return prices.get(token, Decimal(\"1.00\"))\n    \n    async def _estimate_transaction_cost(self) -> Decimal:\n        \"\"\"Estimate transaction cost in USD\"\"\"\n        try:\n            # Solana transaction costs are very low\n            base_fee_lamports = 5000  # Base transaction fee\n            compute_fee_lamports = self.config.PRIORITY_FEE_LAMPORTS\n            \n            total_fee_lamports = base_fee_lamports + compute_fee_lamports\n            total_fee_sol = Decimal(total_fee_lamports) / Decimal(self.config.LAMPORTS_PER_SOL)\n            \n            sol_price_usd = Decimal(\"180.00\")\n            transaction_cost_usd = total_fee_sol * sol_price_usd\n            \n            return transaction_cost_usd\n            \n        except Exception:\n            return Decimal(\"0.01\")  # Very low fallback\n    \n    async def _estimate_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate available liquidity\"\"\"\n        return Decimal(\"2000000\")  # $2M mock liquidity\n    \n    async def _estimate_price_impact(\n        self, \n        amount: Decimal, \n        buy_data: Dict, \n        sell_data: Dict\n    ) -> float:\n        \"\"\"Estimate price impact\"\"\"\n        return 0.05  # 0.05% estimated impact\n    \n    async def _execute_buy(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute buy order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing buy on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"0.997\"),  # After fees\n                \"tx_signature\": f\"{'solana_buy' * 8}{'1' * 16}\",\n                \"transaction_cost\": Decimal(\"0.005\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"transaction_cost\": Decimal(\"0\")\n            }\n    \n    async def _execute_sell(\n        self, \n        dex: str, \n        token_in: str, \n        token_out: str, \n        amount_in: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute sell order on specified DEX\"\"\"\n        try:\n            logger.info(f\"Executing sell on {dex}: {amount_in} {token_in} -> {token_out}\")\n            \n            # Mock execution\n            return {\n                \"success\": True,\n                \"amount_out\": amount_in * Decimal(\"1.003\"),  # Favorable rate\n                \"tx_signature\": f\"{'solana_sell' * 8}{'2' * 16}\",\n                \"transaction_cost\": Decimal(\"0.005\")\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"transaction_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"supported_dexes\": list(self.dexes.keys()),\n            \"trading_pairs\": len(self.trading_pairs)\n        }","size_bytes":18844},"dex/solana_service/engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, Any, Optional, Union, List\nimport json\nimport base58\nfrom solana.rpc.async_api import AsyncClient\ntry:\n    from solana.keypair import Keypair\n    from solana.publickey import PublicKey\n    from solana.transaction import Transaction\n    from solana.system_program import TransferParams, transfer\nexcept ImportError:\n    # Try newer solders import structure\n    from solders.keypair import Keypair\n    from solders.pubkey import Pubkey as PublicKey\n    Transaction = None  # Will need to be implemented\n    TransferParams = None\n    transfer = None\n\ntry:\n    from solders.compute_budget import set_compute_unit_limit, set_compute_unit_price\nexcept ImportError:\n    set_compute_unit_limit = None\n    set_compute_unit_price = None\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseEngine\nfrom models.arbitrage_models import ExecutionResult\n\nfrom .config import SolanaConfig\n\nlogger = logging.getLogger(__name__)\n\nclass SolanaEngine(BaseEngine):\n    \"\"\"Solana blockchain engine for RPC operations\"\"\"\n    \n    def __init__(self, config: SolanaConfig):\n        self.config = config\n        self.client: Optional[AsyncClient] = None\n        self.keypair: Optional[Keypair] = None\n        self.wallet_address: Optional[str] = None\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize Solana RPC connection and wallet\"\"\"\n        try:\n            # Initialize RPC client\n            self.client = AsyncClient(self.config.RPC_URL)\n            \n            # Initialize wallet\n            if self.config.PRIVATE_KEY:\n                try:\n                    # Try to decode as base58 private key\n                    private_key_bytes = base58.b58decode(self.config.PRIVATE_KEY)\n                    self.keypair = Keypair.from_secret_key(private_key_bytes)\n                except Exception:\n                    # Try as JSON array format\n                    try:\n                        key_array = json.loads(self.config.PRIVATE_KEY)\n                        self.keypair = Keypair.from_secret_key(bytes(key_array))\n                    except Exception as e:\n                        raise ValueError(f\"Invalid private key format: {e}\")\n                \n                self.wallet_address = str(self.keypair.public_key)\n                logger.info(f\"Solana Wallet initialized: {self.wallet_address}\")\n            \n            # Test connection\n            result = await self.client.get_health()\n            if result.value != \"ok\":\n                logger.warning(\"Solana RPC health check returned non-OK status\")\n            \n            # Get network info\n            genesis_hash = await self.client.get_genesis_hash()\n            logger.info(f\"Solana engine initialized on network: {self.config.NETWORK}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize Solana engine: {e}\")\n            raise\n    \n    async def get_balance(self, token_address: str, wallet_address: str = None) -> Decimal:\n        \"\"\"Get token balance for wallet\"\"\"\n        try:\n            target_wallet = wallet_address or self.wallet_address\n            if not target_wallet:\n                raise ValueError(\"No wallet address provided\")\n            \n            wallet_pubkey = PublicKey(target_wallet)\n            \n            # SOL balance\n            if token_address.upper() == \"SOL\" or token_address == self.config.TOKENS[\"SOL\"]:\n                balance_result = await self.client.get_balance(wallet_pubkey)\n                balance_lamports = balance_result.value\n                return Decimal(balance_lamports) / Decimal(self.config.LAMPORTS_PER_SOL)\n            else:\n                # SPL Token balance\n                # This would require getting token accounts and parsing balances\n                # For now, return mock balance\n                return Decimal(\"100.0\")  # Mock SPL token balance\n                \n        except Exception as e:\n            logger.error(f\"Error getting Solana balance for {token_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_transaction_fee(self, transaction: Transaction) -> int:\n        \"\"\"Get transaction fee in lamports\"\"\"\n        try:\n            # Get recent blockhash and fee calculator\n            recent_blockhash = await self.client.get_recent_blockhash()\n            \n            # Estimate fee based on signatures\n            num_signatures = len(transaction.signatures) if hasattr(transaction, 'signatures') else 1\n            base_fee = 5000  # Base fee per signature in lamports\n            \n            # Add compute unit costs\n            compute_fee = self.config.COMPUTE_UNIT_PRICE * self.config.MAX_COMPUTE_UNITS // 1_000_000\n            \n            total_fee = base_fee * num_signatures + compute_fee + self.config.PRIORITY_FEE_LAMPORTS\n            \n            return total_fee\n            \n        except Exception as e:\n            logger.error(f\"Error estimating Solana transaction fee: {e}\")\n            return 10000  # Fallback fee\n    \n    async def execute_transaction(self, transaction_data: Dict[str, Any]) -> str:\n        \"\"\"Execute transaction on Solana\"\"\"\n        try:\n            if not self.keypair or not self.wallet_address:\n                raise ValueError(\"Wallet not initialized\")\n            \n            # This would build and send the actual Solana transaction\n            # For now, return mock transaction hash\n            mock_signature = \"5\" + \"a\" * 87  # 88 character transaction signature\n            \n            logger.info(f\"Solana Transaction sent: {mock_signature}\")\n            return mock_signature\n            \n        except Exception as e:\n            logger.error(f\"Error executing Solana transaction: {e}\")\n            raise\n    \n    async def wait_for_transaction_confirmation(\n        self, \n        tx_signature: str, \n        timeout: int = 60\n    ) -> Dict[str, Any]:\n        \"\"\"Wait for transaction confirmation\"\"\"\n        try:\n            # This would wait for transaction confirmation\n            # For now, return mock result\n            return {\n                \"success\": True,\n                \"slot\": 150000000,  # Mock slot\n                \"confirmationStatus\": \"confirmed\"\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error waiting for Solana transaction confirmation: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def get_current_slot(self) -> int:\n        \"\"\"Get current slot number\"\"\"\n        try:\n            result = await self.client.get_slot()\n            return result.value\n        except Exception as e:\n            logger.error(f\"Error getting Solana slot: {e}\")\n            return 0\n    \n    async def get_token_accounts(self, wallet_address: str = None) -> List[Dict[str, Any]]:\n        \"\"\"Get all token accounts for wallet\"\"\"\n        try:\n            target_wallet = wallet_address or self.wallet_address\n            if not target_wallet:\n                raise ValueError(\"No wallet address provided\")\n            \n            wallet_pubkey = PublicKey(target_wallet)\n            \n            # Get token accounts by owner\n            result = await self.client.get_token_accounts_by_owner(\n                wallet_pubkey,\n                {\"programId\": PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\")}  # SPL Token program\n            )\n            \n            token_accounts = []\n            for account_info in result.value:\n                account_data = account_info.account.data\n                # Parse token account data\n                token_accounts.append({\n                    \"pubkey\": str(account_info.pubkey),\n                    \"mint\": \"unknown\",  # Would parse from account data\n                    \"balance\": \"0\"      # Would parse from account data\n                })\n            \n            return token_accounts\n            \n        except Exception as e:\n            logger.error(f\"Error getting Solana token accounts: {e}\")\n            return []\n    \n    async def create_jupiter_swap_instruction(\n        self,\n        input_mint: str,\n        output_mint: str,\n        amount: int,\n        slippage_bps: int = 50\n    ) -> Dict[str, Any]:\n        \"\"\"Create Jupiter swap instruction\"\"\"\n        try:\n            # This would call Jupiter API to get swap instruction\n            # For now, return mock instruction data\n            \n            mock_instruction = {\n                \"programId\": self.config.JUPITER_V6,\n                \"keys\": [],  # Would contain actual account keys\n                \"data\": \"mock_instruction_data\"\n            }\n            \n            return {\n                \"success\": True,\n                \"instruction\": mock_instruction,\n                \"input_amount\": amount,\n                \"output_amount\": int(amount * 0.998),  # Mock output with slippage\n                \"price_impact\": 0.1\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating Jupiter swap instruction: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_token_price_jupiter(\n        self, \n        input_mint: str, \n        output_mint: str, \n        amount: int = None\n    ) -> Optional[Decimal]:\n        \"\"\"Get token price from Jupiter\"\"\"\n        try:\n            # This would call Jupiter price API\n            # For now, return mock price based on token pair\n            \n            if input_mint == self.config.TOKENS[\"SOL\"]:\n                if output_mint == self.config.TOKENS[\"USDC\"]:\n                    return Decimal(\"180.50\")  # Mock SOL/USDC price\n                elif output_mint == self.config.TOKENS[\"RAY\"]:\n                    return Decimal(\"120.0\")   # Mock SOL/RAY price\n            elif input_mint == self.config.TOKENS[\"USDC\"]:\n                if output_mint == self.config.TOKENS[\"USDT\"]:\n                    return Decimal(\"1.001\")   # Mock USDC/USDT price\n            \n            return Decimal(\"1.0\")  # Default fallback\n            \n        except Exception as e:\n            logger.error(f\"Error getting Jupiter price: {e}\")\n            return None\n    \n    async def shutdown(self) -> None:\n        \"\"\"Shutdown engine\"\"\"\n        try:\n            if self.client:\n                await self.client.close()\n            logger.info(\"Solana engine shutdown complete\")\n        except Exception as e:\n            logger.error(f\"Error shutting down Solana engine: {e}\")","size_bytes":10592},"dex/solana_service/flashloan_engine.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\nfrom .engine import SolanaEngine\nfrom .config import SolanaConfig\n\nlogger = logging.getLogger(__name__)\n\nclass SolanaFlashLoanEngine(BaseArbitrageEngine):\n    \"\"\"Solana Flash loan arbitrage engine\"\"\"\n    \n    def __init__(self, engine: SolanaEngine, config: SolanaConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Flash loan providers on Solana\n        self.flash_loan_providers = {\n            \"mango_v4\": {\n                \"program_id\": config.MANGO_V4,\n                \"fee\": 0.0001,  # 0.01% very low\n                \"max_amount\": {\n                    config.TOKENS[\"SOL\"]: Decimal(\"100000\"),    # 100K SOL\n                    config.TOKENS[\"USDC\"]: Decimal(\"50000000\"), # 50M USDC\n                    config.TOKENS[\"USDT\"]: Decimal(\"50000000\"), # 50M USDT\n                    config.TOKENS[\"BTC\"]: Decimal(\"2000\"),      # 2K BTC\n                    config.TOKENS[\"ETH\"]: Decimal(\"15000\")      # 15K ETH\n                }\n            },\n            \"solend\": {\n                \"program_id\": config.SOLEND,\n                \"fee\": 0.0005,  # 0.05%\n                \"max_amount\": {\n                    config.TOKENS[\"SOL\"]: Decimal(\"50000\"),     # 50K SOL\n                    config.TOKENS[\"USDC\"]: Decimal(\"25000000\"), # 25M USDC\n                    config.TOKENS[\"USDT\"]: Decimal(\"25000000\")  # 25M USDT\n                }\n            }\n        }\n        \n        # DEX combinations for flash loan arbitrage\n        self.dex_combinations = [\n            (\"jupiter\", \"raydium\"),\n            (\"jupiter\", \"orca\"),\n            (\"raydium\", \"orca\"),\n            (\"raydium\", \"serum\"),\n            (\"orca\", \"serum\")\n        ]\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize flash loan engine\"\"\"\n        try:\n            logger.info(\"Initializing Solana Flash Loan Engine...\")\n            self.initialized = True\n            logger.info(\"Solana Flash Loan Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Solana flash loan engine: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for flash loan arbitrage opportunities on Solana\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            # Check major token pairs for flash loan opportunities\n            major_tokens = [\n                self.config.TOKENS[\"SOL\"],\n                self.config.TOKENS[\"USDC\"],\n                self.config.TOKENS[\"USDT\"],\n                self.config.TOKENS[\"RAY\"],\n                self.config.TOKENS[\"ORCA\"],\n                self.config.TOKENS[\"SRM\"]\n            ]\n            \n            for i, token_a in enumerate(major_tokens):\n                for token_b in major_tokens[i+1:]:\n                    for dex_a, dex_b in self.dex_combinations:\n                        opportunity = await self._check_flash_loan_opportunity(\n                            token_a, token_b, dex_a, dex_b\n                        )\n                        if opportunity:\n                            opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Solana flash loan opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Solana flash loan opportunities: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute flash loan arbitrage on Solana\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Solana flash loan arbitrage: {opportunity.id}\")\n            \n            # Select best flash loan provider\n            provider = await self._select_best_provider(\n                opportunity.token_a, \n                opportunity.loan_amount\n            )\n            \n            if not provider:\n                raise Exception(\"No suitable flash loan provider found\")\n            \n            # Execute flash loan arbitrage\n            result = await self._execute_flash_loan_arbitrage(\n                provider,\n                opportunity\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=result[\"profit_usd\"],\n                    gas_cost_usd=result[\"transaction_cost_usd\"],\n                    execution_time=execution_time,\n                    transaction_hashes=[result[\"tx_signature\"]]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"transaction_cost_usd\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Solana flash loan execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_flash_loan_opportunity(\n        self, \n        token_a: str, \n        token_b: str, \n        dex_a: str, \n        dex_b: str\n    ) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check for flash loan arbitrage opportunity between two DEXes\"\"\"\n        try:\n            # Get prices on both DEXes\n            price_dex_a = await self._get_dex_price(token_a, token_b, dex_a)\n            price_dex_b = await self._get_dex_price(token_a, token_b, dex_b)\n            \n            if not price_dex_a or not price_dex_b:\n                return None\n            \n            # Determine which direction is profitable\n            if price_dex_b > price_dex_a:\n                buy_dex, sell_dex = dex_a, dex_b\n                buy_price, sell_price = price_dex_a, price_dex_b\n            else:\n                buy_dex, sell_dex = dex_b, dex_a\n                buy_price, sell_price = price_dex_b, price_dex_a\n            \n            price_diff = sell_price - buy_price\n            profit_percentage = (price_diff / buy_price) * 100\n            \n            if profit_percentage > Decimal(\"0.2\"):  # Minimum 0.2% price difference\n                # Calculate optimal loan amount\n                loan_amount = await self._calculate_optimal_loan_amount(\n                    token_a, buy_price, sell_price\n                )\n                \n                if loan_amount > Decimal(\"50\"):  # Minimum loan amount\n                    # Calculate expected profit\n                    profit_usd = await self._calculate_flash_loan_profit(\n                        token_a, token_b, loan_amount, buy_price, sell_price\n                    )\n                    \n                    if profit_usd > Decimal(\"5\"):  # Minimum $5 profit\n                        return ArbitrageOpportunity(\n                            id=f\"solana_flash_{buy_dex}_{sell_dex}_{datetime.now().timestamp()}\",\n                            type=\"flash_loan\",\n                            chain=\"solana\",\n                            token_a=token_a,\n                            token_b=token_b,\n                            exchange_a=buy_dex,\n                            exchange_b=sell_dex,\n                            price_a=buy_price,\n                            price_b=sell_price,\n                            price_difference=price_diff,\n                            profit_usd=profit_usd,\n                            gas_cost_usd=await self._estimate_flash_loan_transaction_cost(),\n                            loan_amount=loan_amount,\n                            amount_in=loan_amount,\n                            amount_out=loan_amount * (sell_price / buy_price),\n                            total_liquidity_usd=await self._estimate_dex_liquidity(token_a, token_b),\n                            price_impact=await self._estimate_flash_loan_price_impact(loan_amount),\n                            timestamp=datetime.now()\n                        )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking flash loan opportunity: {e}\")\n            return None\n    \n    async def _get_dex_price(self, token_a: str, token_b: str, dex: str) -> Optional[Decimal]:\n        \"\"\"Get price from specific DEX\"\"\"\n        try:\n            # Get base price for the pair\n            base_price = await self._get_base_price(token_a, token_b)\n            \n            # Apply DEX-specific variations\n            dex_variations = {\n                \"jupiter\": Decimal(\"0.0\"),      # Best aggregated price\n                \"raydium\": Decimal(\"0.002\"),    # Slightly higher\n                \"orca\": Decimal(\"-0.001\"),      # Slightly lower\n                \"serum\": Decimal(\"0.003\"),      # Orderbook spread\n                \"raydium_clmm\": Decimal(\"0.001\") # Concentrated liquidity\n            }\n            \n            variation = dex_variations.get(dex, Decimal(\"0\"))\n            return base_price * (1 + variation)\n            \n        except Exception as e:\n            logger.debug(f\"Error getting {dex} price: {e}\")\n            return None\n    \n    async def _get_base_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get base price for token pair\"\"\"\n        # Mock base prices for Solana pairs\n        if token_a == self.config.TOKENS[\"SOL\"]:\n            if token_b == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"180.00\")  # SOL/USDC\n            elif token_b == self.config.TOKENS[\"RAY\"]:\n                return Decimal(\"120.0\")   # SOL/RAY\n        elif self._is_stablecoin_pair(token_a, token_b):\n            return Decimal(\"1.001\")  # Stablecoin pairs\n        \n        return Decimal(\"1.0\")  # Default\n    \n    def _is_stablecoin_pair(self, token_a: str, token_b: str) -> bool:\n        \"\"\"Check if pair consists of stablecoins\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"]\n        ]\n        return token_a in stablecoins and token_b in stablecoins\n    \n    async def _calculate_optimal_loan_amount(\n        self, \n        token: str, \n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate optimal flash loan amount\"\"\"\n        try:\n            # Get available liquidity from providers\n            max_available = Decimal(\"0\")\n            \n            for provider_data in self.flash_loan_providers.values():\n                provider_max = provider_data[\"max_amount\"].get(token, Decimal(\"0\"))\n                max_available = max(max_available, provider_max)\n            \n            # Calculate amount that maximizes profit considering slippage\n            price_diff = sell_price - buy_price\n            profit_percentage = price_diff / buy_price\n            \n            # Conservative amount for Solana (good liquidity)\n            optimal_amount = min(\n                max_available * Decimal(\"0.1\"),  # 10% of max available\n                Decimal(\"5000\")  # Cap at reasonable amount\n            )\n            \n            return optimal_amount\n            \n        except Exception as e:\n            logger.error(f\"Error calculating optimal loan amount: {e}\")\n            return Decimal(\"100\")  # Fallback\n    \n    async def _calculate_flash_loan_profit(\n        self, \n        token_a: str, \n        token_b: str, \n        loan_amount: Decimal,\n        buy_price: Decimal, \n        sell_price: Decimal\n    ) -> Decimal:\n        \"\"\"Calculate expected profit from flash loan arbitrage\"\"\"\n        try:\n            # Calculate revenue from arbitrage\n            bought_amount = loan_amount / buy_price\n            sold_amount = bought_amount * sell_price\n            gross_profit = sold_amount - loan_amount\n            \n            # Subtract flash loan fee (Mango: 0.01%)\n            flash_loan_fee = loan_amount * Decimal(\"0.0001\")\n            \n            # Subtract DEX fees (average 0.25% each)\n            buy_fee = loan_amount * Decimal(\"0.0025\")\n            sell_fee = sold_amount * Decimal(\"0.0025\")\n            \n            net_profit = gross_profit - flash_loan_fee - buy_fee - sell_fee\n            \n            # Convert to USD\n            token_price_usd = await self._get_token_price_usd(token_a)\n            profit_usd = net_profit * token_price_usd\n            \n            return profit_usd\n            \n        except Exception as e:\n            logger.error(f\"Error calculating flash loan profit: {e}\")\n            return Decimal(\"0\")\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        # Mock USD prices\n        prices = {\n            self.config.TOKENS[\"SOL\"]: Decimal(\"180.00\"),\n            self.config.TOKENS[\"USDC\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"USDT\"]: Decimal(\"1.00\"),\n            self.config.TOKENS[\"RAY\"]: Decimal(\"1.50\"),\n            self.config.TOKENS[\"ORCA\"]: Decimal(\"4.00\"),\n            self.config.TOKENS[\"SRM\"]: Decimal(\"0.60\")\n        }\n        return prices.get(token, Decimal(\"1.00\"))\n    \n    async def _estimate_flash_loan_transaction_cost(self) -> Decimal:\n        \"\"\"Estimate transaction cost for flash loan arbitrage\"\"\"\n        try:\n            # Solana transaction cost for flash loan + 2 swaps (can be batched)\n            base_fee_lamports = 5000\n            compute_fee_lamports = self.config.PRIORITY_FEE_LAMPORTS * 2  # Flash loan + batch swaps\n            \n            total_fee_lamports = base_fee_lamports + compute_fee_lamports\n            total_fee_sol = Decimal(total_fee_lamports) / Decimal(self.config.LAMPORTS_PER_SOL)\n            \n            sol_price_usd = Decimal(\"180.00\")\n            transaction_cost_usd = total_fee_sol * sol_price_usd\n            \n            return transaction_cost_usd\n            \n        except Exception:\n            return Decimal(\"0.02\")  # Very low fallback\n    \n    async def _estimate_dex_liquidity(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Estimate DEX liquidity\"\"\"\n        return Decimal(\"5000000\")  # $5M mock liquidity\n    \n    async def _estimate_flash_loan_price_impact(self, loan_amount: Decimal) -> float:\n        \"\"\"Estimate price impact from flash loan arbitrage\"\"\"\n        # Lower impact due to efficient routing and high liquidity on Solana\n        impact_factor = float(loan_amount) / 100000  # Base factor\n        return min(1.0, 0.02 + impact_factor * 0.0005)  # Cap at 1%\n    \n    async def _select_best_provider(self, token: str, amount: Decimal) -> Optional[Dict]:\n        \"\"\"Select best flash loan provider\"\"\"\n        try:\n            best_provider = None\n            lowest_fee = Decimal(\"999\")\n            \n            for provider_name, provider_data in self.flash_loan_providers.items():\n                max_amount = provider_data[\"max_amount\"].get(token, Decimal(\"0\"))\n                fee = Decimal(str(provider_data[\"fee\"]))\n                \n                if max_amount >= amount and fee < lowest_fee:\n                    lowest_fee = fee\n                    best_provider = {\n                        \"name\": provider_name,\n                        \"data\": provider_data\n                    }\n            \n            return best_provider\n            \n        except Exception as e:\n            logger.error(f\"Error selecting flash loan provider: {e}\")\n            return None\n    \n    async def _execute_flash_loan_arbitrage(\n        self, \n        provider: Dict, \n        opportunity: ArbitrageOpportunity\n    ) -> Dict[str, Any]:\n        \"\"\"Execute flash loan arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing flash loan arbitrage via {provider['name']}\")\n            \n            # Mock execution\n            # This would create a Solana transaction with flash loan + swaps\n            \n            # Simulate successful execution\n            profit_usd = opportunity.profit_usd * Decimal(\"0.95\")  # 95% of expected\n            \n            return {\n                \"success\": True,\n                \"profit_usd\": profit_usd,\n                \"transaction_cost_usd\": Decimal(\"0.015\"),\n                \"tx_signature\": f\"{'sol_flash' * 8}{'f' * 24}\"\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"transaction_cost_usd\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"flash_loan_providers\": list(self.flash_loan_providers.keys()),\n            \"dex_combinations\": len(self.dex_combinations)\n        }","size_bytes":17673},"dex/solana_service/triangular_arbitrage.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nfrom datetime import datetime\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared'))\n\nfrom interfaces.base_engine import BaseArbitrageEngine\nfrom models.arbitrage_models import ArbitrageOpportunity, ExecutionResult\n\n\nfrom .engine import SolanaEngine\nfrom .config import SolanaConfig\n\nlogger = logging.getLogger(__name__)\n\nclass SolanaTriangularArbitrageEngine(BaseArbitrageEngine):\n    \"\"\"Solana Triangular arbitrage engine\"\"\"\n    \n    def __init__(self, engine: SolanaEngine, config: SolanaConfig):\n        self.engine = engine\n        self.config = config\n        self.initialized = False\n        \n        # Triangular arbitrage paths on Solana\n        self.triangular_paths = [\n            # SOL -> USDC -> USDT -> SOL\n            [config.TOKENS[\"SOL\"], config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"]],\n            # SOL -> RAY -> USDC -> SOL\n            [config.TOKENS[\"SOL\"], config.TOKENS[\"RAY\"], config.TOKENS[\"USDC\"]],\n            # SOL -> ORCA -> USDC -> SOL\n            [config.TOKENS[\"SOL\"], config.TOKENS[\"ORCA\"], config.TOKENS[\"USDC\"]],\n            # SOL -> SRM -> USDC -> SOL\n            [config.TOKENS[\"SOL\"], config.TOKENS[\"SRM\"], config.TOKENS[\"USDC\"]],\n            # USDC -> USDT -> RAY -> USDC (involving stablecoins)\n            [config.TOKENS[\"USDC\"], config.TOKENS[\"USDT\"], config.TOKENS[\"RAY\"]],\n        ]\n        \n        # Primary DEX for triangular arbitrage (Jupiter for routing)\n        self.primary_dex = {\n            \"program_id\": config.JUPITER_V6,\n            \"type\": \"aggregator\"\n        }\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize triangular arbitrage engine\"\"\"\n        try:\n            logger.info(\"Initializing Solana Triangular Arbitrage Engine...\")\n            self.initialized = True\n            logger.info(\"Solana Triangular Arbitrage Engine initialized\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize Solana triangular arbitrage: {e}\")\n            raise\n    \n    async def scan_opportunities(self) -> List[ArbitrageOpportunity]:\n        \"\"\"Scan for triangular arbitrage opportunities on Solana\"\"\"\n        if not self.initialized:\n            return []\n        \n        opportunities = []\n        \n        try:\n            for path in self.triangular_paths:\n                opportunity = await self._check_triangular_path(path)\n                if opportunity:\n                    opportunities.append(opportunity)\n            \n            logger.info(f\"Found {len(opportunities)} Solana triangular arbitrage opportunities\")\n            return opportunities\n            \n        except Exception as e:\n            logger.error(f\"Error scanning Solana triangular arbitrage: {e}\")\n            return []\n    \n    async def execute_opportunity(self, opportunity: ArbitrageOpportunity) -> ExecutionResult:\n        \"\"\"Execute triangular arbitrage on Solana\"\"\"\n        start_time = asyncio.get_event_loop().time()\n        \n        try:\n            logger.info(f\"Executing Solana triangular arbitrage: {opportunity.id}\")\n            \n            # Execute the three swaps in sequence\n            result = await self._execute_triangular_swaps(\n                opportunity.token_a,\n                opportunity.token_b, \n                opportunity.token_c,\n                opportunity.amount_in\n            )\n            \n            execution_time = asyncio.get_event_loop().time() - start_time\n            \n            if result[\"success\"]:\n                actual_profit = result[\"final_amount\"] - opportunity.amount_in\n                \n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=True,\n                    profit_usd=actual_profit * result[\"token_price\"],  # Convert to USD\n                    gas_cost_usd=result[\"total_transaction_cost\"],\n                    execution_time=execution_time,\n                    transaction_hashes=result[\"tx_signatures\"]\n                )\n            else:\n                return ExecutionResult(\n                    opportunity_id=opportunity.id,\n                    success=False,\n                    profit_usd=Decimal(\"0\"),\n                    gas_cost_usd=result.get(\"total_transaction_cost\", Decimal(\"0\")),\n                    execution_time=execution_time,\n                    error=result[\"error\"]\n                )\n                \n        except Exception as e:\n            execution_time = asyncio.get_event_loop().time() - start_time\n            logger.error(f\"Solana triangular arbitrage execution failed: {e}\")\n            \n            return ExecutionResult(\n                opportunity_id=opportunity.id,\n                success=False,\n                profit_usd=Decimal(\"0\"),\n                gas_cost_usd=Decimal(\"0\"),\n                execution_time=execution_time,\n                error=str(e)\n            )\n    \n    async def _check_triangular_path(self, path: List[str]) -> Optional[ArbitrageOpportunity]:\n        \"\"\"Check if a triangular path is profitable\"\"\"\n        try:\n            token_a, token_b, token_c = path\n            start_amount = Decimal(\"100.0\")  # 100 units of token_a\n            \n            # Get exchange rates for each step\n            rate_ab = await self._get_exchange_rate(token_a, token_b)\n            rate_bc = await self._get_exchange_rate(token_b, token_c)\n            rate_ca = await self._get_exchange_rate(token_c, token_a)\n            \n            if not all([rate_ab, rate_bc, rate_ca]):\n                return None\n            \n            # Calculate final amount after complete cycle (including fees)\n            fee_rate = Decimal(\"0.0025\")  # Average fee across DEXes\n            amount_b = start_amount * rate_ab * (1 - fee_rate)  # Subtract fee\n            amount_c = amount_b * rate_bc * (1 - fee_rate)       # Subtract fee\n            final_amount = amount_c * rate_ca * (1 - fee_rate)   # Subtract fee\n            \n            profit = final_amount - start_amount\n            profit_percentage = (profit / start_amount) * 100\n            \n            if profit_percentage > Decimal(str(self.config.MIN_PROFIT_THRESHOLD)):\n                # Calculate profit in USD\n                token_a_price_usd = await self._get_token_price_usd(token_a)\n                profit_usd = profit * token_a_price_usd\n                \n                # Check if profit exceeds transaction costs\n                transaction_cost_usd = await self._estimate_triangular_transaction_cost()\n                \n                if profit_usd > transaction_cost_usd + Decimal(\"3\"):  # Minimum $3 net profit\n                    return ArbitrageOpportunity(\n                        id=f\"solana_triangular_{token_a[:8]}_{datetime.now().timestamp()}\",\n                        type=\"triangular\",\n                        chain=\"solana\",\n                        token_a=token_a,\n                        token_b=token_b,\n                        token_c=token_c,\n                        exchange_a=\"jupiter\",\n                        price_a=rate_ab,\n                        price_b=rate_bc,\n                        price_c=rate_ca,\n                        price_difference=profit_percentage,\n                        profit_usd=profit_usd,\n                        gas_cost_usd=transaction_cost_usd,\n                        amount_in=start_amount,\n                        amount_out=final_amount,\n                        amount_ab=amount_b,\n                        amount_bc=amount_c,\n                        total_liquidity_usd=await self._estimate_path_liquidity(path),\n                        price_impact=await self._estimate_triangular_price_impact(start_amount, path),\n                        timestamp=datetime.now()\n                    )\n            \n            return None\n            \n        except Exception as e:\n            logger.debug(f\"Error checking triangular path: {e}\")\n            return None\n    \n    async def _get_exchange_rate(self, token_in: str, token_out: str) -> Optional[Decimal]:\n        \"\"\"Get exchange rate between two tokens\"\"\"\n        try:\n            # Use Jupiter aggregator for best rates\n            if token_in == self.config.TOKENS[\"SOL\"]:\n                if token_out == self.config.TOKENS[\"USDC\"]:\n                    return Decimal(\"180.25\")  # SOL/USDC rate\n                elif token_out == self.config.TOKENS[\"RAY\"]:\n                    return Decimal(\"120.0\")   # SOL/RAY rate\n                elif token_out == self.config.TOKENS[\"ORCA\"]:\n                    return Decimal(\"45.0\")    # SOL/ORCA rate\n                elif token_out == self.config.TOKENS[\"SRM\"]:\n                    return Decimal(\"300.0\")   # SOL/SRM rate\n            elif token_out == self.config.TOKENS[\"SOL\"]:\n                # Inverse rates\n                rate = await self._get_exchange_rate(token_out, token_in)\n                return Decimal(\"1\") / rate if rate else None\n            elif self._is_stablecoin_pair(token_in, token_out):\n                return Decimal(\"1.002\")  # Slight premium for stablecoin swaps\n            elif token_in == self.config.TOKENS[\"RAY\"] and token_out == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"1.48\")  # RAY/USDC\n            elif token_in == self.config.TOKENS[\"ORCA\"] and token_out == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"3.95\")  # ORCA/USDC\n            \n            # Default fallback rate\n            return Decimal(\"1.0\")\n            \n        except Exception as e:\n            logger.debug(f\"Error getting exchange rate {token_in}/{token_out}: {e}\")\n            return None\n    \n    def _is_stablecoin_pair(self, token_in: str, token_out: str) -> bool:\n        \"\"\"Check if both tokens are stablecoins\"\"\"\n        stablecoins = [\n            self.config.TOKENS[\"USDC\"],\n            self.config.TOKENS[\"USDT\"]\n        ]\n        return token_in in stablecoins and token_out in stablecoins\n    \n    async def _get_token_price_usd(self, token: str) -> Decimal:\n        \"\"\"Get token price in USD\"\"\"\n        try:\n            # Mock USD prices for Solana tokens\n            if token == self.config.TOKENS[\"SOL\"]:\n                return Decimal(\"180.00\")\n            elif token == self.config.TOKENS[\"USDC\"]:\n                return Decimal(\"1.00\")\n            elif token == self.config.TOKENS[\"USDT\"]:\n                return Decimal(\"1.00\")\n            elif token == self.config.TOKENS[\"RAY\"]:\n                return Decimal(\"1.50\")\n            elif token == self.config.TOKENS[\"ORCA\"]:\n                return Decimal(\"4.00\")\n            elif token == self.config.TOKENS[\"SRM\"]:\n                return Decimal(\"0.60\")\n            else:\n                return Decimal(\"1.00\")  # Fallback\n                \n        except Exception:\n            return Decimal(\"1.00\")\n    \n    async def _estimate_triangular_transaction_cost(self) -> Decimal:\n        \"\"\"Estimate transaction cost for triangular arbitrage\"\"\"\n        try:\n            # Solana transaction cost for 3 swaps (could be batched)\n            base_fee_lamports = 5000  # Base transaction fee\n            compute_fee_lamports = self.config.PRIORITY_FEE_LAMPORTS * 3  # 3 swaps\n            \n            total_fee_lamports = base_fee_lamports + compute_fee_lamports\n            total_fee_sol = Decimal(total_fee_lamports) / Decimal(self.config.LAMPORTS_PER_SOL)\n            \n            sol_price_usd = Decimal(\"180.00\")\n            transaction_cost_usd = total_fee_sol * sol_price_usd\n            \n            return transaction_cost_usd\n            \n        except Exception:\n            return Decimal(\"0.02\")  # Very low fallback\n    \n    async def _estimate_path_liquidity(self, path: List[str]) -> Decimal:\n        \"\"\"Estimate liquidity for triangular path\"\"\"\n        return Decimal(\"1000000\")  # $1M mock liquidity\n    \n    async def _estimate_triangular_price_impact(self, amount: Decimal, path: List[str]) -> float:\n        \"\"\"Estimate price impact for triangular arbitrage\"\"\"\n        return 0.08  # 0.08%\n    \n    async def _execute_triangular_swaps(\n        self, \n        token_a: str, \n        token_b: str, \n        token_c: str, \n        start_amount: Decimal\n    ) -> Dict[str, Any]:\n        \"\"\"Execute the three swaps for triangular arbitrage\"\"\"\n        try:\n            logger.info(f\"Executing triangular swaps: {token_a} -> {token_b} -> {token_c} -> {token_a}\")\n            \n            # Mock execution using Jupiter aggregator\n            # This could be done as a single batched transaction on Solana\n            \n            # Simulate the three swaps\n            amount_after_first = start_amount * Decimal(\"0.9975\")   # After fees\n            amount_after_second = amount_after_first * Decimal(\"0.9975\")\n            final_amount = amount_after_second * Decimal(\"1.008\")  # Profitable final swap\n            \n            return {\n                \"success\": True,\n                \"final_amount\": final_amount,\n                \"token_price\": await self._get_token_price_usd(token_a),\n                \"total_transaction_cost\": Decimal(\"0.015\"),  # Very low on Solana\n                \"tx_signatures\": [\n                    f\"{'sol_tri_1' * 8}{'1' * 24}\",\n                    f\"{'sol_tri_2' * 8}{'2' * 24}\",\n                    f\"{'sol_tri_3' * 8}{'3' * 24}\"\n                ]\n            }\n            \n        except Exception as e:\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"total_transaction_cost\": Decimal(\"0\")\n            }\n    \n    async def get_health_status(self) -> Dict[str, Any]:\n        \"\"\"Get engine health status\"\"\"\n        return {\n            \"status\": \"healthy\" if self.initialized else \"uninitialized\",\n            \"initialized\": self.initialized,\n            \"triangular_paths\": len(self.triangular_paths),\n            \"primary_dex\": \"jupiter\"\n        }","size_bytes":13907},"dex/shared/interfaces/__init__.py":{"content":"","size_bytes":0},"dex/shared/interfaces/base_engine.py":{"content":"from abc import ABC, abstractmethod\nfrom typing import Dict, List, Optional, Any\nfrom decimal import Decimal\n\nclass BaseEngine(ABC):\n    \"\"\"Base interface for all chain engines\"\"\"\n    \n    @abstractmethod\n    async def initialize(self) -> None:\n        \"\"\"Initialize Web3 connection and contracts\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_balance(self, token_address: str, wallet_address: str) -> Decimal:\n        \"\"\"Get token balance for wallet\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_gas_price(self) -> int:\n        \"\"\"Get current gas price\"\"\"\n        pass\n    \n    @abstractmethod\n    async def execute_transaction(self, tx_data: Dict[str, Any]) -> str:\n        \"\"\"Execute transaction and return tx hash\"\"\"\n        pass\n\nclass BaseArbitrageStrategy(ABC):\n    \"\"\"Base interface for arbitrage strategies\"\"\"\n    \n    @abstractmethod\n    async def scan_opportunities(self) -> List[Dict[str, Any]]:\n        \"\"\"Scan for arbitrage opportunities - returns List[ArbitrageOpportunity]\"\"\"\n        pass\n    \n    @abstractmethod\n    async def calculate_profit(self, opportunity: Dict[str, Any]) -> Decimal:\n        \"\"\"Calculate potential profit for ArbitrageOpportunity\"\"\"\n        pass\n    \n    @abstractmethod\n    async def execute_arbitrage(self, opportunity: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Execute arbitrage with flashloan\"\"\"\n        pass\n\n# Alias for backward compatibility\nBaseArbitrageEngine = BaseArbitrageStrategy\n\nclass BaseProtocolAdapter(ABC):\n    \"\"\"Base interface for DEX protocol adapters\"\"\"\n    \n    @abstractmethod\n    async def get_pair_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get pair price from DEX\"\"\"\n        pass\n    \n    @abstractmethod\n    async def get_liquidity(self, pair_address: str) -> Decimal:\n        \"\"\"Get pair liquidity\"\"\"\n        pass\n    \n    @abstractmethod\n    async def build_swap_data(self, token_in: str, token_out: str, amount: Decimal) -> Dict:\n        \"\"\"Build swap transaction data\"\"\"\n        pass","size_bytes":2006},"dex/shared/models/__init__.py":{"content":"","size_bytes":0},"dex/shared/models/arbitrage_models.py":{"content":"from dataclasses import dataclass\nfrom typing import Optional, List, Dict, Any\nfrom decimal import Decimal\nfrom datetime import datetime\n\n@dataclass\nclass Token:\n    address: str\n    symbol: str\n    decimals: int\n    name: str\n\n@dataclass\nclass DexPair:\n    address: str\n    token_a: Token\n    token_b: Token\n    dex_name: str\n    protocol_version: str  # \"v2\" or \"v3\"\n    fee_tier: Optional[int] = None  # For V3 pools\n\n@dataclass\nclass ArbitrageOpportunity:\n    opportunity_id: str\n    strategy_type: str  # \"cross\", \"triangular\", \"mempool_backrun\"\n    chain: str\n    profit_percentage: Decimal\n    profit_amount_usd: Decimal\n    gas_cost_usd: Decimal\n    net_profit_usd: Decimal\n    detected_at: datetime\n    status: str = \"active\"\n    \n    # Cross arbitrage specific\n    buy_pair: Optional[DexPair] = None\n    sell_pair: Optional[DexPair] = None\n    buy_price: Optional[Decimal] = None\n    sell_price: Optional[Decimal] = None\n    \n    # Triangular arbitrage specific\n    trading_path: Optional[List[DexPair]] = None\n    tokens_path: Optional[List[Token]] = None\n    \n    # Mempool backrun specific\n    target_tx_hash: Optional[str] = None\n    backrun_strategy: Optional[str] = None\n\n@dataclass\nclass FlashLoanParams:\n    provider: str  # \"aave\", \"dydx\", \"balancer\"\n    asset: str\n    amount: Decimal\n    callback_data: Dict[str, Any]\n\n@dataclass\nclass ExecutionResult:\n    tx_hash: str\n    status: str  # \"success\", \"failed\", \"pending\"\n    gas_used: int\n    gas_price: int\n    profit_realized: Optional[Decimal] = None\n    execution_time_ms: Optional[int] = None\n    error_message: Optional[str] = None\n\n@dataclass\nclass CrossChainOpportunity:\n    \"\"\"Cross-chain arbitrage opportunity between different blockchains\"\"\"\n    opportunity_id: str\n    source_chain: str\n    target_chain: str\n    profit_percentage: Decimal\n    profit_amount_usd: Decimal\n    bridge_cost_usd: Decimal\n    net_profit_usd: Decimal\n    detected_at: datetime\n    status: str = \"active\"\n    \n    # Source chain details\n    source_pair: Optional[DexPair] = None\n    source_price: Optional[Decimal] = None\n    \n    # Target chain details  \n    target_pair: Optional[DexPair] = None\n    target_price: Optional[Decimal] = None\n    \n    # Bridge details\n    bridge_protocol: Optional[str] = None\n    bridge_time_mins: Optional[int] = None","size_bytes":2309},"dex/ethereum_service/protocols/v2/__init__.py":{"content":"# V2 DEX protocol adapters (Uniswap V2, SushiSwap, etc.)","size_bytes":56},"dex/ethereum_service/protocols/v2/uniswap_v2.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'shared'))\nfrom interfaces.base_engine import BaseProtocolAdapter\n\nfrom ...engine import EthereumEngine\nfrom ...config import EthereumConfig\nfrom ...uniswap_helper import UniswapHelper\nfrom ...abi_encoder import SwapCallDataEncoder\n\nlogger = logging.getLogger(__name__)\n\nclass UniswapV2Adapter(BaseProtocolAdapter):\n    \"\"\"Uniswap V2 protocol adapter\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.router_address = config.UNISWAP_V2_ROUTER\n        self.factory_address = config.UNISWAP_V2_FACTORY\n        self.fee_rate = Decimal(\"0.003\")  # 0.3% fee\n        self.uniswap_helper = None\n        \n    async def initialize(self):\n        \"\"\"Initialize Uniswap V2 contracts\"\"\"\n        logger.info(\"Initializing Uniswap V2 adapter...\")\n        if self.engine.w3:\n            self.uniswap_helper = UniswapHelper(\n                self.engine.w3,\n                self.factory_address,\n                self.config.UNISWAP_V3_FACTORY\n            )\n    \n    async def get_pair_price(self, token_a: str, token_b: str) -> Decimal:\n        \"\"\"Get current price for token pair\"\"\"\n        try:\n            if not self.uniswap_helper:\n                logger.error(\"UniswapHelper not initialized\")\n                return Decimal(\"0\")\n            \n            # Get pair reserves using helper\n            reserves = await self.uniswap_helper.get_v2_pair_reserves(token_a, token_b)\n            if not reserves:\n                return Decimal(\"0\")\n            \n            reserve_a, reserve_b = reserves\n            if reserve_a == 0 or reserve_b == 0:\n                return Decimal(\"0\")\n            \n            # Calculate price (token_b per token_a)\n            price = self.uniswap_helper.calculate_v2_price(reserve_a, reserve_b)\n            return price\n            \n        except Exception as e:\n            logger.error(f\"Error getting pair price {token_a}/{token_b}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_liquidity(self, pair_address: str) -> Decimal:\n        \"\"\"Get total liquidity in pair\"\"\"\n        try:\n            # Get reserves and calculate USD liquidity\n            # This is simplified - in production would need price feeds\n            return Decimal(\"1000000\")  # Placeholder for now\n            \n        except Exception as e:\n            logger.error(f\"Error getting liquidity for {pair_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def build_swap_data(self, token_in: str, token_out: str, amount: Decimal) -> Dict:\n        \"\"\"Build swap transaction data with proper decimal handling\"\"\"\n        try:\n            if not self.engine.wallet_address or not self.engine.erc20_helper:\n                raise ValueError(\"Wallet or ERC20Helper not available\")\n            \n            # Get token decimals\n            token_in_info = await self.engine.erc20_helper.get_token_info(token_in)\n            token_out_info = await self.engine.erc20_helper.get_token_info(token_out)\n            \n            if not token_in_info or not token_out_info:\n                raise ValueError(\"Could not get token information\")\n            \n            # Calculate minimum amount out with slippage protection\n            amount_out = await self.get_amount_out(amount, token_in, token_out)\n            min_amount_out = amount_out * (1 - self.config.MAX_SLIPPAGE / 100)\n            \n            # Build real swap transaction with proper decimals\n            transaction = SwapCallDataEncoder.build_v2_swap_transaction(\n                self.router_address,\n                token_in,\n                token_out,\n                amount,\n                min_amount_out,\n                self.engine.wallet_address,\n                token_in_info[\"decimals\"],\n                token_out_info[\"decimals\"]\n            )\n            \n            return transaction\n            \n        except Exception as e:\n            logger.error(f\"Error building swap data: {e}\")\n            return {}\n    \n    async def get_amount_out(self, amount_in: Decimal, token_in: str, token_out: str) -> Decimal:\n        \"\"\"Calculate amount out for given input\"\"\"\n        try:\n            if not self.uniswap_helper:\n                logger.error(\"UniswapHelper not initialized\")\n                return Decimal(\"0\")\n            \n            reserves = await self.uniswap_helper.get_v2_pair_reserves(token_in, token_out)\n            if not reserves:\n                return Decimal(\"0\")\n            \n            reserve_in, reserve_out = reserves\n            \n            # Use helper's calculation method\n            amount_out = self.uniswap_helper.calculate_v2_amount_out(amount_in, reserve_in, reserve_out)\n            return amount_out\n            \n        except Exception as e:\n            logger.error(f\"Error calculating amount out: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_pair_address(self, token_a: str, token_b: str) -> str:\n        \"\"\"Get pair contract address for two tokens\"\"\"\n        try:\n            # This would call the factory contract to get the pair address\n            # For now, return a mock address\n            return \"0x1234567890abcdef1234567890abcdef12345678\"\n            \n        except Exception as e:\n            logger.error(f\"Error getting pair address: {e}\")\n            return \"\"\n    \n    \n    async def estimate_gas(self, swap_data: Dict) -> int:\n        \"\"\"Estimate gas for swap transaction\"\"\"\n        try:\n            # Uniswap V2 swaps typically use 120k-150k gas\n            base_gas = 120000\n            \n            # Add extra gas for complex paths\n            path_length = len(swap_data.get(\"params\", {}).get(\"path\", []))\n            if path_length > 2:\n                base_gas += (path_length - 2) * 30000\n            \n            return min(base_gas, 200000)  # Cap at 200k gas\n            \n        except Exception as e:\n            logger.error(f\"Error estimating gas: {e}\")\n            return 150000  # Default estimate","size_bytes":6212},"dex/ethereum_service/protocols/v3/__init__.py":{"content":"# V3 DEX protocol adapters (Uniswap V3, etc.)","size_bytes":45},"dex/ethereum_service/protocols/v3/uniswap_v3.py":{"content":"import asyncio\nimport logging\nfrom decimal import Decimal\nfrom typing import Dict, List, Any, Optional, Tuple\nimport sys\nimport os\n\n# Add shared modules to path\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', 'shared'))\nfrom interfaces.base_engine import BaseProtocolAdapter\n\nfrom ...engine import EthereumEngine\nfrom ...config import EthereumConfig\nfrom ...uniswap_helper import UniswapHelper\nfrom ...abi_encoder import SwapCallDataEncoder\nfrom ...quoter_helper import UniswapV3QuoterHelper\n\nlogger = logging.getLogger(__name__)\n\nclass UniswapV3Adapter(BaseProtocolAdapter):\n    \"\"\"Uniswap V3 protocol adapter with concentrated liquidity\"\"\"\n    \n    def __init__(self, engine: EthereumEngine, config: EthereumConfig):\n        self.engine = engine\n        self.config = config\n        self.router_address = config.UNISWAP_V3_ROUTER\n        self.factory_address = config.UNISWAP_V3_FACTORY\n        self.quoter_address = config.UNISWAP_V3_QUOTER_V2\n        self.uniswap_helper = None\n        self.quoter_helper = None\n        \n        # Common fee tiers in basis points\n        self.fee_tiers = {\n            \"0.01%\": 100,    # Stable pairs\n            \"0.05%\": 500,    # Standard pairs\n            \"0.30%\": 3000,   # Exotic pairs\n            \"1.00%\": 10000   # Very exotic pairs\n        }\n        \n    async def initialize(self):\n        \"\"\"Initialize Uniswap V3 contracts\"\"\"\n        logger.info(\"Initializing Uniswap V3 adapter...\")\n        if self.engine.w3:\n            self.uniswap_helper = UniswapHelper(\n                self.engine.w3,\n                self.config.UNISWAP_V2_FACTORY,\n                self.factory_address\n            )\n            self.quoter_helper = UniswapV3QuoterHelper(\n                self.engine.w3,\n                self.quoter_address\n            )\n    \n    async def get_pair_price(self, token_a: str, token_b: str, fee_tier: int = 3000) -> Decimal:\n        \"\"\"Get current price for token pair with specific fee tier\"\"\"\n        try:\n            if not self.uniswap_helper:\n                logger.error(\"UniswapHelper not initialized\")\n                return Decimal(\"0\")\n            \n            # Get pool data for the fee tier\n            pool_data = await self.uniswap_helper.get_v3_pool_data(token_a, token_b, fee_tier)\n            if not pool_data:\n                return Decimal(\"0\")\n            \n            # Extract current price from sqrtPriceX96\n            sqrt_price_x96 = pool_data.get(\"sqrtPriceX96\", 0)\n            if sqrt_price_x96 == 0:\n                return Decimal(\"0\")\n            \n            # Convert sqrtPriceX96 to actual price\n            price = self.uniswap_helper.sqrt_price_to_price(sqrt_price_x96)\n            return price\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 pair price {token_a}/{token_b}: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_liquidity(self, pair_address: str) -> Decimal:\n        \"\"\"Get active liquidity in V3 pool\"\"\"\n        try:\n            # This would call the pool contract to get liquidity\n            # V3 has concentrated liquidity, so this is the active liquidity\n            return Decimal(\"500000\")  # $500K active liquidity\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 liquidity for {pair_address}: {e}\")\n            return Decimal(\"0\")\n    \n    async def build_swap_data(self, token_in: str, token_out: str, amount: Decimal, fee_tier: int = 3000) -> Dict:\n        \"\"\"Build V3 swap transaction data with proper decimal handling\"\"\"\n        try:\n            if not self.engine.wallet_address or not self.engine.erc20_helper:\n                raise ValueError(\"Wallet or ERC20Helper not available\")\n            \n            # Get token decimals\n            token_in_info = await self.engine.erc20_helper.get_token_info(token_in)\n            token_out_info = await self.engine.erc20_helper.get_token_info(token_out)\n            \n            if not token_in_info or not token_out_info:\n                raise ValueError(\"Could not get token information\")\n            \n            # Calculate minimum amount out\n            amount_out = await self.get_amount_out(amount, token_in, token_out, fee_tier)\n            min_amount_out = amount_out * (1 - self.config.MAX_SLIPPAGE / 100)\n            \n            # Build real swap transaction with proper decimals\n            transaction = SwapCallDataEncoder.build_v3_swap_transaction(\n                self.router_address,\n                token_in,\n                token_out,\n                fee_tier,\n                amount,\n                min_amount_out,\n                self.engine.wallet_address,\n                token_in_info[\"decimals\"],\n                token_out_info[\"decimals\"]\n            )\n            \n            return transaction\n            \n        except Exception as e:\n            logger.error(f\"Error building V3 swap data: {e}\")\n            return {}\n    \n    async def get_amount_out(self, amount_in: Decimal, token_in: str, token_out: str, fee_tier: int = 3000) -> Decimal:\n        \"\"\"Calculate amount out using V3 Quoter for accuracy\"\"\"\n        try:\n            if not self.quoter_helper or not self.engine.erc20_helper:\n                logger.warning(\"Quoter or ERC20Helper not initialized, falling back to pool price\")\n                return await self._get_amount_out_fallback(amount_in, token_in, token_out, fee_tier)\n            \n            # Get token decimals for proper conversion\n            token_in_info = await self.engine.erc20_helper.get_token_info(token_in)\n            token_out_info = await self.engine.erc20_helper.get_token_info(token_out)\n            \n            if not token_in_info or not token_out_info:\n                logger.warning(\"Could not get token info, falling back to pool price\")\n                return await self._get_amount_out_fallback(amount_in, token_in, token_out, fee_tier)\n            \n            # Use real Quoter for accurate quotes\n            amount_out = await self.quoter_helper.get_optimal_amount_out(\n                token_in,\n                token_out,\n                amount_in,\n                token_in_info[\"decimals\"],\n                token_out_info[\"decimals\"],\n                fee_tier\n            )\n            \n            return amount_out\n            \n        except Exception as e:\n            logger.error(f\"Error calculating V3 amount out: {e}\")\n            return await self._get_amount_out_fallback(amount_in, token_in, token_out, fee_tier)\n    \n    async def _get_amount_out_fallback(self, amount_in: Decimal, token_in: str, token_out: str, fee_tier: int) -> Decimal:\n        \"\"\"Fallback method using pool price when Quoter fails\"\"\"\n        try:\n            if not self.uniswap_helper:\n                return Decimal(\"0\")\n                \n            # Get pool data using helper\n            pool_data = await self.uniswap_helper.get_v3_pool_data(token_in, token_out, fee_tier)\n            if not pool_data:\n                return Decimal(\"0\")\n            \n            # Use sqrtPriceX96 for basic price calculation\n            sqrt_price_x96 = pool_data.get(\"sqrtPriceX96\", 0)\n            if sqrt_price_x96 == 0:\n                return Decimal(\"0\")\n            \n            price = self.uniswap_helper.sqrt_price_to_price(sqrt_price_x96)\n            \n            # Apply fee (simplified calculation)\n            fee_multiplier = 1 - (fee_tier / 1000000)  # fee_tier is in hundredths of a bip\n            amount_out = amount_in * price * Decimal(str(fee_multiplier))\n            \n            return amount_out\n            \n        except Exception as e:\n            logger.error(f\"Error in fallback amount calculation: {e}\")\n            return Decimal(\"0\")\n    \n    async def get_pool_address(self, token_a: str, token_b: str, fee_tier: int) -> str:\n        \"\"\"Get V3 pool address for tokens and fee tier\"\"\"\n        try:\n            # This would call the factory to compute pool address\n            return f\"0xabcdef{fee_tier}1234567890abcdef12345678\"\n            \n        except Exception as e:\n            logger.error(f\"Error getting V3 pool address: {e}\")\n            return \"\"\n    \n    async def get_best_fee_tier(self, token_a: str, token_b: str) -> int:\n        \"\"\"Find the fee tier with the most liquidity\"\"\"\n        try:\n            if not self.uniswap_helper:\n                logger.error(\"UniswapHelper not initialized\")\n                return 3000\n            \n            return await self.uniswap_helper.get_best_v3_fee_tier(token_a, token_b)\n            \n        except Exception as e:\n            logger.error(f\"Error finding best fee tier: {e}\")\n            return 3000  # Default\n    \n    \n    async def estimate_gas(self, swap_data: Dict) -> int:\n        \"\"\"Estimate gas for V3 swap transaction\"\"\"\n        try:\n            # V3 swaps typically use more gas than V2 due to complexity\n            return 180000\n            \n        except Exception as e:\n            logger.error(f\"Error estimating V3 gas: {e}\")\n            return 200000  # Default estimate","size_bytes":9030},"dex/orchestrator/service_registry.py":{"content":"import asyncio\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport json\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ServiceMetadata:\n    name: str\n    service_type: str\n    version: str\n    chain_id: int\n    capabilities: List[str]\n    endpoints: Dict[str, str]\n    health_check_url: str\n    last_heartbeat: datetime\n    status: str\n\nclass ServiceRegistry:\n    \"\"\"Registry for managing blockchain microservices\"\"\"\n    \n    def __init__(self):\n        self.services: Dict[str, Any] = {}\n        self.service_metadata: Dict[str, ServiceMetadata] = {}\n        self.service_health: Dict[str, Dict] = {}\n        \n    async def initialize(self) -> None:\n        \"\"\"Initialize service registry\"\"\"\n        logger.info(\"Initializing Service Registry...\")\n        \n        # Start heartbeat monitor\n        asyncio.create_task(self._heartbeat_monitor())\n        \n        logger.info(\"Service Registry initialized\")\n    \n    async def register_service(\n        self, \n        service_name: str, \n        service_instance: Any,\n        metadata: Optional[ServiceMetadata] = None\n    ) -> None:\n        \"\"\"Register a blockchain service\"\"\"\n        try:\n            self.services[service_name] = service_instance\n            \n            if metadata:\n                self.service_metadata[service_name] = metadata\n            else:\n                # Create default metadata\n                self.service_metadata[service_name] = ServiceMetadata(\n                    name=service_name,\n                    service_type=\"blockchain_service\",\n                    version=\"1.0.0\",\n                    chain_id=getattr(service_instance, 'chain_id', 1),\n                    capabilities=await self._discover_capabilities(service_instance),\n                    endpoints={},\n                    health_check_url=\"\",\n                    last_heartbeat=datetime.now(),\n                    status=\"registered\"\n                )\n            \n            # Initialize health tracking\n            self.service_health[service_name] = {\n                \"status\": \"healthy\",\n                \"last_check\": datetime.now(),\n                \"response_time\": 0.0,\n                \"error_count\": 0,\n                \"uptime\": 100.0\n            }\n            \n            logger.info(f\"Registered service: {service_name}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to register service {service_name}: {e}\")\n            raise\n    \n    async def _discover_capabilities(self, service_instance: Any) -> List[str]:\n        \"\"\"Discover service capabilities\"\"\"\n        capabilities = []\n        \n        # Check for common arbitrage capabilities\n        if hasattr(service_instance, 'cross_arbitrage'):\n            capabilities.append(\"cross_arbitrage\")\n        \n        if hasattr(service_instance, 'triangular_arbitrage'):\n            capabilities.append(\"triangular_arbitrage\")\n        \n        if hasattr(service_instance, 'flash_loan'):\n            capabilities.append(\"flash_loan\")\n        \n        if hasattr(service_instance, 'mempool_monitor'):\n            capabilities.append(\"mempool_monitoring\")\n        \n        return capabilities\n    \n    async def get_service(self, service_name: str) -> Optional[Any]:\n        \"\"\"Get a registered service instance\"\"\"\n        return self.services.get(service_name)\n    \n    async def get_services_by_capability(self, capability: str) -> List[str]:\n        \"\"\"Get services that support a specific capability\"\"\"\n        matching_services = []\n        \n        for service_name, metadata in self.service_metadata.items():\n            if capability in metadata.capabilities:\n                matching_services.append(service_name)\n        \n        return matching_services\n    \n    async def get_healthy_services(self) -> List[str]:\n        \"\"\"Get list of currently healthy services\"\"\"\n        healthy_services = []\n        \n        for service_name, health in self.service_health.items():\n            if health[\"status\"] == \"healthy\":\n                healthy_services.append(service_name)\n        \n        return healthy_services\n    \n    async def update_service_health(\n        self, \n        service_name: str, \n        health_data: Dict[str, Any]\n    ) -> None:\n        \"\"\"Update service health information\"\"\"\n        if service_name in self.service_health:\n            self.service_health[service_name].update(health_data)\n            self.service_health[service_name][\"last_check\"] = datetime.now()\n    \n    async def _heartbeat_monitor(self) -> None:\n        \"\"\"Monitor service heartbeats\"\"\"\n        while True:\n            try:\n                current_time = datetime.now()\n                \n                for service_name, metadata in self.service_metadata.items():\n                    # Check if service is still responsive\n                    try:\n                        service = self.services.get(service_name)\n                        if service and hasattr(service, 'ping'):\n                            start_time = asyncio.get_event_loop().time()\n                            await service.ping()\n                            response_time = asyncio.get_event_loop().time() - start_time\n                            \n                            await self.update_service_health(service_name, {\n                                \"status\": \"healthy\",\n                                \"response_time\": response_time,\n                                \"error_count\": 0\n                            })\n                            \n                    except Exception as e:\n                        logger.warning(f\"Heartbeat failed for {service_name}: {e}\")\n                        \n                        # Increment error count\n                        health = self.service_health.get(service_name, {})\n                        error_count = health.get(\"error_count\", 0) + 1\n                        \n                        await self.update_service_health(service_name, {\n                            \"status\": \"unhealthy\" if error_count > 3 else \"degraded\",\n                            \"error_count\": error_count\n                        })\n                \n                await asyncio.sleep(30)  # Check every 30 seconds\n                \n            except Exception as e:\n                logger.error(f\"Error in heartbeat monitor: {e}\")\n                await asyncio.sleep(60)\n    \n    async def get_service_status(self, service_name: str) -> Dict[str, Any]:\n        \"\"\"Get detailed status for a specific service\"\"\"\n        if service_name not in self.services:\n            return {\"error\": \"Service not found\"}\n        \n        metadata = self.service_metadata.get(service_name, {})\n        health = self.service_health.get(service_name, {})\n        \n        return {\n            \"name\": service_name,\n            \"metadata\": metadata.__dict__ if hasattr(metadata, '__dict__') else metadata,\n            \"health\": health,\n            \"registered\": True\n        }\n    \n    async def get_all_services_status(self) -> Dict[str, Any]:\n        \"\"\"Get status for all registered services\"\"\"\n        all_status = {}\n        \n        for service_name in self.services.keys():\n            all_status[service_name] = await self.get_service_status(service_name)\n        \n        return all_status\n    \n    async def unregister_service(self, service_name: str) -> None:\n        \"\"\"Unregister a service\"\"\"\n        try:\n            if service_name in self.services:\n                service = self.services[service_name]\n                \n                # Try to gracefully shutdown the service\n                if hasattr(service, 'shutdown'):\n                    await service.shutdown()\n                \n                del self.services[service_name]\n            \n            if service_name in self.service_metadata:\n                del self.service_metadata[service_name]\n            \n            if service_name in self.service_health:\n                del self.service_health[service_name]\n            \n            logger.info(f\"Unregistered service: {service_name}\")\n            \n        except Exception as e:\n            logger.error(f\"Error unregistering service {service_name}: {e}\")\n    \n    async def restart_service(self, service_name: str) -> bool:\n        \"\"\"Restart a specific service\"\"\"\n        try:\n            if service_name not in self.services:\n                return False\n            \n            service = self.services[service_name]\n            \n            # Try to restart the service\n            if hasattr(service, 'restart'):\n                await service.restart()\n            elif hasattr(service, 'shutdown') and hasattr(service, 'initialize'):\n                await service.shutdown()\n                await service.initialize()\n            \n            # Reset health status\n            await self.update_service_health(service_name, {\n                \"status\": \"healthy\",\n                \"error_count\": 0,\n                \"response_time\": 0.0\n            })\n            \n            logger.info(f\"Restarted service: {service_name}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to restart service {service_name}: {e}\")\n            return False","size_bytes":9256},"replit.md":{"content":"# Overview\n\nThis is a comprehensive multi-chain cryptocurrency arbitrage trading system that identifies and executes profitable trading opportunities across centralized exchanges (CEX) and decentralized exchanges (DEX). The system monitors price differences between exchanges and automatically executes trades to capture arbitrage profits using various strategies including cross-exchange arbitrage, triangular arbitrage, and flash loan arbitrage.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Core Components\n\n**CEX Arbitrage Engine**\n- Built with Python using asyncio for concurrent processing\n- Uses CCXT library for exchange integration and WebSocket connections for real-time price feeds\n- Implements cross-exchange and triangular arbitrage strategies\n- Features a Quart-based REST API for trade execution and monitoring\n\n**DEX Arbitrage Engine**\n- Multi-chain architecture supporting Ethereum, BSC, Polygon, and Solana\n- Each chain has dedicated microservices with shared interfaces and models\n- Uses Web3.py for Ethereum-based chains and Solana's Python SDK for Solana operations\n- Implements protocol adapters for major DEXes (Uniswap V2/V3, PancakeSwap, QuickSwap, Raydium, etc.)\n\n**Orchestration Layer**\n- Central coordinator managing all arbitrage engines across chains\n- Opportunity aggregator collecting and filtering profitable trades\n- Risk manager implementing position limits and safety checks\n- Execution coordinator handling trade routing and gas optimization\n\n## Trading Strategies\n\n**Cross-Exchange Arbitrage**\n- Monitors price differences between exchanges for the same trading pair\n- Executes simultaneous buy/sell orders to capture price spreads\n- Supports both CEX-to-CEX and DEX-to-DEX arbitrage\n\n**Triangular Arbitrage**\n- Identifies circular trading opportunities within single exchanges\n- Example: ETH → USDC → DAI → ETH for profit\n- Uses mathematical calculations to detect profitable trading paths\n\n**Flash Loan Arbitrage**\n- Leverages flash loans for capital-free arbitrage execution\n- Integrates with Aave, dYdX, and other lending protocols\n- Enables large-scale arbitrage without upfront capital requirements\n\n## Configuration Management\n\n**Environment-Based Configuration**\n- Uses .env files and environment variables for sensitive data\n- Separate configuration classes for each chain and service\n- Validates required parameters on startup with meaningful error messages\n\n**Trading Parameters**\n- Configurable profit thresholds, gas limits, and position sizes\n- Support for multiple trading pairs and exchange selection\n- Risk management parameters including maximum slippage and trade amounts\n\n## Real-Time Monitoring\n\n**WebSocket Price Feeds**\n- Maintains persistent connections to exchange WebSocket APIs\n- Implements automatic reconnection with exponential backoff\n- Caches price data with timestamp tracking for opportunity detection\n\n**Telegram Integration**\n- Real-time alerts for detected opportunities\n- Interactive buttons for manual trade execution approval\n- Whitelisted chat support for security\n\n## Database and Storage\n\n**In-Memory Caching**\n- Price cache with TTL for fast opportunity detection\n- Account balance tracking with periodic updates\n- Trade history and execution metrics storage\n\n**Configuration Storage**\n- Dynamic configuration updates via API endpoints\n- Supports hot-reloading of trading parameters\n- Maintains audit trail of configuration changes\n\n## Error Handling and Resilience\n\n**Robust Error Management**\n- Comprehensive exception handling with detailed logging\n- Automatic retry mechanisms for failed operations\n- Circuit breaker patterns for external service calls\n\n**Health Monitoring**\n- Service health checks with status reporting\n- Automatic failover and recovery mechanisms\n- Performance metrics and execution tracking\n\n# External Dependencies\n\n## Centralized Exchange APIs\n- **CCXT Library**: Unified interface for 150+ cryptocurrency exchanges\n- **WebSocket Connections**: Real-time price feeds from Binance, OKEx, Bybit, and others\n- **Rate Limiting**: Compliance with exchange API limits and authentication\n\n## Blockchain Networks\n- **Ethereum**: Web3.py for smart contract interactions, Infura/Alchemy for RPC access\n- **BSC**: Binance Smart Chain with PancakeSwap and other DEX integrations\n- **Polygon**: Polygon PoS chain with QuickSwap and Uniswap V3 support\n- **Solana**: Native Solana RPC client with Jupiter aggregator integration\n\n## DeFi Protocols\n- **Uniswap V2/V3**: Automated market maker with concentrated liquidity\n- **SushiSwap**: Multi-chain DEX with additional features\n- **PancakeSwap**: BSC's leading DEX with V2 and V3 protocols\n- **Raydium**: Solana's premier AMM and DEX\n- **Flash Loan Providers**: Aave V3, dYdX, Balancer, Mango V4\n\n## Communication Services\n- **Telegram Bot API**: Alert system with interactive trade execution\n- **Aiogram**: Async Telegram bot framework for Python\n- **WebSocket Libraries**: Real-time communication for price feeds\n\n## Development and Deployment\n- **Quart Framework**: Async web framework for REST API endpoints\n- **Uvicorn**: ASGI server for production deployment\n- **Python-dotenv**: Environment variable management\n- **Structlog**: Structured logging for debugging and monitoring\n\n## Mathematical Libraries\n- **SciPy**: Scientific computing for advanced arbitrage calculations\n- **Decimal**: High-precision decimal arithmetic for financial calculations\n- **Asyncio**: Concurrent programming for real-time trading operations","size_bytes":5535},"dex/unified_service_connector.py":{"content":"\"\"\"\nUnified Service Connector for All Blockchain Services\nInitializes and tests connections across Ethereum, BSC, Polygon, and Solana\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n# Import all chain services\nimport sys\nimport os\nsys.path.append(os.path.dirname(__file__))\n\nfrom ethereum_service.service import EthereumArbitrageService\nfrom bsc_service.arbitrage import BSCArbitrageService\nfrom polygon_service.arbitrage import PolygonArbitrageService  \nfrom solana_service.arbitrage import SolanaArbitrageService\n\n# Import orchestrator\nfrom orchestrator.main import DEXArbitrageOrchestrator\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ChainConnectionStatus:\n    chain: str\n    connected: bool\n    block_number: Optional[int] = None\n    wallet_address: Optional[str] = None\n    error: Optional[str] = None\n    rpc_url: Optional[str] = None\n    last_check: Optional[datetime] = None\n\nclass UnifiedServiceConnector:\n    \"\"\"Unified connector for all blockchain arbitrage services\"\"\"\n    \n    def __init__(self):\n        self.services: Dict[str, Any] = {}\n        self.connection_status: Dict[str, ChainConnectionStatus] = {}\n        self.orchestrator: Optional[DEXArbitrageOrchestrator] = None\n        self.is_initialized = False\n        \n    async def initialize_all_services(self) -> Dict[str, ChainConnectionStatus]:\n        \"\"\"Initialize and test connections for all blockchain services\"\"\"\n        logger.info(\"Initializing all blockchain services...\")\n        \n        # Define services to initialize\n        services_config = [\n            (\"ethereum\", EthereumArbitrageService),\n            (\"bsc\", BSCArbitrageService), \n            (\"polygon\", PolygonArbitrageService),\n            (\"solana\", SolanaArbitrageService)\n        ]\n        \n        # Initialize each service\n        for chain_name, service_class in services_config:\n            status = await self._initialize_chain_service(chain_name, service_class)\n            self.connection_status[chain_name] = status\n            \n        # Initialize orchestrator if any services are connected\n        connected_services = [name for name, status in self.connection_status.items() if status.connected]\n        if connected_services:\n            try:\n                await self._initialize_orchestrator()\n                logger.info(f\"Orchestrator initialized with {len(connected_services)} connected chains\")\n            except Exception as e:\n                logger.error(f\"Failed to initialize orchestrator: {e}\")\n        \n        self.is_initialized = True\n        return self.connection_status\n    \n    async def _initialize_chain_service(self, chain_name: str, service_class) -> ChainConnectionStatus:\n        \"\"\"Initialize a single blockchain service\"\"\"\n        logger.info(f\"Initializing {chain_name} service...\")\n        \n        status = ChainConnectionStatus(\n            chain=chain_name,\n            connected=False,\n            last_check=datetime.now()\n        )\n        \n        try:\n            # Create service instance\n            service = service_class()\n            status.rpc_url = getattr(service.config, 'RPC_URL', 'Unknown')\n            status.wallet_address = getattr(service.config, 'WALLET_ADDRESS', None)\n            \n            # Test basic configuration\n            if hasattr(service.config, 'validate'):\n                try:\n                    service.config.validate()\n                except Exception as e:\n                    status.error = f\"Configuration validation failed: {e}\"\n                    logger.warning(f\"{chain_name} config validation failed: {e}\")\n                    return status\n            \n            # Attempt to initialize the service\n            await service.initialize()\n            \n            # Test connection and get block info\n            if hasattr(service.engine, 'get_block_number'):\n                try:\n                    block_number = await asyncio.wait_for(\n                        service.engine.get_block_number(), \n                        timeout=10.0\n                    )\n                    status.block_number = block_number\n                    status.connected = True\n                    self.services[chain_name] = service\n                    logger.info(f\"{chain_name} connected successfully - Block: {block_number}\")\n                    \n                except asyncio.TimeoutError:\n                    status.error = \"Connection timeout - RPC endpoint may be slow\"\n                    logger.warning(f\"{chain_name} connection timeout\")\n                except Exception as e:\n                    status.error = f\"Block query failed: {e}\"\n                    logger.warning(f\"{chain_name} block query failed: {e}\")\n            else:\n                # For services without block number method, just mark as connected\n                status.connected = True\n                self.services[chain_name] = service\n                logger.info(f\"{chain_name} service initialized (no block query available)\")\n            \n        except Exception as e:\n            status.error = f\"Service initialization failed: {e}\"\n            logger.error(f\"Failed to initialize {chain_name}: {e}\")\n        \n        return status\n    \n    async def _initialize_orchestrator(self):\n        \"\"\"Initialize the DEX orchestrator with connected services\"\"\"\n        self.orchestrator = DEXArbitrageOrchestrator()\n        await self.orchestrator.initialize()\n        \n        # Register connected services with orchestrator\n        for chain_name, service in self.services.items():\n            if hasattr(self.orchestrator, 'service_registry'):\n                await self.orchestrator.service_registry.register_service(chain_name, service)\n    \n    async def test_all_connections(self) -> Dict[str, ChainConnectionStatus]:\n        \"\"\"Test connections for all initialized services\"\"\"\n        logger.info(\"Testing all blockchain connections...\")\n        \n        for chain_name, service in self.services.items():\n            status = self.connection_status.get(chain_name)\n            if not status:\n                continue\n                \n            try:\n                # Update connection status\n                if hasattr(service.engine, 'get_block_number'):\n                    block_number = await asyncio.wait_for(\n                        service.engine.get_block_number(), \n                        timeout=10.0\n                    )\n                    status.block_number = block_number\n                    status.connected = True\n                    status.error = None\n                    logger.info(f\"{chain_name} connection test passed - Block: {block_number}\")\n                else:\n                    # Service is available but no block query method\n                    status.connected = True\n                    status.error = None\n                    logger.info(f\"{chain_name} connection test passed\")\n                    \n            except Exception as e:\n                status.connected = False\n                status.error = f\"Connection test failed: {e}\"\n                logger.error(f\"{chain_name} connection test failed: {e}\")\n                \n            status.last_check = datetime.now()\n        \n        return self.connection_status\n    \n    async def get_service_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive status of all services\"\"\"\n        if not self.is_initialized:\n            return {\"status\": \"not_initialized\", \"services\": {}}\n        \n        service_statuses = {}\n        for chain_name, service in self.services.items():\n            try:\n                if hasattr(service, 'get_status'):\n                    service_statuses[chain_name] = await service.get_status()\n                else:\n                    connection_status = self.connection_status.get(chain_name)\n                    service_statuses[chain_name] = {\n                        \"connected\": connection_status.connected if connection_status else False,\n                        \"error\": connection_status.error if connection_status else None,\n                        \"last_check\": connection_status.last_check.isoformat() if connection_status and connection_status.last_check else None\n                    }\n            except Exception as e:\n                service_statuses[chain_name] = {\"status\": \"error\", \"error\": str(e)}\n        \n        return {\n            \"status\": \"initialized\",\n            \"total_services\": len(self.services),\n            \"connected_services\": len([s for s in self.connection_status.values() if s.connected]),\n            \"services\": service_statuses,\n            \"orchestrator_active\": self.orchestrator is not None,\n            \"last_update\": datetime.now().isoformat()\n        }\n    \n    async def scan_all_opportunities(self) -> Dict[str, List[Any]]:\n        \"\"\"Scan for arbitrage opportunities across all connected chains\"\"\"\n        if not self.is_initialized:\n            return {}\n        \n        all_opportunities = {}\n        \n        for chain_name, service in self.services.items():\n            try:\n                if hasattr(service, 'scan_opportunities'):\n                    opportunities = await service.scan_opportunities()\n                    all_opportunities[chain_name] = opportunities\n                    logger.info(f\"Found {len(opportunities)} opportunities on {chain_name}\")\n                else:\n                    logger.warning(f\"{chain_name} service does not support opportunity scanning\")\n            except Exception as e:\n                logger.error(f\"Failed to scan opportunities on {chain_name}: {e}\")\n                all_opportunities[chain_name] = []\n        \n        return all_opportunities\n    \n    async def shutdown_all_services(self):\n        \"\"\"Gracefully shutdown all services\"\"\"\n        logger.info(\"Shutting down all blockchain services...\")\n        \n        if self.orchestrator:\n            try:\n                await self.orchestrator.shutdown()\n                logger.info(\"Orchestrator shutdown complete\")\n            except Exception as e:\n                logger.error(f\"Error shutting down orchestrator: {e}\")\n        \n        for chain_name, service in self.services.items():\n            try:\n                if hasattr(service, 'stop'):\n                    await service.stop()\n                elif hasattr(service, 'shutdown'):\n                    await service.shutdown()\n                logger.info(f\"{chain_name} service shutdown complete\")\n            except Exception as e:\n                logger.error(f\"Error shutting down {chain_name}: {e}\")\n        \n        self.services.clear()\n        self.connection_status.clear()\n        self.is_initialized = False\n\n# Global connector instance\nunified_connector = UnifiedServiceConnector()\n\nasync def main():\n    \"\"\"Test the unified connector\"\"\"\n    logging.basicConfig(level=logging.INFO)\n    \n    try:\n        # Initialize all services\n        statuses = await unified_connector.initialize_all_services()\n        \n        # Print connection results\n        print(\"\\n=== Blockchain Connection Results ===\")\n        for chain, status in statuses.items():\n            print(f\"{chain.upper():10}: {'✓' if status.connected else '✗'} \"\n                  f\"Block: {status.block_number or 'N/A':>8} \"\n                  f\"{'| ' + status.error if status.error else ''}\")\n        \n        # Test connections\n        print(\"\\n=== Testing Connections ===\")\n        await unified_connector.test_all_connections()\n        \n        # Get detailed status\n        print(\"\\n=== Service Status ===\")\n        detailed_status = await unified_connector.get_service_status()\n        print(f\"Connected Services: {detailed_status['connected_services']}/{detailed_status['total_services']}\")\n        \n        # Keep running for testing\n        print(\"\\n=== System Ready ===\")\n        print(\"Press Ctrl+C to shutdown...\")\n        \n        while True:\n            await asyncio.sleep(1)\n            \n    except KeyboardInterrupt:\n        print(\"\\nShutdown requested...\")\n    except Exception as e:\n        logger.error(f\"Error in main: {e}\")\n    finally:\n        await unified_connector.shutdown_all_services()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":12230},"dex/test_connections.py":{"content":"\"\"\"\nSimple test script to check blockchain connections individually\n\"\"\"\nimport asyncio\nimport logging\nimport os\nfrom datetime import datetime\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def test_ethereum_connection():\n    \"\"\"Test Ethereum connection\"\"\"\n    try:\n        from ethereum_service.config import EthereumConfig\n        from ethereum_service.engine import EthereumEngine\n        \n        config = EthereumConfig()\n        engine = EthereumEngine(config)\n        \n        logger.info(f\"Testing Ethereum connection to: {config.RPC_URL[:50]}...\")\n        await engine.initialize()\n        \n        block_number = await engine.get_block_number()\n        logger.info(f\"✓ Ethereum connected - Block: {block_number}\")\n        \n        if engine.wallet_address:\n            logger.info(f\"✓ Wallet: {engine.wallet_address}\")\n            \n        return True, f\"Block: {block_number}\"\n        \n    except Exception as e:\n        logger.error(f\"✗ Ethereum failed: {e}\")\n        return False, str(e)\n\nasync def test_bsc_connection():\n    \"\"\"Test BSC connection\"\"\"\n    try:\n        from bsc_service.config import BSCConfig\n        from bsc_service.engine import BSCEngine\n        \n        config = BSCConfig()\n        engine = BSCEngine(config)\n        \n        logger.info(f\"Testing BSC connection to: {config.RPC_URL[:50]}...\")\n        await engine.initialize()\n        \n        block_number = await engine.get_block_number()\n        logger.info(f\"✓ BSC connected - Block: {block_number}\")\n        \n        if engine.wallet_address:\n            logger.info(f\"✓ Wallet: {engine.wallet_address}\")\n            \n        return True, f\"Block: {block_number}\"\n        \n    except Exception as e:\n        logger.error(f\"✗ BSC failed: {e}\")\n        return False, str(e)\n\nasync def test_polygon_connection():\n    \"\"\"Test Polygon connection\"\"\"\n    try:\n        from polygon_service.config import PolygonConfig\n        from polygon_service.engine import PolygonEngine\n        \n        config = PolygonConfig()\n        engine = PolygonEngine(config)\n        \n        logger.info(f\"Testing Polygon connection to: {config.RPC_URL[:50]}...\")\n        await engine.initialize()\n        \n        block_number = await engine.get_block_number()\n        logger.info(f\"✓ Polygon connected - Block: {block_number}\")\n        \n        if engine.wallet_address:\n            logger.info(f\"✓ Wallet: {engine.wallet_address}\")\n            \n        return True, f\"Block: {block_number}\"\n        \n    except Exception as e:\n        logger.error(f\"✗ Polygon failed: {e}\")\n        return False, str(e)\n\nasync def test_solana_connection():\n    \"\"\"Test Solana connection\"\"\"\n    try:\n        from solana_service.config import SolanaConfig\n        from solana_service.engine import SolanaEngine\n        \n        config = SolanaConfig()\n        engine = SolanaEngine(config)\n        \n        logger.info(f\"Testing Solana connection to: {config.RPC_URL[:50]}...\")\n        await engine.initialize()\n        \n        # For Solana, we'll try to get slot instead of block\n        if hasattr(engine, 'get_slot'):\n            slot = await engine.get_slot()\n            logger.info(f\"✓ Solana connected - Slot: {slot}\")\n            return True, f\"Slot: {slot}\"\n        else:\n            logger.info(f\"✓ Solana client initialized\")\n            return True, \"Initialized\"\n        \n    except Exception as e:\n        logger.error(f\"✗ Solana failed: {e}\")\n        return False, str(e)\n\nasync def main():\n    \"\"\"Test all blockchain connections\"\"\"\n    print(\"\\n=== Blockchain Connection Test ===\")\n    print(f\"Time: {datetime.now()}\")\n    \n    # Check if secrets are available\n    secrets_status = {\n        \"ETH_RPC_URL\": bool(os.getenv(\"ETH_RPC_URL\")),\n        \"ETH_PRIVATE_KEY\": bool(os.getenv(\"ETH_PRIVATE_KEY\")),\n        \"BSC_RPC_URL\": bool(os.getenv(\"BSC_RPC_URL\")),\n        \"BSC_PRIVATE_KEY\": bool(os.getenv(\"BSC_PRIVATE_KEY\")),\n        \"POLYGON_RPC_URL\": bool(os.getenv(\"POLYGON_RPC_URL\")),\n        \"POLYGON_PRIVATE_KEY\": bool(os.getenv(\"POLYGON_PRIVATE_KEY\")),\n        \"SOLANA_RPC_URL\": bool(os.getenv(\"SOLANA_RPC_URL\")),\n        \"SOLANA_PRIVATE_KEY\": bool(os.getenv(\"SOLANA_PRIVATE_KEY\")),\n    }\n    \n    print(\"\\n=== Secret Status ===\")\n    for key, status in secrets_status.items():\n        print(f\"{key:20}: {'✓' if status else '✗'}\")\n    \n    # Test connections\n    tests = [\n        (\"Ethereum\", test_ethereum_connection),\n        (\"BSC\", test_bsc_connection), \n        (\"Polygon\", test_polygon_connection),\n        (\"Solana\", test_solana_connection)\n    ]\n    \n    results = {}\n    print(\"\\n=== Connection Tests ===\")\n    \n    for chain_name, test_func in tests:\n        try:\n            success, info = await test_func()\n            results[chain_name] = {\"success\": success, \"info\": info}\n            status = \"✓\" if success else \"✗\"\n            print(f\"{chain_name:10}: {status} {info}\")\n        except Exception as e:\n            results[chain_name] = {\"success\": False, \"info\": f\"Test failed: {e}\"}\n            print(f\"{chain_name:10}: ✗ Test failed: {e}\")\n    \n    # Summary\n    successful = len([r for r in results.values() if r[\"success\"]])\n    total = len(results)\n    \n    print(f\"\\n=== Summary ===\")\n    print(f\"Connected: {successful}/{total} chains\")\n    \n    if successful > 0:\n        print(\"✓ Ready to proceed with DEX system integration\")\n    else:\n        print(\"✗ No connections successful - check RPC URLs and network access\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":5563}},"version":1}